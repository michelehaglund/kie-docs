<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?><?asciidoc-numbered?><book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info>
<title>Developing decision services in Red Hat Decision Manager</title><subtitle>
</subtitle>

<date>2021-01-26</date>
<productname>Red Hat Decision Manager</productname>
<productnumber>7.10</productnumber>
<abstract>
	<para>This document describes how to develop decision services with Red Hat Decision Manager using Decision Model and Notation (DMN) models, Drools Rule Language (DRL) files, guided decision tables, and other decision-authoring assets.</para>
</abstract>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Common_Content/Legal_Notice.xml"/>
</info>
<preface>
<title>Preface</title>
<simpara>As a developer of business decisions, you can use Red Hat Decision Manager to develop decision services using Decision Model and Notation (DMN) models, Drools Rule Language (DRL) rules, guided decision tables, and other rule-authoring assets.</simpara>
</preface>
<preface xml:id="snip-conscious-language_developing-decision-services">
<title>Making open source more inclusive</title>
<simpara>Red Hat is committed to replacing problematic language in our code, documentation, and web properties. We are beginning with these four terms: master, slave, blacklist, and whitelist. Because of the enormity of this endeavor, these changes will be implemented gradually over several upcoming releases. For more details, see <link xlink:href="https://www.redhat.com/en/blog/making-open-source-more-inclusive-eradicating-problematic-language"><emphasis>our CTO Chris Wright’s message</emphasis></link>.</simpara>
</preface>
<part xml:id="assembly-dmn-models">
<title>Designing a decision service using DMN models</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can use Decision Model and Notation (DMN) to model a decision service graphically. The decision requirements of a DMN decision model are determined by a decision requirements graph (DRG) that is depicted in one or more decision requirements diagrams (DRDs). A DRD can represent part or all of the overall DRG for the DMN model. DRDs trace business decisions from start to finish, with each decision node using logic defined in DMN boxed expressions such as decision tables.</simpara>
<simpara>Red Hat Decision Manager provides design and runtime support for DMN 1.2 models at conformance level 3, and runtime-only support for DMN 1.1 and 1.3 models at conformance level 3. You can design your DMN models directly in Business Central or with the Red Hat Decision Manager DMN modeler in VSCode, or import existing DMN models into your Red Hat Decision Manager projects for deployment and execution. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import into Business Central, open in the DMN designer, and save are converted to DMN 1.2 models.</simpara>
<simpara>For more information about DMN, see the Object Management Group (OMG) <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<simpara>For a step-by-step tutorial with an example DMN decision service, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_dmn-models">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="con-BPMN-DMN-modelers_dmn-models">
<title>Red Hat Decision Manager BPMN and DMN modelers</title>
<simpara>Red Hat Decision Manager provides the following extensions or applications that you can use to design Business Process Model and Notation (BPMN) process models and Decision Model and Notation (DMN) decision models using graphical modelers.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Business Central</emphasis>: Enables you to view and design BPMN models, DMN models, and test scenario files in a related embedded designer.</simpara>
<simpara>To use Business Central, you can set up a development environment containing a Business Central to design business rules and processes, and a KIE Server to execute and test the created business rules and processes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat Decision Manager VSCode extension</emphasis>: Enables you to view and design BPMN models, DMN models, and test scenario files in Visual Studio Code (VSCode). The VSCode extension requires VSCode 1.46.0 or later.</simpara>
<simpara>To install the Red Hat Decision Manager VSCode extension, select the <emphasis role="strong">Extensions</emphasis> menu option in VSCode and search for and install the <emphasis role="strong">Red Hat Business Automation Bundle</emphasis> extension.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Standalone BPMN and DMN editors</emphasis>: Enable you to view and design BPMN and DMN models embedded in your web applications. To download the necessary files, you can either use the NPM artifacts from the <link xlink:href="https://npm.registry.redhat.com/">NPM registry</link> or download the JavaScript files directly for the DMN standalone editor library at <literal><link xlink:href="https://&lt;YOUR_PAGE&gt;/dmn/index.js">https://&lt;YOUR_PAGE&gt;/dmn/index.js</link></literal> and for the BPMN standalone editor library at <literal><link xlink:href="https://&lt;YOUR_PAGE&gt;/bpmn/index.js">https://&lt;YOUR_PAGE&gt;/bpmn/index.js</link></literal>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="proc-vscode-extension_dmn-models">
<title>Installing the Red Hat Decision Manager VSCode extension bundle</title>
<simpara>Red Hat Decision Manager provides a <emphasis role="strong">Red Hat Business Automation Bundle</emphasis> VSCode extension that enables you to design Decision Model and Notation (DMN) decision models, Business Process Model and Notation (BPMN) 2.0 business processes, and test scenarios directly in VSCode. Red Hat Decision Manager also provides individual <emphasis role="strong">DMN Editor</emphasis> and <emphasis role="strong">BPMN Editor</emphasis> VSCode extensions for DMN or BPMN support only, if needed.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xlink:href="https://code.visualstudio.com/">VSCode</link> 1.46.0 or later is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your VSCode IDE, select the <emphasis role="strong">Extensions</emphasis> menu option and search for <emphasis role="strong">Red Hat Business Automation Bundle</emphasis> for DMN, BPMN, and test scenario file support.</simpara>
<simpara>For DMN or BPMN file support only, you can also search for the individual <emphasis role="strong">DMN Editor</emphasis> or <emphasis role="strong">BPMN Editor</emphasis> extensions.</simpara>
</listitem>
<listitem>
<simpara>When the <emphasis role="strong">Red Hat Business Automation Bundle</emphasis> extension appears in VSCode, select it and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>For optimal VSCode editor behavior, after the extension installation is complete, reload or close and re-launch your instance of VSCode.</simpara>
</listitem>
</orderedlist>
<simpara>After you install the VSCode extension bundle, any <literal>.dmn</literal>, <literal>.bpmn</literal>, or <literal>.bpmn2</literal> files that you open in VSCode are automatically displayed as graphical models. Additionally, any <literal>.scesim</literal> files that you open are automatically displayed as tabular test scenario models for testing the functionality of your business decisions.</simpara>
<simpara>If the DMN, BPMN, or test scenario modelers open only the XML source of a DMN, BPMN, or test scenario file and displays an error message, review the reported errors and the model file to ensure that all elements are correctly defined.</simpara>
<note>
<simpara>For new DMN or BPMN models, you can also enter <literal>dmn.new</literal> or <literal>bpmn.new</literal> in a web browser to design your DMN or BPMN model in the online modeler. When you finish creating your model, you can click <emphasis role="strong">Download</emphasis> in the online modeler page to import your DMN or BPMN file into your Red Hat Decision Manager project in VSCode.</simpara>
</note>
</section>
<section xml:id="proc-standalone-editors_dmn-models">
<title>Configuring the Red Hat Decision Manager standalone editors</title>
<simpara>Red Hat Decision Manager provides standalone editors that are distributed in a self-contained library providing an all-in-one JavaScript file for each editor. The JavaScript file uses a comprehensive API to set and control the editor.</simpara>
<simpara>You can install the standalone editors in three ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Download each JavaScript file manually</simpara>
</listitem>
<listitem>
<simpara>Use the NPM package</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the standalone editors using one of the following methods:</simpara>
<simpara><emphasis role="strong">Download each JavaScript file manually</emphasis>: For this method, follow these steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Download the JavaScript files.</simpara>
</listitem>
<listitem>
<simpara>Add the downloaded Javascript files to your hosted application.</simpara>
</listitem>
<listitem>
<simpara>Add the following <literal>&lt;script&gt;</literal> tag to your HTML page:</simpara>
<formalpara>
<title>Script tag for your HTML page for the DMN editor</title>
<para>
<screen>&lt;script src="https://&lt;YOUR_PAGE&gt;/dmn/index.js"&gt;&lt;/script&gt;</screen>
</para>
</formalpara>
<formalpara>
<title>Script tag for your HTML page for the BPMN editor</title>
<para>
<screen>&lt;script src="https://&lt;YOUR_PAGE&gt;/bpmn/index.js"&gt;&lt;/script&gt;</screen>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Use the NPM package</emphasis>: For this method, follow these steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the NPM package to your <literal>package.json</literal> file:</simpara>
<formalpara>
<title>Adding the NPM package</title>
<para>
<screen>npm install @redhat/kogito-tooling-kie-editors-standalone</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Import each editor library to your TypeScript file:</simpara>
<formalpara>
<title>Importing each editor</title>
<para>
<screen>import * as DmnEditor from "@redhat/kogito-tooling-kie-editors-standalone/dist/dmn"
import * as BpmnEditor from "@redhat/kogito-tooling-kie-editors-standalone/dist/bpmn"</screen>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After you install the standalone editors, open the required editor by using the provided editor API, as shown in the following example for opening a DMN editor. The API is the same for each editor.</simpara>
<formalpara>
<title>Opening the DMN standalone editor</title>
<para>
<programlisting language="java" linenumbering="unnumbered">const editor = DmnEditor.open({
  container: document.getElementById("dmn-editor-container"),
  initialContent: Promise.resolve(""),
  readOnly: false,
  origin: "",
  resources: new Map([
    [
      "MyIncludedModel.dmn",
      {
        contentType: "text",
        content: Promise.resolve("")
      }
    ]
  ])
});</programlisting>
</para>
</formalpara>
<simpara>Use the following parameters with the editor API:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>container</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HTML element in which the editor is appended.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>initialContent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Promise to a DMN model content. This parameter can be empty, as shown in the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Promise.resolve("")</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Promise.resolve("&lt;DIAGRAM_CONTENT_DIRECTLY_HERE&gt;")</literal></simpara>
</listitem>
<listitem>
<simpara><literal>fetch("MyDmnModel.dmn").then(content ⇒ content.text())</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>readOnly</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara>Enables you to allow changes in the editor. Set to <literal>false</literal> (default) to allow content editing and <literal>true</literal> for read-only mode in editor.</simpara>
<note>
<simpara>Only the DMN editor supports read-only mode for now.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>origin</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara>Origin of the repository. The default value is <literal>window.location.origin</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>resources</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara>Map of resources for the editor. For example, this parameter is used to provide included models for the DMN editor or work item definitions for the BPMN editor. Each entry in the map contains a resource name and an object that consists of <literal>content-type</literal> (<literal>text</literal> or <literal>binary</literal>) and <literal>content</literal> (similar to the <literal>initialContent</literal> parameter).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The returned object contains the methods that are required to manipulate the editor.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Returned object methods</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">Method</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>getContent(): Promise&lt;string&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Returns a promise containing the editor content.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>setContent(content: string): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the content of the editor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>getPreview(): Promise&lt;string&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Returns a promise containing an SVG string of the current diagram.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>subscribeToContentChanges(callback: (isDirty: boolean) ⇒ void): (isDirty: boolean) ⇒ void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets a callback to be called when the content changes in the editor and returns the same callback to be used for unsubscription.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>unsubscribeToContentChanges(callback: (isDirty: boolean) ⇒ void): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unsubscribes the passed callback when the content changes in the editor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>markAsSaved(): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Resets the editor state that indicates that the content in the editor is saved. Also, it activates the subscribed callbacks related to content change.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>undo(): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Undoes the last change in the editor. Also, it activates the subscribed callbacks related to content change.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>redo(): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Redoes the last undone change in the editor. Also, it activates the subscribed callbacks related to content change.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>close(): void</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Closes the editor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>getElementPosition(selector: string): Promise&lt;Rect&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides an alternative to extend the standard query selector when an element lives inside a canvas or a video component. The <literal>selector</literal> parameter must follow the <literal>&lt;PROVIDER&gt;:::&lt;SELECT&gt;</literal> format, such as <literal>Canvas:::MySquare</literal> or <literal>Video:::PresenterHand</literal>. This method returns a <literal>Rect</literal> representing the element position.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>envelopeApi: MessageBusClientApi&lt;KogitoEditorEnvelopeApi&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an advanced editor API. For more information about advanced editor API, see <link xlink:href="https://github.com/kiegroup/kogito-tooling/blob/master/packages/envelope-bus/src/api/index.ts#L43-L56">MessageBusClientApi</link> and <link xlink:href="https://github.com/kiegroup/kogito-tooling/blob/master/packages/editor/src/api/KogitoEditorEnvelopeApi.ts#L34-L41">KogitoEditorEnvelopeApi</link>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="dmn-con_dmn-models">
<title>Decision Model and Notation (DMN)</title>
<simpara>Decision Model and Notation (DMN) is a standard established by the Object Management Group (OMG) for describing and modeling operational decisions. DMN defines an XML schema that enables DMN models to be shared between DMN-compliant platforms and across organizations so that business analysts and business rules developers can collaborate in designing and implementing DMN decision services. The DMN standard is similar to and can be used together with the Business Process Model and Notation (BPMN) standard for designing and modeling business processes.</simpara>
<simpara>For more information about the background and applications of DMN, see the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<section xml:id="dmn-conformance-levels-con_dmn-models">
<title>DMN conformance levels</title>
<simpara>The DMN specification defines three incremental levels of conformance in a software implementation. A product that claims compliance at one level must also be compliant with any preceding levels. For example, a conformance level 3 implementation must also include the supported components in conformance levels 1 and 2. For the formal definitions of each conformance level, see the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<simpara>The following list summarizes the three DMN conformance levels:</simpara>
<variablelist>
<varlistentry>
<term>Conformance level 1</term>
<listitem>
<simpara>A DMN conformance level 1 implementation supports decision requirement diagrams (DRDs), decision logic, and decision tables, but decision models are not executable. Any language can be used to define the expressions, including natural, unstructured languages.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Conformance level 2</term>
<listitem>
<simpara>A DMN conformance level 2 implementation includes the requirements in conformance level 1, and supports Simplified Friendly Enough Expression Language (S-FEEL) expressions and fully executable decision models.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Conformance level 3</term>
<listitem>
<simpara>A DMN conformance level 3 implementation includes the requirements in conformance levels 1 and 2, and supports Friendly Enough Expression Language (FEEL) expressions, the full set of boxed expressions, and fully executable decision models.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Red Hat Decision Manager provides design and runtime support for DMN 1.2 models at conformance level 3, and runtime-only support for DMN 1.1 and 1.3 models at conformance level 3. You can design your DMN models directly in Business Central or with the Red Hat Decision Manager DMN modeler in VSCode, or import existing DMN models into your Red Hat Decision Manager projects for deployment and execution. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import into Business Central, open in the DMN designer, and save are converted to DMN 1.2 models.</simpara>
</section>
<section xml:id="dmn-drd-components-ref_dmn-models">
<title>DMN decision requirements diagram (DRD) components</title>
<simpara>A decision requirements diagram (DRD) is a visual representation of your DMN model. A DRD can represent part or all of the overall decision requirements graph (DRG) for the DMN model. DRDs trace business decisions using decision nodes, business knowledge models, sources of business knowledge, input data, and decision services.</simpara>
<simpara>The following table summarizes the components in a DRD:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>DRD components</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="40*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_2">Component</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Notation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="4"><simpara>Elements</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top"><simpara>Node where one or more input elements determine an output based on defined decision logic.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-node.png"/>
</imageobject>
<textobject><phrase>dmn decision node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><simpara>Reusable function with one or more decision elements. Decisions that have the same logic but depend on different sub-input data or sub-decisions use business knowledge models to determine which procedure to follow.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-node.png"/>
</imageobject>
<textobject><phrase>dmn bkm node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Knowledge source</simpara></entry>
<entry align="left" valign="top"><simpara>External authorities, documents, committees, or policies that regulate a decision or business knowledge model. Knowledge sources are references to real-world factors rather than executable business rules.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-source-node.png"/>
</imageobject>
<textobject><phrase>dmn knowledge source node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Input data</simpara></entry>
<entry align="left" valign="top"><simpara>Information used in a decision node or a business knowledge model. Input data usually includes business-level concepts or objects relevant to the business, such as loan applicant data used in a lending strategy.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-data-node.png"/>
</imageobject>
<textobject><phrase>dmn input data node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Decision service</simpara></entry>
<entry align="left" valign="top"><simpara>Top-level decision containing a set of reusable decisions published as a service for invocation. A decision service can be invoked from an external application or a BPMN business process.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-service-node.png"/>
</imageobject>
<textobject><phrase>dmn decision service node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="2"><simpara>Requirement connectors</simpara></entry>
<entry align="left" valign="top"><simpara>Information requirement</simpara></entry>
<entry align="left" valign="top"><simpara>Connection from an input data node or decision node to another decision node that requires the information.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-info-connector.png"/>
</imageobject>
<textobject><phrase>dmn info connector</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Knowledge requirement</simpara></entry>
<entry align="left" valign="top"><simpara>Connection from a business knowledge model to a decision node or to another business knowledge model that invokes the decision logic.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-connector.png"/>
</imageobject>
<textobject><phrase>dmn knowledge connector</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Authority requirement</simpara></entry>
<entry align="left" valign="top"><simpara>Connection from an input data node or a decision node to a dependent knowledge source or from a knowledge source to a decision node, business knowledge model, or another knowledge source.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-authority-connector.png"/>
</imageobject>
<textobject><phrase>dmn authority connector</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Artifacts</simpara></entry>
<entry align="left" valign="top"><simpara>Text annotation</simpara></entry>
<entry align="left" valign="top"><simpara>Explanatory note associated with an input data node, decision node, business knowledge model, or knowledge source.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-annotation-node.png"/>
</imageobject>
<textobject><phrase>dmn annotation node</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Association</simpara></entry>
<entry align="left" valign="top"><simpara>Connection from an input data node, decision node, business knowledge model, or knowledge source to a text annotation.</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-association-connector.png"/>
</imageobject>
<textobject><phrase>dmn association connector</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following table summarizes the permitted connectors between DRD elements:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>DRD connector rules</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Starts from</entry>
<entry align="left" valign="top">Connects to</entry>
<entry align="left" valign="top">Connection type</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top"><simpara>Information requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-to-decision.png"/>
</imageobject>
<textobject><phrase>dmn decision to decision</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top" morerows="1"><simpara>Knowledge requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-to-decision.png"/>
</imageobject>
<textobject><phrase>dmn bkm to decision</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-to-bkm.png"/>
</imageobject>
<textobject><phrase>dmn bkm to bkm</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Decision service</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top" morerows="1"><simpara>Knowledge requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-service-to-decision.png"/>
</imageobject>
<textobject><phrase>dmn decision service to decision</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-service-to-bkm.png"/>
</imageobject>
<textobject><phrase>dmn decision service to bkm</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Input data</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top"><simpara>Information requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-to-decision.png"/>
</imageobject>
<textobject><phrase>dmn input to decision</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Knowledge source</simpara></entry>
<entry align="left" valign="top"><simpara>Authority requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-to-knowledge-source.png"/>
</imageobject>
<textobject><phrase>dmn input to knowledge source</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top" morerows="2"><simpara>Knowledge source</simpara></entry>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top" morerows="2"><simpara>Authority requirement</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-source-to-decision.png"/>
</imageobject>
<textobject><phrase>dmn knowledge source to decision</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-source-to-bkm.png"/>
</imageobject>
<textobject><phrase>dmn knowledge source to bkm</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Knowledge source</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-source-to-knowledge-source.png"/>
</imageobject>
<textobject><phrase>dmn knowledge source to knowledge source</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Decision</simpara></entry>
<entry align="left" valign="top" morerows="3"><simpara>Text annotation</simpara></entry>
<entry align="left" valign="top" morerows="3"><simpara>Association</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-to-annotation.png"/>
</imageobject>
<textobject><phrase>dmn decision to annotation</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Business knowledge model</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-to-annotation.png"/>
</imageobject>
<textobject><phrase>dmn bkm to annotation</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Knowledge source</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-knowledge-source-to-annotation.png"/>
</imageobject>
<textobject><phrase>dmn knowledge source to annotation</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Input data</simpara></entry>
<entry align="left" valign="top"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-to-annotation.png"/>
</imageobject>
<textobject><phrase>dmn input to annotation</phrase></textobject>
</mediaobject>
</informalfigure></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following example DRD illustrates some of these DMN components in practice:</simpara>
<figure>
<title>Example DRD: Loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-example-drd.png"/>
</imageobject>
<textobject><phrase>dmn example drd</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following example DRD illustrates DMN components that are part of a reusable decision service:</simpara>
<figure>
<title>Example DRD: Phone call handling as a decision service</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-example-drd3.png" contentwidth="90%"/>
</imageobject>
<textobject><phrase>dmn example drd3</phrase></textobject>
</mediaobject>
</figure>
<simpara>In a DMN decision service node, the decision nodes in the bottom segment incorporate input data from outside of the decision service to arrive at a final decision in the top segment of the decision service node. The resulting top-level decisions from the decision service are then implemented in any subsequent decisions or business knowledge requirements of the DMN model. You can reuse DMN decision services in other DMN models to apply the same decision logic with different input data and different outgoing connections.</simpara>
</section>
<section xml:id="dmn-feel-con_dmn-models">
<title>Rule expressions in FEEL</title>
<simpara>Friendly Enough Expression Language (FEEL) is an expression language defined by the Object Management Group (OMG) DMN specification. FEEL expressions define the logic of a decision in a DMN model. FEEL is designed to facilitate both decision modeling and execution by assigning semantics to the decision model constructs. FEEL expressions in decision requirements diagrams (DRDs) occupy table cells in boxed expressions for decision nodes and business knowledge models.</simpara>
<simpara>For more information about FEEL in DMN, see the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<section xml:id="dmn-feel-data-types-ref_dmn-models">
<title>Data types in FEEL</title>
<simpara>Friendly Enough Expression Language (FEEL) supports the following data types:</simpara>
<itemizedlist>
<listitem>
<simpara>Numbers</simpara>
</listitem>
<listitem>
<simpara>Strings</simpara>
</listitem>
<listitem>
<simpara>Boolean values</simpara>
</listitem>
<listitem>
<simpara>Dates</simpara>
</listitem>
<listitem>
<simpara>Time</simpara>
</listitem>
<listitem>
<simpara>Date and time</simpara>
</listitem>
<listitem>
<simpara>Days and time duration</simpara>
</listitem>
<listitem>
<simpara>Years and months duration</simpara>
</listitem>
<listitem>
<simpara>Functions</simpara>
</listitem>
<listitem>
<simpara>Contexts</simpara>
</listitem>
<listitem>
<simpara>Ranges (or intervals)</simpara>
</listitem>
<listitem>
<simpara>Lists</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The DMN specification currently does not provide an explicit way of declaring a variable as a <literal>function</literal>, <literal>context</literal>, <literal>range</literal>, or <literal>list</literal>, but Red Hat Decision Manager extends the DMN built-in types to support variables of these types.</simpara>
</note>
<simpara>The following list describes each data type:</simpara>
<variablelist>
<varlistentry>
<term>Numbers</term>
<listitem>
<simpara>Numbers in FEEL are based on the <link xlink:href="http://ieeexplore.ieee.org/document/4610935/">IEEE 754-2008</link> Decimal 128 format, with 34 digits of precision. Internally, numbers are represented in Java as <link xlink:href="https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html"><literal>BigDecimals</literal></link> with <literal>MathContext DECIMAL128</literal>. FEEL supports only one number data type, so the same type is used to represent both integers and floating
point numbers.</simpara>
<simpara>FEEL numbers use a dot (<literal>.</literal>) as a decimal separator. FEEL does not support <literal>-INF</literal>, <literal>+INF</literal>, or <literal>NaN</literal>. FEEL uses
<literal>null</literal> to represent invalid numbers.</simpara>
<simpara>Red Hat Decision Manager extends the DMN specification and supports additional number notations:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Scientific:</emphasis> You can use scientific notation with the suffix <literal>e&lt;exp&gt;</literal> or <literal>E&lt;exp&gt;</literal>. For example, <literal>1.2e3</literal> is the same as writing the expression <literal>1.2*10**3</literal>, but is a literal instead of an expression.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hexadecimal:</emphasis> You can use hexadecimal numbers with the prefix <literal>0x</literal>. For example, <literal>0xff</literal> is the same as the decimal number <literal>255</literal>. Both uppercase and lowercase letters are supported. For example, <literal>0XFF</literal> is the same as <literal>0xff</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type suffixes:</emphasis> You can use the type suffixes <literal>f</literal>, <literal>F</literal>, <literal>d</literal>, <literal>D</literal>, <literal>l</literal>, and <literal>L</literal>. These suffixes are ignored.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Strings</term>
<listitem>
<simpara>Strings in FEEL are any sequence of characters delimited by double quotation marks.</simpara>
<formalpara>
<title>Example</title>
<para>
<screen>"John Doe"</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Boolean values</term>
<listitem>
<simpara>FEEL uses three-valued boolean logic, so a boolean logic expression may have values <literal>true</literal>, <literal>false</literal>, or <literal>null</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Dates</term>
<listitem>
<simpara>Date literals are not supported in FEEL, but you can use the built-in <literal>date()</literal> function to construct date values. Date strings in FEEL follow the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#date">XML Schema Part 2: Datatypes</link> document. The format is <literal>"YYYY-MM-DD"</literal> where <literal>YYYY</literal> is the year with four digits, <literal>MM</literal> is the number of the month with two digits, and <literal>DD</literal> is the number of the day.</simpara>
<simpara>Example:</simpara>
<screen>date( "2017-06-23" )</screen>
<simpara>Date objects have time equal to <literal>"00:00:00"</literal>, which is midnight. The dates are considered to be local, without a timezone.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Time</term>
<listitem>
<simpara>Time literals are not supported in FEEL, but you can use the built-in <literal>time()</literal> function to construct time values. Time strings in FEEL follow the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#time">XML Schema Part 2: Datatypes</link> document. The format is <literal>"hh:mm:ss[.uuu][(+-)hh:mm]"</literal> where <literal>hh</literal> is the hour of the day (from <literal>00</literal> to <literal>23</literal>), <literal>mm</literal> is the minutes in the hour, and <literal>ss</literal> is the number of seconds in the minute. Optionally, the string may define the number of milliseconds (<literal>uuu</literal>) within the second and contain a positive (<literal>+</literal>) or negative (<literal>-</literal>) offset from UTC time to define its timezone. Instead of using an offset, you can use the letter <literal>z</literal> to represent the UTC time, which is the same as an offset of <literal>-00:00</literal>. If no offset is defined, the time is considered to be local.</simpara>
<simpara>Examples:</simpara>
<screen>time( "04:25:12" )
time( "14:10:00+02:00" )
time( "22:35:40.345-05:00" )
time( "15:00:30z" )</screen>
<simpara>Time values that define an offset or a timezone cannot be compared to local times that do not define an offset or a timezone.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Date and time</term>
<listitem>
<simpara>Date and time literals are not supported in FEEL, but you can use the built-in <literal>date and time()</literal> function to construct date and time values. Date and time strings in FEEL follow the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#dateTime">XML Schema Part 2: Datatypes</link> document. The format is <literal>"&lt;date&gt;T&lt;time&gt;"</literal>, where <literal>&lt;date&gt;</literal> and <literal>&lt;time&gt;</literal> follow the prescribed XML schema formatting, conjoined by <literal>T</literal>.</simpara>
<simpara>Examples:</simpara>
<screen>date and time( "2017-10-22T23:59:00" )
date and time( "2017-06-13T14:10:00+02:00" )
date and time( "2017-02-05T22:35:40.345-05:00" )
date and time( "2017-06-13T15:00:30z" )</screen>
<simpara>Date and time values that define an offset or a timezone cannot be compared to local date and time values
that do not define an offset or a timezone.</simpara>
<important>
<simpara>If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword <literal>dateTime</literal> as a synonym of <literal>date and time</literal>.</simpara>
</important>
</listitem>
</varlistentry>
<varlistentry>
<term>Days and time duration</term>
<listitem>
<simpara>Days and time duration literals are not supported in FEEL, but you can use the built-in <literal>duration()</literal> function to construct days and time duration values. Days and time duration strings in FEEL follow the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#duration">XML Schema Part 2: Datatypes</link> document, but are restricted to only days, hours, minutes and seconds. Months and years are not supported.</simpara>
<simpara>Examples:</simpara>
<screen>duration( "P1DT23H12M30S" )
duration( "P23D" )
duration( "PT12H" )
duration( "PT35M" )</screen>
<important>
<simpara>If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword <literal>dayTimeDuration</literal> as a synonym of <literal>days and time duration</literal>.</simpara>
</important>
</listitem>
</varlistentry>
<varlistentry>
<term>Years and months duration</term>
<listitem>
<simpara>Years and months duration literals are not supported in FEEL, but you can use the built-in <literal>duration()</literal> function to construct days and time duration values. Years and months duration strings in FEEL follow the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#duration">XML Schema Part 2: Datatypes</link> document, but are restricted to only years and months. Days, hours, minutes, or seconds are not supported.</simpara>
<simpara>Examples:</simpara>
<screen>duration( "P3Y5M" )
duration( "P2Y" )
duration( "P10M" )
duration( "P25M" )</screen>
<important>
<simpara>If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword <literal>yearMonthDuration</literal> as a synonym of <literal>years and months duration</literal>.</simpara>
</important>
</listitem>
</varlistentry>
<varlistentry>
<term>Functions</term>
<listitem>
<simpara>FEEL has <literal>function</literal> literals (or anonymous functions) that you can use to create functions. The DMN specification currently does not provide an explicit way of declaring a variable as a <literal>function</literal>, but Red Hat Decision Manager extends the DMN built-in types to support variables of functions.</simpara>
<simpara>Example:</simpara>
<screen>function(a, b) a + b</screen>
<simpara>In this example, the FEEL expression creates a function that adds the parameters <literal>a</literal> and <literal>b</literal> and returns the result.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Contexts</term>
<listitem>
<simpara>FEEL has <literal>context</literal> literals that you can use to create contexts. A <literal>context</literal> in FEEL is a list of key and value pairs, similar to maps in languages like Java. The DMN specification currently does not provide an explicit way of declaring a variable as a <literal>context</literal>, but Red Hat Decision Manager extends the DMN built-in types to support variables of contexts.</simpara>
<simpara>Example:</simpara>
<screen>{ x : 5, y : 3 }</screen>
<simpara>In this example, the expression creates a context with two entries, <literal>x</literal> and <literal>y</literal>, representing a coordinate in a chart.</simpara>
<simpara>In DMN 1.2, another way to create contexts is to create an item definition that contains the list of keys as attributes, and then declare the variable as having that item definition type.</simpara>
<simpara>The Red Hat Decision Manager DMN API supports DMN <literal>ItemDefinition</literal> structural types in a <literal>DMNContext</literal> represented in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>User-defined Java type: Must be a valid JavaBeans object defining properties and getters for each of the components in the DMN <literal>ItemDefinition</literal>. If necessary, you can also use the <literal>@FEELProperty</literal> annotation for those getters representing a component name which would result in an invalid Java identifier.</simpara>
</listitem>
<listitem>
<simpara><literal>java.util.Map</literal> interface: The map needs to define the appropriate entries, with the keys corresponding to the component name in the DMN <literal>ItemDefinition</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Ranges (or intervals)</term>
<listitem>
<simpara>FEEL has <literal>range</literal> literals that you can use to create ranges or intervals. A <literal>range</literal> in FEEL is a value that defines a lower and an upper bound, where either can be open or closed. The DMN specification currently does not provide an explicit way of declaring a variable as a <literal>range</literal>, but Red Hat Decision Manager extends the DMN built-in types to support variables of ranges.</simpara>
<simpara>The syntax of a range is defined in the following formats:</simpara>
<screen>range          := interval_start endpoint '..' endpoint interval_end
interval_start := open_start | closed_start
open_start     := '(' | ']'
closed_start   := '['
interval_end   := open_end | closed_end
open_end       := ')' | '['
closed_end     := ']'
endpoint       := expression</screen>
<simpara>The expression for the endpoint must return a comparable value, and the lower bound endpoint must be lower than the upper bound endpoint.</simpara>
<simpara>For example, the following literal expression defines an interval between <literal>1</literal> and <literal>10</literal>, including the boundaries (a closed interval on both endpoints):</simpara>
<screen>[ 1 .. 10 ]</screen>
<simpara>The following literal expression defines an interval between 1 hour and 12 hours, including the lower boundary (a closed interval), but excluding the upper boundary (an open interval):</simpara>
<screen>[ duration("PT1H") .. duration("PT12H") )</screen>
<simpara>You can use ranges in decision tables to test for ranges of values, or use ranges in simple literal expressions. For example, the following literal expression returns <literal>true</literal> if the value of a variable <literal>x</literal> is between <literal>0</literal> and <literal>100</literal>:</simpara>
<screen>x in [ 1 .. 100 ]</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>Lists</term>
<listitem>
<simpara>FEEL has <literal>list</literal> literals that you can use to create lists of items. A <literal>list</literal> in FEEL is represented by a comma-separated list of values enclosed in square brackets. The DMN specification currently does not provide an explicit way of declaring a variable as a <literal>list</literal>, but Red Hat Decision Manager extends the DMN built-in types to support variables of lists.</simpara>
<simpara>Example:</simpara>
<screen>[ 2, 3, 4, 5 ]</screen>
<simpara>All lists in FEEL contain elements of the same type and are immutable. Elements in a list can be accessed by index, where the first element is <literal>1</literal>. Negative indexes can access elements starting from the end of the list so that <literal>-1</literal> is the last element.</simpara>
<simpara>For example, the following expression returns the second element of a list <literal>x</literal>:</simpara>
<screen>x[2]</screen>
<simpara>The following expression returns the second-to-last element of a list <literal>x</literal>:</simpara>
<screen>x[-2]</screen>
<simpara>Elements in a list can also be counted by the function <literal>count</literal>, which uses the list of elements as the parameter.</simpara>
<simpara>For example, the following expression returns <literal>4</literal>:</simpara>
<screen>count([ 2, 3, 4, 5 ])</screen>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="ref-dmn-feel-builtin-functions_dmn-models">
<title>Built-in functions in FEEL</title>
<simpara role="_abstract">To promote interoperability with other platforms and systems, Friendly Enough Expression Language (FEEL) includes a library of built-in functions. The built-in FEEL functions are implemented in the Drools Decision Model and Notation (DMN) engine so that you can use the functions in your DMN decision services.</simpara>
<simpara>The following sections describe each built-in FEEL function, listed in the format <literal><emphasis>NAME</emphasis>( <emphasis>PARAMETERS</emphasis> )</literal>. For more information about FEEL functions in DMN, see the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<section xml:id="conversion_functions" remap="_conversion_functions">
<title>Conversion functions</title>
<simpara>The following functions support conversion between values of different types. Some of these functions use specific string formats, such as the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>date string</literal>: Follows the format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#date">XML Schema Part 2: Datatypes</link> document, such as <literal>2020-06-01</literal></simpara>
</listitem>
<listitem>
<simpara><literal>time string</literal>: Follows one of the following formats:</simpara>
<itemizedlist>
<listitem>
<simpara>Format defined in the <link xlink:href="https://www.w3.org/TR/xmlschema-2/#time">XML Schema Part 2: Datatypes</link> document, such as <literal>23:59:00z</literal></simpara>
</listitem>
<listitem>
<simpara>Format for a local time defined by ISO 8601 followed by <literal>@</literal> and an IANA Timezone, such as <literal>00:01:00@Etc/UTC</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>date time string</literal>: Follows the format of a <literal>date string</literal> followed by <literal>T</literal> and a <literal>time string</literal>, such as <literal>2012-12-25T11:00:00Z</literal></simpara>
</listitem>
<listitem>
<simpara><literal>duration string</literal>: Follows the format of <literal>days and time duration</literal> and <literal>years and months duration</literal> defined in the <link xlink:href="https://www.w3.org/TR/xpath-datamodel/#types">XQuery 1.0 and XPath 2.0 Data Model</link>, such as <literal>P1Y2M</literal></simpara>
</listitem>
</itemizedlist>
<variablelist>
<varlistentry>
<term>date( from ) - <emphasis>using date</emphasis></term>
<listitem>
<simpara>Converts <literal>from</literal> to a <literal>date</literal> value.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date( "2012-12-25" ) - date( "2012-12-24" ) = duration( "P1D" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>date( from ) - <emphasis>using date and time</emphasis></term>
<listitem>
<simpara>Converts <literal>from</literal> to a <literal>date</literal> value and sets time components to null.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date(date and time( "2012-12-25T11:00:00Z" )) = date( "2012-12-25" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>date( year, month, day )</term>
<listitem>
<simpara>Produces a <literal>date</literal> from the specified year, month, and day values.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>year</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>month</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>day</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date( 2012, 12, 25 ) = date( "2012-12-25" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>date and time( date, time )</term>
<listitem>
<simpara>Produces a <literal>date and time</literal> from the specified date and ignores any time components and the specified time.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>time</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date and time ( "2012-12-24T23:59:00" ) = date and time(date( "2012-12-24" ), time( "23:59:00" ))</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>date and time( from )</term>
<listitem>
<simpara>Produces a <literal>date and time</literal> from the specified string.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date time string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date and time( "2012-12-24T23:59:00" ) + duration( "PT1M" ) = date and time( "2012-12-25T00:00:00" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>time( from )</term>
<listitem>
<simpara>Produces a <literal>time</literal> from the specified string.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>time string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">time( "23:59:00z" ) + duration( "PT2M" ) = time( "00:01:00@Etc/UTC" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>time( from )</term>
<listitem>
<simpara>Produces a <literal>time</literal> from the specified parameter and ignores any date components.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>time</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">time(date and time( "2012-12-25T11:00:00Z" )) = time( "11:00:00Z" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>time( hour, minute, second, offset? )</term>
<listitem>
<simpara>Produces a <literal>time</literal> from the specified hour, minute, and second component values.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>hour</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>minute</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>second</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>offset</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>days and time duration</literal> or null</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">time( "23:59:00z" ) = time(23, 59, 0, duration( "PT0H" ))</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>number( from, grouping separator, decimal separator )</term>
<listitem>
<simpara>Converts <literal>from</literal> to a <literal>number</literal> using the specified separators.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal> representing a valid number</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>grouping separator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Space ( ), comma (<literal>,</literal>), period (<literal>.</literal>), or null</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>decimal separator</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Same types as <literal>grouping separator</literal>, but the values cannot match</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">number( "1 000,0", " ", "," ) = number( "1,000.0", ",", "." )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>string( from )</term>
<listitem>
<simpara>Provides a string representation of the specified parameter.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Non-null value</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">string( 1.1 ) = "1.1"
string( null ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>duration( from )</term>
<listitem>
<simpara>Converts <literal>from</literal> to a <literal>days and time duration</literal> value or <literal>years and months duration</literal> value.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="30*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Format</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>duration string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">date and time( "2012-12-24T23:59:00" ) - date and time( "2012-12-22T03:45:00" ) = duration( "P2DT20H14M" )
duration( "P2Y2M" ) = duration( "P26M" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>years and months duration( from, to )</term>
<listitem>
<simpara>Calculates the <literal>years and months duration</literal> between the two specified parameters.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>from</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>to</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">years and months duration( date( "2011-12-22" ), date( "2013-08-24" ) ) = duration( "P1Y8M" )</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="boolean_functions" remap="_boolean_functions">
<title>Boolean functions</title>
<simpara>The following functions support Boolean operations.</simpara>
<variablelist>
<varlistentry>
<term>not( negand )</term>
<listitem>
<simpara>Performs the logical negation of the <literal>negand</literal> operand.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>negand</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>boolean</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">not( true ) = false
not( null ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="string_functions" remap="_string_functions">
<title>String functions</title>
<simpara>The following functions support string operations.</simpara>
<note>
<simpara>In FEEL, Unicode characters are counted based on their code points.</simpara>
</note>
<variablelist>
<varlistentry>
<term>substring( string, start position, length? )</term>
<listitem>
<simpara>Returns the substring from the start position for the specified length. The first character is at position value <literal>1</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>start position</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>length</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">substring( "testing",3 ) = "sting"
substring( "testing",3,3 ) = "sti"
substring( "testing", -2, 1 ) = "n"
substring( "\U01F40Eab", 2 ) = "ab"</programlisting>
</para>
</formalpara>
<note>
<simpara>In FEEL, the string literal <literal>"\U01F40Eab"</literal> is the <literal>🐎ab</literal> string (horse symbol followed by <literal>a</literal> and <literal>b</literal>).</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>string length( string )</term>
<listitem>
<simpara>Calculates the length of the specified string.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">string length( "tes" ) = 3
string length( "\U01F40Eab" ) = 3</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>upper case( string )</term>
<listitem>
<simpara>Produces an uppercase version of the specified string.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">upper case( "aBc4" ) = "ABC4"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>lower case( string )</term>
<listitem>
<simpara>Produces a lowercase version of the specified string.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">lower case( "aBc4" ) = "abc4"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>substring before( string, match )</term>
<listitem>
<simpara>Calculates the substring before the match.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">substring before( "testing", "ing" ) = "test"
substring before( "testing", "xyz" ) = ""</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>substring after( string, match )</term>
<listitem>
<simpara>Calculates the substring after the match.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">substring after( "testing", "test" ) = "ing"
substring after( "", "a" ) = ""</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>replace( input, pattern, replacement, flags? )</term>
<listitem>
<simpara>Calculates the regular expression replacement.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>input</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pattern</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>replacement</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>flags</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>This function uses regular expression parameters as defined in <link xlink:href="https://www.w3.org/TR/xquery-operators/#regex-syntax">XQuery 1.0 and XPath 2.0 Functions and Operators</link>.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">replace( "abcd", "(ab)|(a)", "[1=$1][2=$2]" ) = "[1=ab][2=]cd"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>contains( string, match )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the string contains the match.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">contains( "testing", "to" ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>starts with( string, match )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the string starts with the match</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">starts with( "testing", "te" ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>ends with( string, match )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the string ends with the match.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">ends with( "testing", "g" ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>matches( input, pattern, flags? )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the input matches the regular expression.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>input</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pattern</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>flags</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>This function uses regular expression parameters as defined in <link xlink:href="https://www.w3.org/TR/xquery-operators/#regex-syntax">XQuery 1.0 and XPath 2.0 Functions and Operators</link>.</simpara>
</note>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">matches( "teeesting", "^te*sting" ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>split( string, delimiter )</term>
<listitem>
<simpara>Returns a list of the original string and splits it at the delimiter regular expression pattern.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>delimiter</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal> for a regular expression pattern</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>This function uses regular expression parameters as defined in <link xlink:href="https://www.w3.org/TR/xquery-operators/#regex-syntax">XQuery 1.0 and XPath 2.0 Functions and Operators</link>.</simpara>
</note>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">split( "John Doe", "\\s" ) = ["John", "Doe"]
split( "a;b;c;;", ";" ) = ["a","b","c","",""]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="list_functions" remap="_list_functions">
<title>List functions</title>
<simpara>The following functions support list operations.</simpara>
<note>
<simpara>In FEEL, the index of the first element in a list is <literal>1</literal>. The index of the last element in a list can be identified as <literal>-1</literal>.</simpara>
</note>
<variablelist>
<varlistentry>
<term>list contains( list, element )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the list contains the element.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>element</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type, including null</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">list contains( [1,2,3], 2 ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>count( list )</term>
<listitem>
<simpara>Counts the elements in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">count( [1,2,3] ) = 3
count( [] ) = 0
count( [1,[2,3]] ) = 2</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>min( list )</term>
<listitem>
<simpara>Returns the minimum comparable element in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>min( e1, e2, ..., eN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">min( [1,2,3] ) = 1
min( 1 ) = 1
min( [1] ) = 1</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>max( list )</term>
<listitem>
<simpara>Returns the maximum comparable element in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>max( e1, e2, ..., eN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">max( 1,2,3 ) = 3
max( [] ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>sum( list )</term>
<listitem>
<simpara>Returns the sum of the numbers in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>sum( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">sum( [1,2,3] ) = 6
sum( 1,2,3 ) = 6
sum( 1 ) = 1
sum( [] ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>mean( list )</term>
<listitem>
<simpara>Calculates the average (arithmetic mean) of the elements in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>mean( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">mean( [1,2,3] ) = 2
mean( 1,2,3 ) = 2
mean( 1 ) = 1
mean( [] ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>all( list )</term>
<listitem>
<simpara>Returns <literal>true</literal> if all elements in the list are true.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>boolean</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>all( b1, b2, ..., bN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">all( [false,null,true] ) = false
all( true ) = true
all( [true] ) = true
all( [] ) = true
all( 0 ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>any( list )</term>
<listitem>
<simpara>Returns <literal>true</literal> if any element in the list is true.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>boolean</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>any( b1, b2, ..., bN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">any( [false,null,true] ) = true
any( false ) = false
any( [] ) = false
any( 0 ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>sublist( list, start position, length? )</term>
<listitem>
<simpara>Returns the sublist from the start position, limited to the length elements.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>start position</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>length</literal> (Optional)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">sublist( [4,5,6], 1, 2 ) = [4,5]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>append( list, item )</term>
<listitem>
<simpara>Creates a list that is appended to the item or items.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>item</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">append( [1], 2, 3 ) = [1,2,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>concatenate( list )</term>
<listitem>
<simpara>Creates a list that is the result of the concatenated lists.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">concatenate( [1,2],[3] ) = [1,2,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>insert before( list, position, newItem )</term>
<listitem>
<simpara>Creates a list with the <literal>newItem</literal> inserted at the specified position.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>position</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>newItem</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">insert before( [1,3],1,2 ) = [2,1,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>remove( list, position )</term>
<listitem>
<simpara>Creates a list with the removed element excluded from the specified position.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>position</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">remove( [1,2,3], 2 ) = [1,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>reverse( list )</term>
<listitem>
<simpara>Returns a reversed list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">reverse( [1,2,3] ) = [3,2,1]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>index of( list, match )</term>
<listitem>
<simpara>Returns indexes matching the element.</simpara>
<itemizedlist>
<title>Parameters</title>
<listitem>
<simpara><literal>list</literal> of type <literal>list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>match</literal> of any type</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>match</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">index of( [1,2,3,2],2 ) = [2,4]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>union( list )</term>
<listitem>
<simpara>Returns a list of all the elements from multiple lists and excludes duplicates.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">union( [1,2],[2,3] ) = [1,2,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>distinct values( list )</term>
<listitem>
<simpara>Returns a list of elements from a single list and excludes duplicates.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">distinct values( [1,2,3,2,1] ) = [1,2,3]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>flatten( list )</term>
<listitem>
<simpara>Returns a flattened list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">flatten( [[1,2],[[3]], 4] ) = [1,2,3,4]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>product( list )</term>
<listitem>
<simpara>Returns the product of the numbers in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>product( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">product( [2, 3, 4] ) = 24
product( 2, 3, 4 ) = 24</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>median( list )</term>
<listitem>
<simpara>Returns the median of the numbers in the list. If the number of elements is odd, the result is the middle element. If the number of elements is even, the result is the average of the two middle elements.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>median( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">median( 8, 2, 5, 3, 4 ) = 4
median( [6, 1, 2, 3] ) = 2.5
median( [ ] ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>stddev( list )</term>
<listitem>
<simpara>Returns the standard deviation of the numbers in the list.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>stddev( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">stddev( 2, 4, 7, 5 ) = 2.081665999466132735282297706979931
stddev( [47] ) = null
stddev( 47 ) = null
stddev( [ ] ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>mode( list )</term>
<listitem>
<simpara>Returns the mode of the numbers in the list. If multiple elements are returned, the numbers are sorted in ascending order.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal> of <literal>number</literal> elements</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Alternative signature</title>
<para>
<screen>mode( n1, n2, ..., nN )</screen>
</para>
</formalpara>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">mode( 6, 3, 9, 6, 6 ) = [6]
mode( [6, 1, 9, 6, 1] ) = [1, 6]
mode( [ ] ) = [ ]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="numeric_functions" remap="_numeric_functions">
<title>Numeric functions</title>
<simpara>The following functions support number operations.</simpara>
<variablelist>
<varlistentry>
<term>decimal( n, scale )</term>
<listitem>
<simpara>Returns a number with the specified scale.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>scale</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal> in the range <literal>[−6111..6176]</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>This function is implemented to be consistent with the <literal>FEEL:number</literal> definition for rounding decimal numbers to the nearest even decimal number.</simpara>
</note>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">decimal( 1/3, 2 ) = .33
decimal( 1.5, 0 ) = 2
decimal( 2.5, 0 ) = 2
decimal( 1.035, 2 ) = 1.04
decimal( 1.045, 2 ) = 1.04
decimal( 1.055, 2 ) = 1.06
decimal( 1.065, 2 ) = 1.06</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>floor( n )</term>
<listitem>
<simpara>Returns the greatest integer that is less than or equal to the specified number.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">floor( 1.5 ) = 1
floor( -1.5 ) = -2</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ceiling( n )</term>
<listitem>
<simpara>Returns the smallest integer that is greater than or equal to the specified number.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">ceiling( 1.5 ) = 2
ceiling( -1.5 ) = -1</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>abs( n )</term>
<listitem>
<simpara>Returns the absolute value.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal>, <literal>days and time duration</literal>, or <literal>years and months duration</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">abs( 10 ) = 10
abs( -10 ) = 10
abs( @"PT5H" ) = @"PT5H"
abs( @"-PT5H" ) = @"PT5H"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>modulo( dividend, divisor )</term>
<listitem>
<simpara>Returns the remainder of the division of the dividend by the divisor. If either the dividend or divisor is negative, the result is of the same sign as the divisor.</simpara>
<note>
<simpara>This function is also expressed as <literal>modulo(dividend, divisor) = dividend - divisor*floor(dividen d/divisor)</literal>.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>dividend</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>divisor</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">modulo( 12, 5 ) = 2
modulo( -12,5 )= 3
modulo( 12,-5 )= -3
modulo( -12,-5 )= -2
modulo( 10.1, 4.5 )= 1.1
modulo( -10.1, 4.5 )= 3.4
modulo( 10.1, -4.5 )= -3.4
modulo( -10.1, -4.5 )= -1.1</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>sqrt( number )</term>
<listitem>
<simpara>Returns the square root of the specified number.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">sqrt( 16 ) = 4</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>log( number )</term>
<listitem>
<simpara>Returns the logarithm of the specified number.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">decimal( log( 10 ), 2 ) = 2.30</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>exp( number )</term>
<listitem>
<simpara>Returns Euler’s number <literal>e</literal> raised to the power of the specified number.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">decimal( exp( 5 ), 2 ) = 148.41</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>odd( number )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the specified number is odd.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">odd( 5 ) = true
odd( 2 ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>even( number )</term>
<listitem>
<simpara>Returns <literal>true</literal> if the specified number is even.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>number</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">even( 5 ) = false
even ( 2 ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="date_and_time_functions" remap="_date_and_time_functions">
<title>Date and time functions</title>
<simpara>The following functions support date and time operations.</simpara>
<variablelist>
<varlistentry>
<term>is( value1, value2 )</term>
<listitem>
<simpara>Returns <literal>true</literal> if both values are the same element in the FEEL semantic domain.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>value1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>value2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any type</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">is( date( "2012-12-25" ), time( "23:00:50" ) ) = false
is( date( "2012-12-25" ), date( "2012-12-25" ) ) = true
is( time( "23:00:50z" ), time( "23:00:50" ) ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="range_functions" remap="_range_functions">
<title>Range functions</title>
<simpara>The following functions support temporal ordering operations to establish relationships between single scalar values and ranges of such values. These functions are similar to the components in the Health Level Seven (HL7) International <link xlink:href="https://cql.hl7.org/08-a-cqlsyntax.html">Clinical Quality Language (CQL) 1.4 syntax</link>.</simpara>
<variablelist>
<varlistentry>
<term>before( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is before an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>before( point1 point2 )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>before( point range )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>before( range point )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>before( range1,range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>point1 &lt; point2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>point &lt; range.start or ( point = range.start and not(range.start included) )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range.end &lt; point or ( range.end = point and not(range.end included) )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.end &lt; range2.start or (( not(range1.end included) or not(range2.start included) ) and range1.end = range2.start )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">before( 1, 10 ) = true
before( 10, 1 ) = false
before( 1, [1..10] ) = false
before( 1, (1..10] ) = true
before( 1, [5..10] ) = true
before( [1..10], 10 ) = false
before( [1..10), 10 ) = true
before( [1..10], 15 ) = true
before( [1..10], [15..20] ) = true
before( [1..10], [10..20] ) = false
before( [1..10), [10..20] ) = true
before( [1..10], (10..20] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>after( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is after an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>after( point1 point2 )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>after( point range )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>after( range, point )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>after( range1 range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>point1 &gt; point2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>point &gt; range.end or ( point = range.end and not(range.end included) )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range.start &gt; point or ( range.start = point and not(range.start included) )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.start &gt; range2.end or (( not(range1.start included) or not(range2.end included) ) and range1.start = range2.end )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">after( 10, 5 ) = true
after( 5, 10 ) = false
after( 12, [1..10] ) = true
after( 10, [1..10) ) = true
after( 10, [1..10] ) = false
after( [11..20], 12 ) = false
after( [11..20], 10 ) = true
after( (11..20], 11 ) = true
after( [11..20], 11 ) = false
after( [11..20], [1..10] ) = true
after( [1..10], [11..20] ) = false
after( [11..20], [1..11) ) = true
after( (11..20], [1..11] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>meets( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> meets an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>meets( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range1.end included and range2.start included and range1.end = range2.start</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">meets( [1..5], [5..10] ) = true
meets( [1..5), [5..10] ) = false
meets( [1..5], (5..10] ) = false
meets( [1..5], [6..10] ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>met by( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is met by an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>met by( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range1.start included and range2.end included and range1.start = range2.end</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">met by( [5..10], [1..5] ) = true
met by( [5..10], [1..5) ) = false
met by( (5..10], [1..5] ) = false
met by( [6..10], [1..5] ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>overlaps( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> overlaps an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>overlaps( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>( range1.end &gt; range2.start or (range1.end = range2.start and (range1.end included or range2.end included)) ) and ( range1.start &lt; range2.end or (range1.start = range2.end and range1.start included and range2.end included) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">overlaps( [1..5], [3..8] ) = true
overlaps( [3..8], [1..5] ) = true
overlaps( [1..8], [3..5] ) = true
overlaps( [3..5], [1..8] ) = true
overlaps( [1..5], [6..8] ) = false
overlaps( [6..8], [1..5] ) = false
overlaps( [1..5], [5..8] ) = true
overlaps( [1..5], (5..8] ) = false
overlaps( [1..5), [5..8] ) = false
overlaps( [1..5), (5..8] ) = false
overlaps( [5..8], [1..5] ) = true
overlaps( (5..8], [1..5] ) = false
overlaps( [5..8], [1..5) ) = false
overlaps( (5..8], [1..5) ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>overlaps before( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> overlaps before an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>overlaps before( range1 range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>( range1.start &lt; range2.start or (range1.start = range2.start and range1.start included and range2.start included) ) and ( range1.end &gt; range2.start or (range1.end = range2.start and range1.end included and range2.start included) ) and ( range1.end &lt; range2.end or (range1.end = range2.end and (not(range1.end included) or range2.end included )) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">overlaps before( [1..5], [3..8] ) = true
overlaps before( [1..5], [6..8] ) = false
overlaps before( [1..5], [5..8] ) = true
overlaps before( [1..5], (5..8] ) = false
overlaps before( [1..5), [5..8] ) = false
overlaps before( [1..5), (1..5] ) = true
overlaps before( [1..5], (1..5] ) = true
overlaps before( [1..5), [1..5] ) = false
overlaps before( [1..5], [1..5] ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>overlaps after( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> overlaps after an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>overlaps after( range1 range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>( range2.start &lt; range1.start or (range2.start = range1.start and range2.start included and not( range1.start included)) ) and ( range2.end &gt; range1.start or (range2.end = range1.start  and range2.end included and range1.start included) ) and ( range2.end &lt; range1.end or (range2.end = range1.end and (not(range2.end included) or range1.end included)) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">overlaps after( [3..8], [1..5] )= true
overlaps after( [6..8], [1..5] )= false
overlaps after( [5..8], [1..5] )= true
overlaps after( (5..8], [1..5] )= false
overlaps after( [5..8], [1..5) )= false
overlaps after( (1..5], [1..5) )= true
overlaps after( (1..5], [1..5] )= true
overlaps after( [1..5], [1..5) )= false
overlaps after( [1..5], [1..5] )= false
overlaps after( (1..5), [1..5] )= false
overlaps after( (1..5], [1..6] )= false
overlaps after( (1..5], (1..5] )= false
overlaps after( (1..5], [2..5] )= false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>finishes( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> finishes an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>finishes( point, range )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>finishes( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range.end included and range.end = point</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.end included = range2.end included and range1.end = range2.end and ( range1.start &gt; range2.start or (range1.start = range2.start and (not(range1.start included) or range2.start included)) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">finishes( 10, [1..10] ) = true
finishes( 10, [1..10) ) = false
finishes( [5..10], [1..10] ) = true
finishes( [5..10), [1..10] ) = false
finishes( [5..10), [1..10) ) = true
finishes( [1..10], [1..10] ) = true
finishes( (1..10], [1..10] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>finished by( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is finished by an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>finished by( range, point )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>finished by( range1 range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range.end included and range.end = point</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.end included = range2.end included and range1.end = range2.end and ( range1.start &lt; range2.start or (range1.start = range2.start and (range1.start included or not(range2.start included))) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">finished by( [1..10], 10 ) = true
finished by( [1..10), 10 ) = false
finished by( [1..10], [5..10] ) = true
finished by( [1..10], [5..10) ) = false
finished by( [1..10), [5..10) ) = true
finished by( [1..10], [1..10] ) = true
finished by( [1..10], (1..10] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>includes( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> includes an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>includes( range, point )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>includes( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>(range.start &lt; point and range.end &gt; point) or (range.start = point and range.start included) or (range.end = point and range.end included)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>( range1.start &lt; range2.start or (range1.start = range2.start and (range1.start included or not(range2.start included))) ) and ( range1.end &gt; range2.end or (range1.end = range2.end and (range1.end included or not(range2.end included))) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">includes( [1..10], 5 ) = true
includes( [1..10], 12 ) = false
includes( [1..10], 1 ) = true
includes( [1..10], 10 ) = true
includes( (1..10], 1 ) = false
includes( [1..10), 10 ) = false
includes( [1..10], [4..6] ) = true
includes( [1..10], [1..5] ) = true
includes( (1..10], (1..5] ) = true
includes( [1..10], (1..10) ) = true
includes( [1..10), [5..10) ) = true
includes( [1..10], [1..10) ) = true
includes( [1..10], (1..10] ) = true
includes( [1..10], [1..10] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>during( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is during an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>during( point, range )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>during( range1 range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>(range.start &lt; point and range.end &gt; point) or (range.start = point and range.start included) or (range.end = point and range.end included)</literal></simpara>
</listitem>
<listitem>
<simpara><literal>( range2.start &lt; range1.start or (range2.start = range1.start and (range2.start included or not(range1.start included))) ) and ( range2.end &gt; range1.end or (range2.end = range1.end and (range2.end included or not(range1.end included))) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">during( 5, [1..10] ) = true
during( 12, [1..10] ) = false
during( 1, [1..10] ) = true
during( 10, [1..10] ) = true
during( 1, (1..10] ) = false
during( 10, [1..10) ) = false
during( [4..6], [1..10] ) = true
during( [1..5], [1..10] ) = true
during( (1..5], (1..10] ) = true
during( (1..10), [1..10] ) = true
during( [5..10), [1..10) ) = true
during( [1..10), [1..10] ) = true
during( (1..10], [1..10] ) = true
during( [1..10], [1..10] ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>starts( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> starts an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>starts( point, range )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>starts( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range.start = point and range.start included</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.start = range2.start and range1.start included = range2.start included and ( range1.end &lt; range2.end or (range1.end = range2.end and (not(range1.end included) or range2.end included)) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">starts( 1, [1..10] ) = true
starts( 1, (1..10] ) = false
starts( 2, [1..10] ) = false
starts( [1..5], [1..10] ) = true
starts( (1..5], (1..10] ) = true
starts( (1..5], [1..10] ) = false
starts( [1..5], (1..10] ) = false
starts( [1..10], [1..10] ) = true
starts( [1..10), [1..10] ) = true
starts( (1..10), (1..10) ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>started by( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> is started by an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>started by( range, point )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>started by( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>range.start = point and range.start included</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.start = range2.start and range1.start included = range2.start included and ( range2.end &lt; range1.end or (range2.end = range1.end and (not(range2.end included) or range1.end included)) )</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">started by( [1..10], 1 ) = true
started by( (1..10], 1 ) = false
started by( [1..10], 2 ) = false
started by( [1..10], [1..5] ) = true
started by( (1..10], (1..5] ) = true
started by( [1..10], (1..5] ) = false
started by( (1..10], [1..5] ) = false
started by( [1..10], [1..10] ) = true
started by( [1..10], [1..10) ) = true
started by( (1..10), (1..10) ) = true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>coincides( )</term>
<listitem>
<simpara>Returns <literal>true</literal> when an element <literal>A</literal> coincides with an element <literal>B</literal> and when the relevant requirements for evaluating to <literal>true</literal> are also met.</simpara>
<orderedlist numeration="loweralpha">
<title>Signatures</title>
<listitem>
<simpara><literal>coincides( point1, point2 )</literal></simpara>
</listitem>
<listitem>
<simpara><literal>coincides( range1, range2 )</literal></simpara>
</listitem>
</orderedlist>
<orderedlist numeration="loweralpha">
<title>Requirements for evaluating to <literal>true</literal></title>
<listitem>
<simpara><literal>point1 = point2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>range1.start = range2.start and range1.start included = range2.start included and range1.end = range2.end and range1.end included = range2.end included</literal></simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">coincides( 5, 5 ) = true
coincides( 3, 4 ) = false
coincides( [1..5], [1..5] ) = true
coincides( (1..5), [1..5] ) = false
coincides( [1..5], [2..6] ) = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="temporal_functions" remap="_temporal_functions">
<title>Temporal functions</title>
<simpara>The following functions support general temporal operations.</simpara>
<variablelist>
<varlistentry>
<term>day of year( date )</term>
<listitem>
<simpara>Returns the Gregorian number of the day of the year.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">day of year( date(2019, 9, 17) ) = 260</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>day of week( date )</term>
<listitem>
<simpara>Returns the Gregorian day of the week: <literal>"Monday"</literal>, <literal>"Tuesday"</literal>, <literal>"Wednesday"</literal>, <literal>"Thursday"</literal>, <literal>"Friday"</literal>, <literal>"Saturday"</literal>, or <literal>"Sunday"</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">day of week( date(2019, 9, 17) ) = "Tuesday"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>month of year( date )</term>
<listitem>
<simpara>Returns the Gregorian month of the year: <literal>"January"</literal>, <literal>"February"</literal>, <literal>"March"</literal>, <literal>"April"</literal>, <literal>"May"</literal>, <literal>"June"</literal>, <literal>"July"</literal>, <literal>"August"</literal>, <literal>"September"</literal>, <literal>"October"</literal>, <literal>"November"</literal>, or <literal>"December"</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">month of year( date(2019, 9, 17) ) = "September"</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>month of year( date )</term>
<listitem>
<simpara>Returns the Gregorian week of the year as defined by ISO 8601.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>date</literal> or <literal>date and time</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">week of year( date(2019, 9, 17) ) = 38
week of year( date(2003, 12, 29) ) = 1
week of year( date(2004, 1, 4) ) = 1
week of year( date(2005, 1, 1) ) = 53
week of year( date(2005, 1, 3) ) = 1
week of year( date(2005, 1, 9) ) = 1</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="sort_functions" remap="_sort_functions">
<title>Sort functions</title>
<simpara>The following functions support sorting operations.</simpara>
<variablelist>
<varlistentry>
<term>sort( list, precedes )</term>
<listitem>
<simpara>Returns a list of the same elements but ordered according to the sorting function.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>precedes</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>function</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">sort( list: [3,1,4,5,2], precedes: function(x,y) x &lt; y ) = [1,2,3,4,5]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="context_functions" remap="_context_functions">
<title>Context functions</title>
<simpara>The following functions support context operations.</simpara>
<variablelist>
<varlistentry>
<term>get value( m, key )</term>
<listitem>
<simpara>Returns the value from the context for the specified entry key.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>m</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>context</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>key</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>string</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Examples</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">get value( {key1 : "value1"}, "key1" ) = "value1"
get value( {key1 : "value1"}, "unexistent-key" ) = null</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>get entries( m )</term>
<listitem>
<simpara>Returns a list of key-value pairs for the specified context.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>m</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>context</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example</title>
<para>
<programlisting language="FEEL" linenumbering="unnumbered">get entries( {key1 : "value1", key2 : "value2"} ) = [ { key : "key1", value : "value1" }, {key : "key2", value : "value2"} ]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="dmn-feel-variable-function-names-ref_dmn-models">
<title>Variable and function names in FEEL</title>
<simpara>Unlike many traditional expression languages, Friendly Enough Expression Language (FEEL) supports spaces and a few special characters as part of variable and function names. A FEEL name must start with a <literal>letter</literal>, <literal>?</literal>, or <literal>_</literal> element. The unicode letter characters are also allowed. Variable names cannot start with a language keyword, such as <literal>and</literal>, <literal>true</literal>, or <literal>every</literal>. The remaining characters in a variable name can be any of the starting characters, as well as <literal>digits</literal>, white spaces, and special characters such as <literal>+</literal>, <literal>-</literal>, <literal>/</literal>, <literal>*</literal>, <literal>'</literal>, and <literal>.</literal>.</simpara>
<simpara>For example, the following names are all valid FEEL names:</simpara>
<itemizedlist>
<listitem>
<simpara>Age</simpara>
</listitem>
<listitem>
<simpara>Birth Date</simpara>
</listitem>
<listitem>
<simpara>Flight 234 pre-check procedure</simpara>
</listitem>
</itemizedlist>
<simpara>Several limitations apply to variable and function names in FEEL:</simpara>
<variablelist>
<varlistentry>
<term>Ambiguity</term>
<listitem>
<simpara>The use of spaces, keywords, and other special characters as part of names can make FEEL ambiguous. The ambiguities are resolved in the context of the expression, matching names from left to right. The parser resolves the variable name as the longest name matched in scope. You can use <literal>( )</literal> to disambiguate names if necessary.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Spaces in names</term>
<listitem>
<simpara>The DMN specification limits the use of spaces in FEEL names. According to the DMN specification, names can contain multiple spaces but not two consecutive spaces.</simpara>
<simpara>In order to make the language easier to use and avoid common errors due to spaces, Red Hat Decision Manager removes the limitation on the use of consecutive spaces. Red Hat Decision Manager supports variable names with any number of consecutive spaces, but normalizes them into a single space. For example, the variable references <literal>First Name</literal> with one space and <literal>First  Name</literal> with two spaces are both acceptable in Red Hat Decision Manager.</simpara>
<simpara>Red Hat Decision Manager also normalizes the use of other white spaces, like the non-breakable white space that is common in web pages, tabs, and line breaks. From a Red Hat Decision Manager FEEL engine perspective, all of these characters are normalized into a single white space before processing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>The keyword <literal>in</literal></term>
<listitem>
<simpara>The keyword <literal>in</literal> is the only keyword in the language that cannot be used as part of a variable name. Although the specifications allow the use of keywords in the middle of variable names, the use of <literal>in</literal> in variable names conflicts with the grammar definition of <literal>for</literal>, <literal>every</literal> and <literal>some</literal> expression constructs.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="dmn-boxed-expressions-con_dmn-models">
<title>DMN decision logic in boxed expressions</title>
<simpara>Boxed expressions in DMN are tables that you use to define the underlying logic of decision nodes and business knowledge models in a decision requirements diagram (DRD). Some boxed expressions can contain other boxed expressions, but the top-level boxed expression corresponds to the decision logic of a single DRD artifact. While DRDs represent the flow of a DMN decision model, boxed expressions define the actual decision logic of individual nodes. DRDs and boxed expressions together form a complete and functional DMN decision model.</simpara>
<simpara>The following are the types of DMN boxed expressions:</simpara>
<itemizedlist>
<listitem>
<simpara>Decision tables</simpara>
</listitem>
<listitem>
<simpara>Literal expressions</simpara>
</listitem>
<listitem>
<simpara>Contexts</simpara>
</listitem>
<listitem>
<simpara>Relations</simpara>
</listitem>
<listitem>
<simpara>Functions</simpara>
</listitem>
<listitem>
<simpara>Invocations</simpara>
</listitem>
<listitem>
<simpara>Lists</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Red Hat Decision Manager does not provide boxed list expressions in Business Central, but supports a FEEL <literal>list</literal> data type that you can use in boxed literal expressions. For more information about the <literal>list</literal> data type and other FEEL data types in Red Hat Decision Manager, see <xref linkend="dmn-feel-data-types-ref_dmn-models"/>.</simpara>
</note>
<simpara>All Friendly Enough Expression Language (FEEL) expressions that you use in your boxed expressions must conform to the FEEL syntax requirements in the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<section xml:id="dmn-decision-tables-con_dmn-models">
<title>DMN decision tables</title>
<simpara>A decision table in DMN is a visual representation of one or more business rules in a tabular format. You use decision tables to define rules for a decision node that applies those rules at a given point in the decision model. Each rule consists of a single row in the table, and includes columns that define the conditions (input) and outcome (output) for that particular row. The definition of each row is precise enough to derive the outcome using the values of the conditions. Input and output values can be FEEL expressions or defined data type values.</simpara>
<simpara>For example, the following decision table determines credit score ratings based on a defined range of a loan applicant’s credit score:</simpara>
<figure>
<title>Decision table for credit score rating</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example.png"/>
</imageobject>
<textobject><phrase>dmn decision table example</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following decision table determines the next step in a lending strategy for applicants depending on applicant loan eligibility and the bureau call type:</simpara>
<figure>
<title>Decision table for lending strategy</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example2.png"/>
</imageobject>
<textobject><phrase>dmn decision table example2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following decision table determines applicant qualification for a loan as the concluding decision node in a loan prequalification decision model:</simpara>
<figure>
<title>Decision table for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example3.png"/>
</imageobject>
<textobject><phrase>dmn decision table example3</phrase></textobject>
</mediaobject>
</figure>
<simpara>Decision tables are a popular way of modeling rules and decision logic, and are used in many methodologies (such as DMN) and implementation frameworks (such as Drools).</simpara>
<important>
<simpara>Red Hat Decision Manager supports both DMN decision tables and Drools-native decision tables, but they are different types of assets with different syntax requirements and are not interchangeable. For more information about Drools-native decision tables in Red Hat Decision Manager, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link>.</simpara>
</important>
<section xml:id="dmn-decision-tables-hit-policies-con_dmn-models">
<title>Hit policies in DMN decision tables</title>
<simpara>Hit policies determine how to reach an outcome when multiple rules in a decision table match the provided input values. For example, if one rule in a decision table applies a sales discount to military personnel and another rule applies a discount to students, then when a customer is both a student and in the military, the decision table hit policy must indicate whether to apply one discount or the other (<emphasis role="strong">Unique</emphasis>, <emphasis role="strong">First</emphasis>) or both discounts (<emphasis role="strong">Collect Sum</emphasis>). You specify the single character of the hit policy (<emphasis role="strong">U</emphasis>, <emphasis role="strong">F</emphasis>, <emphasis role="strong">C+</emphasis>) in the upper-left corner of the decision table.</simpara>
<simpara>The following decision table hit policies are supported in DMN:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Unique (U):</emphasis> Permits only one rule to match. Any overlap raises an error.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Any (A):</emphasis> Permits multiple rules to match, but they must all have the same output. If multiple matching rules do not have the same output, an error is raised.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Priority (P):</emphasis> Permits multiple rules to match, with different outputs. The output that comes first in the output values list is selected.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">First (F):</emphasis> Uses the first match in rule order.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Collect (C+, C&gt;, C&lt;, C#):</emphasis> Aggregates output from multiple rules based on an aggregation function.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Collect ( C ):</emphasis> Aggregates values in an arbitrary list.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Collect Sum (C+):</emphasis> Outputs the sum of all collected values. Values must be numeric.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Collect Min (C&lt;):</emphasis> Outputs the minimum value among the matches. The resulting values must be comparable, such as numbers, dates, or text (lexicographic order).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Collect Max (C&gt;):</emphasis> Outputs the maximum value among the matches. The resulting values must be comparable, such as numbers, dates or text (lexicographic order).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Collect Count (C#):</emphasis> Outputs the number of matching rules.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="dmn-literal-expressions-con_dmn-models">
<title>Boxed literal expressions</title>
<simpara>A boxed literal expression in DMN is a literal FEEL expression as text in a table cell, typically with a labeled column and an assigned data type. You use boxed literal expressions to define simple or complex node logic or decision data directly in FEEL for a particular node in a decision. Literal FEEL expressions must conform to FEEL syntax requirements in the OMG <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
<simpara>For example, the following boxed literal expression defines the minimum acceptable PITI calculation (principal, interest, taxes, and insurance) in a lending decision, where <literal>acceptable rate</literal> is a variable defined in the DMN model:</simpara>
<figure>
<title>Boxed literal expression for minimum PITI value</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-literal-expression-example2.png"/>
</imageobject>
<textobject><phrase>dmn literal expression example2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed literal expression sorts a list of possible dating candidates (soul mates) in an online dating application based on their score on criteria such as age, location, and interests:</simpara>
<figure>
<title>Boxed literal expression for matching online dating candidates</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-literal-expression-example3b.png"/>
</imageobject>
<textobject><phrase>dmn literal expression example3b</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-context-expressions-con_dmn-models">
<title>Boxed context expressions</title>
<simpara>A boxed context expression in DMN is a set of variable names and values with a result value. Each name-value pair is a context entry. You use context expressions to represent data definitions in decision logic and set a value for a desired decision element within the DMN decision model. A value in a boxed context expression can be a data type value or FEEL expression, or can contain a nested sub-expression of any type, such as a decision table, a literal expression, or another context expression.</simpara>
<simpara>For example, the following boxed context expression defines the factors for sorting delayed passengers in a flight-rebooking decision model, based on defined data types (<literal>tPassengerTable</literal>, <literal>tFlightNumberList</literal>):</simpara>
<figure>
<title>Boxed context expression for flight passenger waiting list</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-context-expression-example.png"/>
</imageobject>
<textobject><phrase>dmn context expression example</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed context expression defines the factors that determine whether a loan applicant can meet minimum mortgage payments based on principal, interest, taxes, and insurance (PITI), represented as a front-end ratio calculation with a sub-context expression:</simpara>
<figure>
<title>Boxed context expression for front-end client PITI ratio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-context-expression-example2.png"/>
</imageobject>
<textobject><phrase>dmn context expression example2</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-relation-expressions-con_dmn-models">
<title>Boxed relation expressions</title>
<simpara>A boxed relation expression in DMN is a traditional data table with information about given entities, listed as rows. You use boxed relation tables to define decision data for relevant entities in a decision at a particular node. Boxed relation expressions are similar to context expressions in that they set variable names and values, but relation expressions contain no result value and list all variable values based on a single defined variable in each column.</simpara>
<simpara>For example, the following boxed relation expression provides information about employees in an employee rostering decision:</simpara>
<figure>
<title>Boxed relation expression with employee information</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-relation-expression-example.png"/>
</imageobject>
<textobject><phrase>dmn relation expression example</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-function-expressions-con_dmn-models">
<title>Boxed function expressions</title>
<simpara>A boxed function expression in DMN is a parameterized boxed expression containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type. By default, all business knowledge models are defined as boxed function expressions. You use boxed function expressions to call functions on your decision logic and to define all business knowledge models.</simpara>
<simpara>For example, the following boxed function expression determines airline flight capacity in a flight-rebooking decision model:</simpara>
<figure>
<title>Boxed function expression for flight capacity</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example.png"/>
</imageobject>
<textobject><phrase>dmn function expression example</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed function expression contains a basic Java function as a context expression for determining absolute value in a decision model calculation:</simpara>
<figure>
<title>Boxed function expression for absolute value</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example2.png"/>
</imageobject>
<textobject><phrase>dmn function expression example2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed function expression determines a monthly mortgage installment as a business knowledge model in a lending decision, with the function value defined as a nested context expression:</simpara>
<figure>
<title>Boxed function expression for installment calculation in business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example3.png"/>
</imageobject>
<textobject><phrase>dmn function expression example3</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed function expression uses a PMML model included in the DMN file to define the minimum acceptable PITI calculation (principal, interest, taxes, and insurance) in a lending decision:</simpara>
<figure>
<title>Boxed function expression with an included PMML model in business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example5.png"/>
</imageobject>
<textobject><phrase>dmn function expression example5</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-invocation-expressions-con_dmn-models">
<title>Boxed invocation expressions</title>
<simpara>A boxed invocation expression in DMN is a boxed expression that invokes a business knowledge model. A boxed invocation expression contains the name of the business knowledge model to be invoked and a list of parameter bindings. Each binding is represented by two boxed expressions on a row: The box on the left contains the name of a parameter and the box on the right contains the binding expression whose value is assigned to the parameter to evaluate the invoked business knowledge model. You use boxed invocations to invoke at a particular decision node a business knowledge model defined in the decision model.</simpara>
<simpara>For example, the following boxed invocation expression invokes a <literal>Reassign Next Passenger</literal> business knowledge model as the concluding decision node in a flight-rebooking decision model:</simpara>
<figure>
<title>Boxed invocation expression to reassign flight passengers</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-invocation-example.png"/>
</imageobject>
<textobject><phrase>dmn invocation example</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed invocation expression invokes an <literal>InstallmentCalculation</literal> business knowledge model to calculate a monthly installment amount for a loan before proceeding to affordability decisions:</simpara>
<figure>
<title>Boxed invocation expression for required monthly installment</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-invocation-example2.png"/>
</imageobject>
<textobject><phrase>dmn invocation example2</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-list-expressions-con_dmn-models">
<title>Boxed list expressions</title>
<simpara>A boxed list expression in DMN represents a FEEL list of items. You use boxed lists to define lists of relevant items for a particular node in a decision. You can also use literal FEEL expressions for list items in cells to create more complex lists.</simpara>
<simpara>For example, the following boxed list expression identifies approved credit score agencies in a loan application decision service:</simpara>
<figure>
<title>Boxed list expression for approved credit score agencies</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-list-expression-example.png"/>
</imageobject>
<textobject><phrase>dmn list expression example</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed list expression also identifies approved credit score agencies but uses FEEL logic to define the agency status (Inc., LLC, SA, GA) based on a DMN input node:</simpara>
<figure>
<title>Boxed list expression using FEEL logic for approved credit score agency status</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-list-expression-example2.png"/>
</imageobject>
<textobject><phrase>dmn list expression example2</phrase></textobject>
</mediaobject>
</figure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-list-expression-example2a.png"/>
</imageobject>
<textobject><phrase>dmn list expression example2a</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="dmn-model-example-ref_dmn-models">
<title>DMN model example</title>
<simpara>The following is a real-world DMN model example that demonstrates how you can use decision modeling to reach a decision based on input data, circumstances, and company guidelines. In this scenario, a flight from San Diego to New York is canceled, requiring the affected airline to find alternate arrangements for its inconvenienced passengers.</simpara>
<simpara>First, the airline collects the information necessary to determine how best to get the travelers to their destinations:</simpara>
<variablelist>
<varlistentry>
<term>Input data</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>List of flights</simpara>
</listitem>
<listitem>
<simpara>List of passengers</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Decisions</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Prioritize the passengers who will get seats on a new flight</simpara>
</listitem>
<listitem>
<simpara>Determine which flights those passengers will be offered</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Business knowledge models</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>The company process for determining passenger priority</simpara>
</listitem>
<listitem>
<simpara>Any flights that have space available</simpara>
</listitem>
<listitem>
<simpara>Company rules for determining how best to reassign inconvenienced passengers</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara>The airline then uses the DMN standard to model its decision process in the following decision requirements diagram (DRD) for determining the best rebooking solution:</simpara>
<figure>
<title>DRD for flight rebooking</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-passenger-rebooking-drd.png"/>
</imageobject>
<textobject><phrase>dmn passenger rebooking drd</phrase></textobject>
</mediaobject>
</figure>
<simpara>Similar to flowcharts, DRDs use shapes to represent the different elements in a process. Ovals contain the two necessary input data, rectangles contain the decision points in the model, and rectangles with clipped corners (business knowledge models) contain reusable logic that can be repeatedly invoked.</simpara>
<simpara>The DRD draws logic for each element from boxed expressions that provide variable definitions using FEEL expressions or data type values.</simpara>
<simpara>Some boxed expressions are basic, such as the following decision for establishing a prioritized waiting list:</simpara>
<figure>
<title>Boxed context expression example for prioritized wait list</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-context-expression-example.png"/>
</imageobject>
<textobject><phrase>dmn context expression example</phrase></textobject>
</mediaobject>
</figure>
<simpara>Some boxed expressions are more complex with greater detail and calculation, such as the following business knowledge model for reassigning the next delayed passenger:</simpara>
<figure>
<title>Boxed function expression for passenger reassignment</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-reassign-passenger.png"/>
</imageobject>
<textobject><phrase>dmn reassign passenger</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following is the DMN source file for this decision model:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dmn:definitions xmlns="https://www.drools.org/kie-dmn/Flight-rebooking" xmlns:dmn="http://www.omg.org/spec/DMN/20151101/dmn.xsd" xmlns:feel="http://www.omg.org/spec/FEEL/20140401" id="_0019_flight_rebooking" name="0019-flight-rebooking" namespace="https://www.drools.org/kie-dmn/Flight-rebooking"&gt;
  &lt;dmn:itemDefinition id="_tFlight" name="tFlight"&gt;
    &lt;dmn:itemComponent id="_tFlight_Flight" name="Flight Number"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_From" name="From"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_To" name="To"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_Dep" name="Departure"&gt;
      &lt;dmn:typeRef&gt;feel:dateTime&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_Arr" name="Arrival"&gt;
      &lt;dmn:typeRef&gt;feel:dateTime&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_Capacity" name="Capacity"&gt;
      &lt;dmn:typeRef&gt;feel:number&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tFlight_Status" name="Status"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
  &lt;/dmn:itemDefinition&gt;
  &lt;dmn:itemDefinition id="_tFlightTable" isCollection="true" name="tFlightTable"&gt;
    &lt;dmn:typeRef&gt;tFlight&lt;/dmn:typeRef&gt;
  &lt;/dmn:itemDefinition&gt;
  &lt;dmn:itemDefinition id="_tPassenger" name="tPassenger"&gt;
    &lt;dmn:itemComponent id="_tPassenger_Name" name="Name"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tPassenger_Status" name="Status"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tPassenger_Miles" name="Miles"&gt;
      &lt;dmn:typeRef&gt;feel:number&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
    &lt;dmn:itemComponent id="_tPassenger_Flight" name="Flight Number"&gt;
      &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
    &lt;/dmn:itemComponent&gt;
  &lt;/dmn:itemDefinition&gt;
  &lt;dmn:itemDefinition id="_tPassengerTable" isCollection="true" name="tPassengerTable"&gt;
    &lt;dmn:typeRef&gt;tPassenger&lt;/dmn:typeRef&gt;
  &lt;/dmn:itemDefinition&gt;
  &lt;dmn:itemDefinition id="_tFlightNumberList" isCollection="true" name="tFlightNumberList"&gt;
    &lt;dmn:typeRef&gt;feel:string&lt;/dmn:typeRef&gt;
  &lt;/dmn:itemDefinition&gt;
  &lt;dmn:inputData id="i_Flight_List" name="Flight List"&gt;
    &lt;dmn:variable name="Flight List" typeRef="tFlightTable"/&gt;
  &lt;/dmn:inputData&gt;
  &lt;dmn:inputData id="i_Passenger_List" name="Passenger List"&gt;
    &lt;dmn:variable name="Passenger List" typeRef="tPassengerTable"/&gt;
  &lt;/dmn:inputData&gt;
  &lt;dmn:decision name="Prioritized Waiting List" id="d_PrioritizedWaitingList"&gt;
    &lt;dmn:variable name="Prioritized Waiting List" typeRef="tPassengerTable"/&gt;
    &lt;dmn:informationRequirement&gt;
      &lt;dmn:requiredInput href="#i_Passenger_List"/&gt;
    &lt;/dmn:informationRequirement&gt;
    &lt;dmn:informationRequirement&gt;
      &lt;dmn:requiredInput href="#i_Flight_List"/&gt;
    &lt;/dmn:informationRequirement&gt;
    &lt;dmn:knowledgeRequirement&gt;
      &lt;dmn:requiredKnowledge href="#b_PassengerPriority"/&gt;
    &lt;/dmn:knowledgeRequirement&gt;
    &lt;dmn:context&gt;
      &lt;dmn:contextEntry&gt;
        &lt;dmn:variable name="Cancelled Flights" typeRef="tFlightNumberList"/&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;Flight List[ Status = "cancelled" ].Flight Number&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:contextEntry&gt;
      &lt;dmn:contextEntry&gt;
        &lt;dmn:variable name="Waiting List" typeRef="tPassengerTable"/&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;Passenger List[ list contains( Cancelled Flights, Flight Number ) ]&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:contextEntry&gt;
      &lt;dmn:contextEntry&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;sort( Waiting List, passenger priority )&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:contextEntry&gt;
    &lt;/dmn:context&gt;
  &lt;/dmn:decision&gt;
  &lt;dmn:decision name="Rebooked Passengers" id="d_RebookedPassengers"&gt;
    &lt;dmn:variable name="Rebooked Passengers" typeRef="tPassengerTable"/&gt;
    &lt;dmn:informationRequirement&gt;
      &lt;dmn:requiredDecision href="#d_PrioritizedWaitingList"/&gt;
    &lt;/dmn:informationRequirement&gt;
    &lt;dmn:informationRequirement&gt;
      &lt;dmn:requiredInput href="#i_Flight_List"/&gt;
    &lt;/dmn:informationRequirement&gt;
    &lt;dmn:knowledgeRequirement&gt;
      &lt;dmn:requiredKnowledge href="#b_ReassignNextPassenger"/&gt;
    &lt;/dmn:knowledgeRequirement&gt;
    &lt;dmn:invocation&gt;
      &lt;dmn:literalExpression&gt;
        &lt;dmn:text&gt;reassign next passenger&lt;/dmn:text&gt;
      &lt;/dmn:literalExpression&gt;
      &lt;dmn:binding&gt;
        &lt;dmn:parameter name="Waiting List"/&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;Prioritized Waiting List&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:binding&gt;
      &lt;dmn:binding&gt;
        &lt;dmn:parameter name="Reassigned Passengers List"/&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;[]&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:binding&gt;
      &lt;dmn:binding&gt;
        &lt;dmn:parameter name="Flights"/&gt;
        &lt;dmn:literalExpression&gt;
          &lt;dmn:text&gt;Flight List&lt;/dmn:text&gt;
        &lt;/dmn:literalExpression&gt;
      &lt;/dmn:binding&gt;
    &lt;/dmn:invocation&gt;
  &lt;/dmn:decision&gt;
  &lt;dmn:businessKnowledgeModel id="b_PassengerPriority" name="passenger priority"&gt;
    &lt;dmn:encapsulatedLogic&gt;
      &lt;dmn:formalParameter name="Passenger1" typeRef="tPassenger"/&gt;
      &lt;dmn:formalParameter name="Passenger2" typeRef="tPassenger"/&gt;
      &lt;dmn:decisionTable hitPolicy="UNIQUE"&gt;
        &lt;dmn:input id="b_Passenger_Priority_dt_i_P1_Status" label="Passenger1.Status"&gt;
          &lt;dmn:inputExpression typeRef="feel:string"&gt;
            &lt;dmn:text&gt;Passenger1.Status&lt;/dmn:text&gt;
          &lt;/dmn:inputExpression&gt;
          &lt;dmn:inputValues&gt;
            &lt;dmn:text&gt;"gold", "silver", "bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputValues&gt;
        &lt;/dmn:input&gt;
        &lt;dmn:input id="b_Passenger_Priority_dt_i_P2_Status" label="Passenger2.Status"&gt;
          &lt;dmn:inputExpression typeRef="feel:string"&gt;
            &lt;dmn:text&gt;Passenger2.Status&lt;/dmn:text&gt;
          &lt;/dmn:inputExpression&gt;
          &lt;dmn:inputValues&gt;
            &lt;dmn:text&gt;"gold", "silver", "bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputValues&gt;
        &lt;/dmn:input&gt;
        &lt;dmn:input id="b_Passenger_Priority_dt_i_P1_Miles" label="Passenger1.Miles"&gt;
          &lt;dmn:inputExpression typeRef="feel:string"&gt;
            &lt;dmn:text&gt;Passenger1.Miles&lt;/dmn:text&gt;
          &lt;/dmn:inputExpression&gt;
        &lt;/dmn:input&gt;
        &lt;dmn:output id="b_Status_Priority_dt_o" label="Passenger1 has priority"&gt;
          &lt;dmn:outputValues&gt;
            &lt;dmn:text&gt;true, false&lt;/dmn:text&gt;
          &lt;/dmn:outputValues&gt;
          &lt;dmn:defaultOutputEntry&gt;
            &lt;dmn:text&gt;false&lt;/dmn:text&gt;
          &lt;/dmn:defaultOutputEntry&gt;
        &lt;/dmn:output&gt;
        &lt;dmn:rule id="b_Passenger_Priority_dt_r1"&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r1_i1"&gt;
            &lt;dmn:text&gt;"gold"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r1_i2"&gt;
            &lt;dmn:text&gt;"gold"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r1_i3"&gt;
            &lt;dmn:text&gt;&gt;= Passenger2.Miles&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:outputEntry id="b_Passenger_Priority_dt_r1_o1"&gt;
            &lt;dmn:text&gt;true&lt;/dmn:text&gt;
          &lt;/dmn:outputEntry&gt;
        &lt;/dmn:rule&gt;
        &lt;dmn:rule id="b_Passenger_Priority_dt_r2"&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r2_i1"&gt;
            &lt;dmn:text&gt;"gold"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r2_i2"&gt;
            &lt;dmn:text&gt;"silver","bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r2_i3"&gt;
            &lt;dmn:text&gt;-&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:outputEntry id="b_Passenger_Priority_dt_r2_o1"&gt;
            &lt;dmn:text&gt;true&lt;/dmn:text&gt;
          &lt;/dmn:outputEntry&gt;
        &lt;/dmn:rule&gt;
        &lt;dmn:rule id="b_Passenger_Priority_dt_r3"&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r3_i1"&gt;
            &lt;dmn:text&gt;"silver"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r3_i2"&gt;
            &lt;dmn:text&gt;"silver"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r3_i3"&gt;
            &lt;dmn:text&gt;&gt;= Passenger2.Miles&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:outputEntry id="b_Passenger_Priority_dt_r3_o1"&gt;
            &lt;dmn:text&gt;true&lt;/dmn:text&gt;
          &lt;/dmn:outputEntry&gt;
        &lt;/dmn:rule&gt;
        &lt;dmn:rule id="b_Passenger_Priority_dt_r4"&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r4_i1"&gt;
            &lt;dmn:text&gt;"silver"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r4_i2"&gt;
            &lt;dmn:text&gt;"bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r4_i3"&gt;
            &lt;dmn:text&gt;-&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:outputEntry id="b_Passenger_Priority_dt_r4_o1"&gt;
            &lt;dmn:text&gt;true&lt;/dmn:text&gt;
          &lt;/dmn:outputEntry&gt;
        &lt;/dmn:rule&gt;
        &lt;dmn:rule id="b_Passenger_Priority_dt_r5"&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r5_i1"&gt;
            &lt;dmn:text&gt;"bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r5_i2"&gt;
            &lt;dmn:text&gt;"bronze"&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:inputEntry id="b_Passenger_Priority_dt_r5_i3"&gt;
            &lt;dmn:text&gt;&gt;= Passenger2.Miles&lt;/dmn:text&gt;
          &lt;/dmn:inputEntry&gt;
          &lt;dmn:outputEntry id="b_Passenger_Priority_dt_r5_o1"&gt;
            &lt;dmn:text&gt;true&lt;/dmn:text&gt;
          &lt;/dmn:outputEntry&gt;
        &lt;/dmn:rule&gt;
      &lt;/dmn:decisionTable&gt;
    &lt;/dmn:encapsulatedLogic&gt;
    &lt;dmn:variable name="passenger priority" typeRef="feel:boolean"/&gt;
  &lt;/dmn:businessKnowledgeModel&gt;
  &lt;dmn:businessKnowledgeModel id="b_ReassignNextPassenger" name="reassign next passenger"&gt;
    &lt;dmn:encapsulatedLogic&gt;
      &lt;dmn:formalParameter name="Waiting List" typeRef="tPassengerTable"/&gt;
      &lt;dmn:formalParameter name="Reassigned Passengers List" typeRef="tPassengerTable"/&gt;
      &lt;dmn:formalParameter name="Flights" typeRef="tFlightTable"/&gt;
      &lt;dmn:context&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Next Passenger" typeRef="tPassenger"/&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;Waiting List[1]&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Original Flight" typeRef="tFlight"/&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;Flights[ Flight Number = Next Passenger.Flight Number ][1]&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Best Alternate Flight" typeRef="tFlight"/&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;Flights[ From = Original Flight.From and To = Original Flight.To and Departure &gt; Original Flight.Departure and Status = "scheduled" and has capacity( item, Reassigned Passengers List ) ][1]&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Reassigned Passenger" typeRef="tPassenger"/&gt;
          &lt;dmn:context&gt;
            &lt;dmn:contextEntry&gt;
              &lt;dmn:variable name="Name" typeRef="feel:string"/&gt;
              &lt;dmn:literalExpression&gt;
                &lt;dmn:text&gt;Next Passenger.Name&lt;/dmn:text&gt;
              &lt;/dmn:literalExpression&gt;
            &lt;/dmn:contextEntry&gt;
            &lt;dmn:contextEntry&gt;
              &lt;dmn:variable name="Status" typeRef="feel:string"/&gt;
              &lt;dmn:literalExpression&gt;
                &lt;dmn:text&gt;Next Passenger.Status&lt;/dmn:text&gt;
              &lt;/dmn:literalExpression&gt;
            &lt;/dmn:contextEntry&gt;
            &lt;dmn:contextEntry&gt;
              &lt;dmn:variable name="Miles" typeRef="feel:number"/&gt;
              &lt;dmn:literalExpression&gt;
                &lt;dmn:text&gt;Next Passenger.Miles&lt;/dmn:text&gt;
              &lt;/dmn:literalExpression&gt;
            &lt;/dmn:contextEntry&gt;
            &lt;dmn:contextEntry&gt;
              &lt;dmn:variable name="Flight Number" typeRef="feel:string"/&gt;
              &lt;dmn:literalExpression&gt;
                &lt;dmn:text&gt;Best Alternate Flight.Flight Number&lt;/dmn:text&gt;
              &lt;/dmn:literalExpression&gt;
            &lt;/dmn:contextEntry&gt;
          &lt;/dmn:context&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Remaining Waiting List" typeRef="tPassengerTable"/&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;remove( Waiting List, 1 )&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:variable name="Updated Reassigned Passengers List" typeRef="tPassengerTable"/&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;append( Reassigned Passengers List, Reassigned Passenger )&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
        &lt;dmn:contextEntry&gt;
          &lt;dmn:literalExpression&gt;
            &lt;dmn:text&gt;if count( Remaining Waiting List ) &gt; 0 then reassign next passenger( Remaining Waiting List, Updated Reassigned Passengers List, Flights ) else Updated Reassigned Passengers List&lt;/dmn:text&gt;
          &lt;/dmn:literalExpression&gt;
        &lt;/dmn:contextEntry&gt;
      &lt;/dmn:context&gt;
    &lt;/dmn:encapsulatedLogic&gt;
    &lt;dmn:variable name="reassign next passenger" typeRef="tPassengerTable"/&gt;
    &lt;dmn:knowledgeRequirement&gt;
      &lt;dmn:requiredKnowledge href="#b_HasCapacity"/&gt;
    &lt;/dmn:knowledgeRequirement&gt;
  &lt;/dmn:businessKnowledgeModel&gt;
  &lt;dmn:businessKnowledgeModel id="b_HasCapacity" name="has capacity"&gt;
    &lt;dmn:encapsulatedLogic&gt;
      &lt;dmn:formalParameter name="flight" typeRef="tFlight"/&gt;
      &lt;dmn:formalParameter name="rebooked list" typeRef="tPassengerTable"/&gt;
      &lt;dmn:literalExpression&gt;
        &lt;dmn:text&gt;flight.Capacity &gt; count( rebooked list[ Flight Number = flight.Flight Number ] )&lt;/dmn:text&gt;
      &lt;/dmn:literalExpression&gt;
    &lt;/dmn:encapsulatedLogic&gt;
    &lt;dmn:variable name="has capacity" typeRef="feel:boolean"/&gt;
  &lt;/dmn:businessKnowledgeModel&gt;
&lt;/dmn:definitions&gt;</programlisting>
</section>
</chapter>
<chapter xml:id="dmn-support-con_dmn-models">
<title>DMN support in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager provides design and runtime support for DMN 1.2 models at conformance level 3, and runtime-only support for DMN 1.1 and 1.3 models at conformance level 3. You can integrate DMN models with your Red Hat Decision Manager decision services in several ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Design your DMN models directly in Business Central using the DMN designer.</simpara>
</listitem>
<listitem>
<simpara>Import DMN files into your project in Business Central (<emphasis role="strong">Menu → Design → Projects → Import Asset</emphasis>). Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import into Business Central, open in the DMN designer, and save are converted to DMN 1.2 models.</simpara>
</listitem>
<listitem>
<simpara>Package DMN files as part of your project knowledge JAR (KJAR) file without Business Central.</simpara>
</listitem>
</itemizedlist>
<simpara>In addition to all DMN conformance level 3 requirements, Red Hat Decision Manager also includes enhancements and fixes to FEEL and DMN model components to optimize the experience of implementing DMN decision services with Red Hat Decision Manager. From a platform perspective, DMN models are like any other business asset in Red Hat Decision Manager, such as DRL files or spreadsheet decision tables, that you can include in your Red Hat Decision Manager project and deploy to KIE Server in order to start your DMN decision services.</simpara>
<simpara>For more information about including external DMN files with your Red Hat Decision Manager project packaging and deployment method, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<section xml:id="dmn-properties-ref_dmn-models">
<title>Configurable DMN properties in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager provides the following DMN properties that you can configure when you execute your DMN models on KIE Server or on your client application.
You can configure some of these properties using the <literal>kmodule.xml</literal> file in your Red Hat Decision Manager project when you deploy your project on KIE Server.</simpara>
<variablelist>
<varlistentry>
<term>org.kie.dmn.strictConformance</term>
<listitem>
<simpara>When enabled, this property disables by default any extensions or profiles provided beyond the DMN standard, such as some helper functions or enhanced features of DMN 1.2 backported into DMN 1.1. You can use this property to configure the decision engine to support only pure DMN features, such as when running the <link xlink:href="https://dmn-tck.github.io/tck/">DMN Technology Compatibility Kit</link> (TCK).</simpara>
<simpara>Default value: <literal>false</literal></simpara>
<screen>-Dorg.kie.dmn.strictConformance=true</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>org.kie.dmn.runtime.typecheck</term>
<listitem>
<simpara>When enabled, this property enables verification of actual values conforming to their declared types in the DMN model, as input or output of DRD elements. You can use this property to verify whether data supplied to the DMN model or produced by the DMN model is compliant with what is specified in the model.</simpara>
<simpara>Default value: <literal>false</literal></simpara>
<screen>-Dorg.kie.dmn.runtime.typecheck=true</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>org.kie.dmn.decisionservice.coercesingleton</term>
<listitem>
<simpara>By default, this property makes the result of a decision service defining a single output decision be the single value of the output decision value. When disabled, this property makes the result of a decision service defining a single output decision be a <literal>context</literal> with the single entry for that decision. You can use this property to adjust your decision service outputs according to your project requirements.</simpara>
<simpara>Default value: <literal>true</literal></simpara>
<screen>-Dorg.kie.dmn.decisionservice.coercesingleton=false</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>org.kie.dmn.profiles.$PROFILE_NAME</term>
<listitem>
<simpara>When valorized with a Java fully qualified name, this property loads a DMN profile onto the decision engine at start time. You can use this property to implement a predefined DMN profile with supported features different from or beyond the DMN standard. For example, if you are creating DMN models using the Signavio DMN modeller, use this property to implement features from the Signavio DMN profile into your DMN decision service.</simpara>
<screen>-Dorg.kie.dmn.profiles.signavio=org.kie.dmn.signavio.KieDMNSignavioProfile</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>org.kie.dmn.runtime.listeners.$LISTENER_NAME</term>
<listitem>
<simpara>When valorized with a Java fully qualified name, this property loads and registers a DMN Runtime Listener onto the decision engine at start time.
You can use this property to register a DMN listener in order to be notified of several events during DMN model evaluations.</simpara>
<simpara>To configure this property when deploying your project on KIE Server, modify this property in the <literal>kmodule.xml</literal> file of your project. This approach is helpful when the listener is specific to your project and when the configuration must be applied in KIE Server only to your deployed project.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;configuration&gt;
    &lt;property key="org.kie.dmn.runtime.listeners.mylistener" value="org.acme.MyDMNListener"/&gt;
  &lt;/configuration&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>To configure this property globally for your Red Hat Decision Manager environment, modify this property using a command terminal or any other global application configuration mechanism. This approach is helpful when the decision engine is embedded as part of your Java application.</simpara>
<screen>-Dorg.kie.dmn.runtime.listeners.mylistener=org.acme.MyDMNListener</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>org.kie.dmn.compiler.execmodel</term>
<listitem>
<simpara>When enabled, this property enables DMN decision table logic to be compiled into executable rule models during run time. You can use this property to evaluate DMN decision table logic more efficiently. This property is helpful when the executable model compilation was not originally performed during project compile time. Enabling this property may result in added compile time during the first evaluation by the decision engine, but subsequent compilations are more efficient.</simpara>
<simpara>Default value: <literal>false</literal></simpara>
<screen>-Dorg.kie.dmn.compiler.execmodel=true</screen>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="dmn-validation-con_dmn-models">
<title>Configurable DMN validation in Red Hat Decision Manager</title>
<simpara>By default, the <literal>kie-maven-plugin</literal> component in the <literal>pom.xml</literal> file of your Red Hat Decision Manager project uses the following <literal>&lt;validateDMN&gt;</literal> configurations to perform pre-compilation validation of DMN model assets and to perform DMN decision table static analysis:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>VALIDATE_SCHEMA</literal>: DMN model files are verified against the DMN specification XSD schema to ensure that the files are valid XML and compliant with the specification.</simpara>
</listitem>
<listitem>
<simpara><literal>VALIDATE_MODEL</literal>: The pre-compilation analysis is performed for the DMN model to ensure that the basic semantic is aligned with the DMN specification.</simpara>
</listitem>
<listitem>
<simpara><literal>ANALYZE_DECISION_TABLE</literal>: DMN decision tables are statically analyzed for gaps or overlaps and to ensure that the semantic of the decision table follows best practices.</simpara>
</listitem>
</itemizedlist>
<simpara>You can modify the default DMN validation and DMN decision table analysis behavior to perform only a specified validation during the project build, or you can disable this default behavior completely, as shown in the following examples:</simpara>
<formalpara>
<title>Default configuration for DMN validation and decision table analysis</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;validateDMN&gt;VALIDATE_SCHEMA,VALIDATE_MODEL,ANALYZE_DECISION_TABLE&lt;/validateDMN&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Configuration to perform only the DMN decision table static analysis</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;validateDMN&gt;ANALYZE_DECISION_TABLE&lt;/validateDMN&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Configuration to perform only the XSD schema validation</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;validateDMN&gt;VALIDATE_SCHEMA&lt;/validateDMN&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Configuration to perform only the DMN model validation</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;validateDMN&gt;VALIDATE_MODEL&lt;/validateDMN&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Configuration to disable all DMN validation</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;plugin&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-maven-plugin&lt;/artifactId&gt;
  &lt;extensions&gt;true&lt;/extensions&gt;
  &lt;configuration&gt;
    &lt;validateDMN&gt;disable&lt;/validateDMN&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>If you enter an unrecognized <literal>&lt;validateDMN&gt;</literal> configuration flag, all pre-compilation validation is disabled and the Maven plugin emits related log messages.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="dmn-model-creating-proc_dmn-models">
<title>Creating and editing DMN models in Business Central</title>
<simpara>You can use the DMN designer in Business Central to design DMN decision requirements diagrams (DRDs) and define decision logic for a complete and functional DMN decision model. Red Hat Decision Manager provides design and runtime support for DMN 1.2 models at conformance level 3, and includes enhancements and fixes to FEEL and DMN model components to optimize the experience of implementing DMN decision services with Red Hat Decision Manager. Red Hat Decision Manager also provides runtime-only support for DMN 1.1 and 1.3 models at conformance level 3, but any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import into Business Central, open in the DMN designer, and save are converted to DMN 1.2 models.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Create or import a DMN file in your Business Central project.</simpara>
<simpara>To create a DMN file, click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">DMN</emphasis>, enter an informative DMN model name, select the appropriate <emphasis role="strong">Package</emphasis>, and click <emphasis role="strong">Ok</emphasis>.</simpara>
<simpara>To import an existing DMN file, click <emphasis role="strong">Import Asset</emphasis>, enter the DMN model name, select the appropriate <emphasis role="strong">Package</emphasis>, select the DMN file to upload, and click <emphasis role="strong">Ok</emphasis>.</simpara>
<simpara>The new DMN file is now listed in the <emphasis role="strong">DMN</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>, and the DMN decision requirements diagram (DRD) canvas appears.</simpara>
<note>
<simpara>If you imported a DMN file that does not contain layout information, the imported decision requirements diagram (DRD) is formatted automatically in the DMN designer. Click <emphasis role="strong">Save</emphasis> in the DMN designer to save the DRD layout.</simpara>
<simpara>If an imported DRD is not automatically formatted, you can select the <emphasis role="strong">Perform automatic layout</emphasis> icon in the upper-right toolbar in the DMN designer to format the DRD.</simpara>
</note>
</listitem>
<listitem>
<simpara>Begin adding components to your new or imported DMN decision requirements diagram (DRD) by clicking and dragging one of the DMN nodes from the left toolbar:</simpara>
<figure>
<title>Adding DRD components</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drag-decision-node.png"/>
</imageobject>
<textobject><phrase>dmn drag decision node</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following DRD components are available:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Decision</emphasis>: Use this node for a DMN decision, where one or more input elements determine an output based on defined decision logic.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Business knowledge model</emphasis>: Use this node for reusable functions with one or more decision elements. Decisions that have the same logic but depend on different sub-input data or sub-decisions use business knowledge models to determine which procedure to follow.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Knowledge source</emphasis>: Use this node for external authorities, documents, committees, or policies that regulate a decision or business knowledge model. Knowledge sources are references to real-world factors rather than executable business rules.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Input data</emphasis>: Use this node for information used in a decision node or a business knowledge model. Input data usually includes business-level concepts or objects relevant to the business, such as loan applicant data used in a lending strategy.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Text annotation</emphasis>: Use this node for explanatory notes associated with an input data node, decision node, business knowledge model, or knowledge source.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Decision service</emphasis>: Use this node to enclose a set of reusable decisions implemented as a decision service for invocation. A decision service can be used in other DMN models and can be invoked from an external application or a BPMN business process.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In the DMN designer canvas, double-click the new DRD node to enter an informative node name.</simpara>
</listitem>
<listitem>
<simpara>If the node is a decision or business knowledge model, select the node to display the node options and click the <emphasis role="strong">Edit</emphasis> icon to open the DMN boxed expression designer to define the decision logic for the node:</simpara>
<figure>
<title>Opening a new decision node boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-edit.png"/>
</imageobject>
<textobject><phrase>dmn decision edit</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Opening a new business knowledge model boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-edit.png"/>
</imageobject>
<textobject><phrase>dmn bkm edit</phrase></textobject>
</mediaobject>
</figure>
<simpara>By default, all business knowledge models are defined as boxed function expressions containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type.</simpara>
<simpara>For decision nodes, you click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.</simpara>
<figure>
<title>Selecting the logic type for a decision node</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-boxed-expression-options.png"/>
</imageobject>
<textobject><phrase>dmn decision boxed expression options</phrase></textobject>
</mediaobject>
</figure>
<simpara>For business knowledge models, you click the top-left function cell to select the function type, or right-click the function value cell, select <emphasis role="strong">Clear</emphasis>, and select a boxed expression of another type.</simpara>
<figure>
<title>Selecting the function or other logic type for a business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-define.png"/>
</imageobject>
<textobject><phrase>dmn bkm define</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>In the selected boxed expression designer for either a decision node (any expression type) or business knowledge model (function expression), click the applicable table cells to define the table name, variable data types, variable names and values, function parameters and bindings, or FEEL expressions to include in the decision logic.</simpara>
<simpara>You can right-click cells for additional actions where applicable, such as inserting or removing table rows and columns or clearing table contents.</simpara>
<simpara>The following is an example decision table for a decision node that determines credit score ratings based on a defined range of a loan applicant’s credit score:</simpara>
<figure>
<title>Decision node decision table for credit score rating</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example1a.png"/>
</imageobject>
<textobject><phrase>dmn decision table example1a</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following is an example boxed function expression for a business knowledge model that calculates mortgage payments based on principal, interest, taxes, and insurance (PITI) as a literal expression:</simpara>
<figure>
<title>Business knowledge model function for PITI calculation</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example4.png"/>
</imageobject>
<textobject><phrase>dmn function expression example4</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>After you define the decision logic for the selected node, click <emphasis role="strong">Back to "&lt;MODEL_NAME&gt;"</emphasis> to return to the DRD view.</simpara>
</listitem>
<listitem>
<simpara>For the selected DRD node, use the available connection options to create and connect to the next node in the DRD, or click and drag a new node onto the DRD canvas from the left toolbar.</simpara>
<simpara>The node type determines which connection options are supported. For example, an <emphasis role="strong">Input data</emphasis> node can connect to a decision node, knowledge source, or text annotation using the applicable connection type, whereas a <emphasis role="strong">Knowledge source</emphasis> node can connect to any DRD element. A <emphasis role="strong">Decision</emphasis> node can connect only to another decision or a text annotation.</simpara>
<simpara>The following connection types are available, depending on the node type:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Information requirement</emphasis>: Use this connection from an input data node or decision node to another decision node that requires the information.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Knowledge requirement</emphasis>: Use this connection from a business knowledge model to a decision node or to another business knowledge model that invokes the decision logic.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Authority requirement</emphasis>: Use this connection from an input data node or a decision node to a dependent knowledge source or from a knowledge source to a decision node, business knowledge model, or another knowledge source.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Association</emphasis>: Use this connection from an input data node, decision node, business knowledge model, or knowledge source to a text annotation.</simpara>
</listitem>
</itemizedlist>
<figure>
<title>Connecting credit score input to the credit score rating decision</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-connection-example.png"/>
</imageobject>
<textobject><phrase>dmn input connection example</phrase></textobject>
</mediaobject>
</figure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-input-connection-example2.png"/>
</imageobject>
<textobject><phrase>dmn input connection example2</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Continue adding and defining the remaining DRD components of your decision model. Periodically click <emphasis role="strong">Save</emphasis> in the DMN designer to save your work.</simpara>
<note>
<simpara>As you periodically save a DRD, the DMN designer performs a static validation of the DMN model and might produce error messages until the model is defined completely. After you finish defining the DMN model completely, if any errors remain, troubleshoot the specified problems accordingly.</simpara>
</note>
</listitem>
<listitem>
<simpara>After you add and define all components of the DRD, click <emphasis role="strong">Save</emphasis> to save and validate the completed DRD.</simpara>
<simpara>To adjust the DRD layout, you can select the <emphasis role="strong">Perform automatic layout</emphasis> icon in the upper-right toolbar of the DMN designer.</simpara>
<simpara>The following is an example DRD for a loan prequalification decision model:</simpara>
<figure>
<title>Completed DRD for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-example-drd.png"/>
</imageobject>
<textobject><phrase>dmn example drd</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following is an example DRD for a phone call handling decision model using a reusable decision service:</simpara>
<figure>
<title>Completed DRD for phone call handling with a decision service</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-example-drd3.png" contentwidth="90%"/>
</imageobject>
<textobject><phrase>dmn example drd3</phrase></textobject>
</mediaobject>
</figure>
<simpara>In a DMN decision service node, the decision nodes in the bottom segment incorporate input data from outside of the decision service to arrive at a final decision in the top segment of the decision service node. The resulting top-level decisions from the decision service are then implemented in any subsequent decisions or business knowledge requirements of the DMN model. You can reuse DMN decision services in other DMN models to apply the same decision logic with different input data and different outgoing connections.</simpara>
</listitem>
</orderedlist>
<section xml:id="dmn-logic-defining-proc_dmn-models">
<title>Defining DMN decision logic in boxed expressions in Business Central</title>
<simpara>Boxed expressions in DMN are tables that you use to define the underlying logic of decision nodes and business knowledge models in a decision requirements diagram (DRD). Some boxed expressions can contain other boxed expressions, but the top-level boxed expression corresponds to the decision logic of a single DRD artifact. While DRDs represent the flow of a DMN decision model, boxed expressions define the actual decision logic of individual nodes. DRDs and boxed expressions together form a complete and functional DMN decision model.</simpara>
<simpara>You can use the DMN designer in Business Central to define decision logic for your DRD components using built-in boxed expressions.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A DMN file is created or imported in Business Central.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis>, click the project name, and select the DMN file you want to modify.</simpara>
</listitem>
<listitem>
<simpara>In the DMN designer canvas, select a decision node or business knowledge model node that you want to define and click the <emphasis role="strong">Edit</emphasis> icon to open the DMN boxed expression designer:</simpara>
<figure>
<title>Opening a new decision node boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-edit.png"/>
</imageobject>
<textobject><phrase>dmn decision edit</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Opening a new business knowledge model boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-edit.png"/>
</imageobject>
<textobject><phrase>dmn bkm edit</phrase></textobject>
</mediaobject>
</figure>
<simpara>By default, all business knowledge models are defined as boxed function expressions containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type.</simpara>
<simpara>For decision nodes, you click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.</simpara>
<figure>
<title>Selecting the logic type for a decision node</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-boxed-expression-options.png"/>
</imageobject>
<textobject><phrase>dmn decision boxed expression options</phrase></textobject>
</mediaobject>
</figure>
<simpara>For business knowledge model nodes, you click the top-left function cell to select the function type, or right-click the function value cell, select <emphasis role="strong">Clear</emphasis>, and select a boxed expression of another type.</simpara>
<figure>
<title>Selecting the function or other logic type for a business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-define.png"/>
</imageobject>
<textobject><phrase>dmn bkm define</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>For this example, use a decision node and select <emphasis role="strong">Decision Table</emphasis> as the boxed expression type.</simpara>
<simpara>A decision table in DMN is a visual representation of one or more rules in a tabular format. Each rule consists of a single row in the table, and includes columns that define the conditions (input) and outcome (output) for that particular row.</simpara>
</listitem>
<listitem>
<simpara>Click the input column header to define the name and data type for the input condition. For example, name the input column <emphasis role="strong">Credit Score.FICO</emphasis> with a <literal>number</literal> data type. This column specifies numeric credit score values or ranges of loan applicants.</simpara>
</listitem>
<listitem>
<simpara>Click the output column header to define the name and data type for the output values. For example, name the output column <emphasis role="strong">Credit Score Rating</emphasis> and next to the <emphasis role="strong">Data Type</emphasis> option, click <emphasis role="strong">Manage</emphasis> to go to the <emphasis role="strong">Data Types</emphasis> page where you can create a custom data type with score ratings as constraints.</simpara>
<figure>
<title>Managing data types for a column header value</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types.png"/>
</imageobject>
<textobject><phrase>dmn manage data types</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Data Types</emphasis> page, click <emphasis role="strong">New Data Type</emphasis> to add a new data type or click <emphasis role="strong">Import Data Object</emphasis> to import an existing data object from your project that you want to use as a DMN data type.</simpara>
<simpara>If you import a data object from your project as a DMN data type and then that object is updated, you must re-import the data object as a DMN data type to apply the changes in your DMN model.</simpara>
<simpara>For this example, click <emphasis role="strong">New Data Type</emphasis> and create a <emphasis role="strong">Credit_Score_Rating</emphasis> data type as a <literal>string</literal>:</simpara>
<figure>
<title>Adding a new data type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-add.png"/>
</imageobject>
<textobject><phrase>dmn custom data type add</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Constraints</emphasis>, select <emphasis role="strong">Enumeration</emphasis> from the drop-down options, and add the following constraints:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Excellent"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Good"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Fair"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Poor"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Bad"</literal></simpara>
</listitem>
</itemizedlist>
<figure>
<title>Adding constraints to the new data type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-constraints.png"/>
</imageobject>
<textobject><phrase>dmn custom data type constraints</phrase></textobject>
</mediaobject>
</figure>
<simpara>To change the order of data type constraints, you can click the left end of the constraint row and drag the row as needed:</simpara>
<figure>
<title>Dragging constraints to change constraint order</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-constraints-drag.png"/>
</imageobject>
<textobject><phrase>dmn custom data type constraints drag</phrase></textobject>
</mediaobject>
</figure>
<simpara>For information about constraint types and syntax requirements for the specified data type, see the <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">OK</emphasis> to save the constraints and click the check mark to the right of the data type to save the data type.</simpara>
</listitem>
<listitem>
<simpara>Return to the <emphasis role="strong">Credit Score Rating</emphasis> decision table, click the <emphasis role="strong">Credit Score Rating</emphasis> column header, and set the data type to this new custom data type.</simpara>
</listitem>
<listitem>
<simpara>Use the <emphasis role="strong">Credit Score.FICO</emphasis> input column to define credit score values or ranges of values, and use the <emphasis role="strong">Credit Score Rating</emphasis> column to specify one of the corresponding ratings you defined in the <emphasis role="strong">Credit_Score_Rating</emphasis> data type.</simpara>
<simpara>Right-click any value cell to insert or delete rows (rules) or columns (clauses).</simpara>
<figure>
<title>Decision node decision table for credit score rating</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example1a.png"/>
</imageobject>
<textobject><phrase>dmn decision table example1a</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>After you define all rules, click the top-left corner of the decision table to define the rule <emphasis role="strong">Hit Policy</emphasis> and <emphasis role="strong">Builtin Aggregator</emphasis> (for <emphasis role="strong">COLLECT</emphasis> hit policy only).</simpara>
<simpara>The hit policy determines how to reach an outcome when multiple rules in a decision table match the provided input values. The built-in aggregator determines how to aggregate rule values when you use the <emphasis role="strong">COLLECT</emphasis> hit policy.</simpara>
<figure>
<title>Defining the decision table hit policy</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-hit-policies.png"/>
</imageobject>
<textobject><phrase>dmn hit policies</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following example is a more complex decision table that determines applicant qualification for a loan as the concluding decision node in the same loan prequalification decision model:</simpara>
<figure>
<title>Decision table for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example3.png"/>
</imageobject>
<textobject><phrase>dmn decision table example3</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<simpara>For boxed expression types other than decision tables, you follow these guidelines similarly to navigate the boxed expression tables and define variables and parameters for decision logic, but according to the requirements of the boxed expression type. Some boxed expressions, such as boxed literal expressions, can be single-column tables, while other boxed expressions, such as function, context, and invocation expressions, can be multi-column tables with nested boxed expressions of other types.</simpara>
<simpara>For example, the following boxed context expression defines the parameters that determine whether a loan applicant can meet minimum mortgage payments based on principal, interest, taxes, and insurance (PITI), represented as a front-end ratio calculation with a sub-context expression:</simpara>
<figure>
<title>Boxed context expression for front-end client PITI ratio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-context-expression-example2.png"/>
</imageobject>
<textobject><phrase>dmn context expression example2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following boxed function expression determines a monthly mortgage installment as a business knowledge model in a lending decision, with the function value defined as a nested context expression:</simpara>
<figure>
<title>Boxed function expression for installment calculation in business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example3.png"/>
</imageobject>
<textobject><phrase>dmn function expression example3</phrase></textobject>
</mediaobject>
</figure>
<simpara>For more information and examples of each boxed expression type, see <xref linkend="dmn-boxed-expressions-con_dmn-models"/>.</simpara>
</section>
<section xml:id="dmn-data-types-defining-proc_dmn-models">
<title>Creating custom data types for DMN boxed expressions in Business Central</title>
<simpara>In DMN boxed expressions in Business Central, data types determine the structure of the data that you use within an associated table, column, or field in the boxed expression. You can use default DMN data types (such as String, Number, Boolean) or you can create custom data types to specify additional fields and constraints that you want to implement for the boxed expression values.</simpara>
<simpara>Custom data types that you create for a boxed expression can be simple or structured:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Simple</emphasis> data types have only a name and a type assignment. Example: <literal>Age (number)</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Structured</emphasis> data types contain multiple fields associated with a parent data type. Example: A single type <literal>Person</literal> containing the fields <literal>Name (string)</literal>, <literal>Age (number)</literal>, <literal>Email (string)</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A DMN file is created or imported in Business Central.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis>, click the project name, and select the DMN file you want to modify.</simpara>
</listitem>
<listitem>
<simpara>In the DMN designer canvas, select a decision node or business knowledge model for which you want to define the data types and click the <emphasis role="strong">Edit</emphasis> icon to open the DMN boxed expression designer.</simpara>
</listitem>
<listitem>
<simpara>If the boxed expression is for a decision node that is not yet defined, click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.</simpara>
<figure>
<title>Selecting the logic type for a decision node</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-boxed-expression-options.png"/>
</imageobject>
<textobject><phrase>dmn decision boxed expression options</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click the cell for the table header, column header, or parameter field (depending on the boxed expression type) for which you want to define the data type and click <emphasis role="strong">Manage</emphasis> to go to the <emphasis role="strong">Data Types</emphasis> page where you can create a custom data type.</simpara>
<figure>
<title>Managing data types for a column header value</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types.png"/>
</imageobject>
<textobject><phrase>dmn manage data types</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also set and manage custom data types for a specified decision node or business knowledge model node by selecting the <emphasis role="strong">Properties</emphasis> icon in the upper-right corner of the DMN designer:</simpara>
<figure>
<title>Managing data types in decision requirements diagram (DRD) properties</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types1a.png"/>
</imageobject>
<textobject><phrase>dmn manage data types1a</phrase></textobject>
</mediaobject>
</figure>
<simpara>The data type that you define for a specified cell in a boxed expression determines the structure of the data that you use within that associated table, column, or field in the boxed expression.</simpara>
<simpara>In this example, an output column <emphasis role="strong">Credit Score Rating</emphasis> for a DMN decision table defines a set of custom credit score ratings based on an applicant’s credit score.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Data Types</emphasis> page, click <emphasis role="strong">New Data Type</emphasis> to add a new data type or click <emphasis role="strong">Import Data Object</emphasis> to import an existing data object from your project that you want to use as a DMN data type.</simpara>
<simpara>If you import a data object from your project as a DMN data type and then that object is updated, you must re-import the data object as a DMN data type to apply the changes in your DMN model.</simpara>
<simpara>For this example, click <emphasis role="strong">New Data Type</emphasis> and create a <emphasis role="strong">Credit_Score_Rating</emphasis> data type as a <literal>string</literal>:</simpara>
<figure>
<title>Adding a new data type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-add.png"/>
</imageobject>
<textobject><phrase>dmn custom data type add</phrase></textobject>
</mediaobject>
</figure>
<simpara>If the data type requires a list of items, enable the <emphasis role="strong">List</emphasis> setting.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Constraints</emphasis>, select <emphasis role="strong">Enumeration</emphasis> from the drop-down options, and add the following constraints:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Excellent"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Good"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Fair"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Poor"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Bad"</literal></simpara>
</listitem>
</itemizedlist>
<figure>
<title>Adding constraints to the new data type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-constraints.png"/>
</imageobject>
<textobject><phrase>dmn custom data type constraints</phrase></textobject>
</mediaobject>
</figure>
<simpara>To change the order of data type constraints, you can click the left end of the constraint row and drag the row as needed:</simpara>
<figure>
<title>Dragging constraints to change constraint order</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-custom-data-type-constraints-drag.png"/>
</imageobject>
<textobject><phrase>dmn custom data type constraints drag</phrase></textobject>
</mediaobject>
</figure>
<simpara>For information about constraint types and syntax requirements for the specified data type, see the <link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">OK</emphasis> to save the constraints and click the check mark to the right of the data type to save the data type.</simpara>
</listitem>
<listitem>
<simpara>Return to the <emphasis role="strong">Credit Score Rating</emphasis> decision table, click the <emphasis role="strong">Credit Score Rating</emphasis> column header, set the data type to this new custom data type, and define the rule values for that column with the rating constraints that you specified.</simpara>
<figure>
<title>Decision table for credit score rating</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example1a.png"/>
</imageobject>
<textobject><phrase>dmn decision table example1a</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the DMN decision model for this scenario, the <emphasis role="strong">Credit Score Rating</emphasis> decision flows into the following <emphasis role="strong">Loan Prequalification</emphasis> decision that also requires custom data types:</simpara>
<figure>
<title>Decision table for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-blank.png"/>
</imageobject>
<textobject><phrase>dmn manage data types blank</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Continuing with this example, return to the <emphasis role="strong">Data Types</emphasis> window, click <emphasis role="strong">New Data Type</emphasis>, and create a <emphasis role="strong">Loan_Qualification</emphasis> data type as a <literal>Structure</literal> with no constraints.</simpara>
<simpara>When you save the new structured data type, the first sub-field appears so that you can begin defining nested data fields in this parent data type. You can use these sub-fields in association with the parent structured data type in boxed expressions, such as nested column headers in decision tables or nested table parameters in context or function expressions.</simpara>
<simpara>For additional sub-fields, select the addition icon next to the <emphasis role="strong">Loan_Qualification</emphasis> data type:</simpara>
<figure>
<title>Adding a new structured data type with nested fields</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>For this example, under the structured <emphasis role="strong">Loan_Qualification</emphasis> data type, add a <emphasis role="strong">Qualification</emphasis> field with <literal>"Qualified"</literal> and <literal>"Not Qualified"</literal> enumeration constraints, and a <emphasis role="strong">Reason</emphasis> field with no constraints. Add also a simple <emphasis role="strong">Back_End_Ratio</emphasis> and a <emphasis role="strong">Front_End_Ratio</emphasis> data type, both with <literal>"Sufficient"</literal> and <literal>"Insufficient"</literal> enumeration constraints.</simpara>
<simpara>Click the check mark to the right of each data type that you create to save your changes.</simpara>
<figure>
<title>Adding nested data types with constraints</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured2.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured2</phrase></textobject>
</mediaobject>
</figure>
<simpara>To change the order or nesting of data types, you can click the left end of the data type row and drag the row as needed:</simpara>
<figure>
<title>Dragging data types to change data type order or nesting</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured2-drag.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured2 drag</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Return to the decision table and, for each column, click the column header cell, set the data type to the new corresponding custom data type, and define the rule values as needed for the column with the constraints that you specified, if applicable.</simpara>
<figure>
<title>Decision table for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-table-example3.png"/>
</imageobject>
<textobject><phrase>dmn decision table example3</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<simpara>For boxed expression types other than decision tables, you follow these guidelines similarly to navigate the boxed expression tables and define custom data types as needed.</simpara>
<simpara>For example, the following boxed function expression uses custom <literal>tCandidate</literal> and <literal>tProfile</literal> structured data types to associate data for online dating compatibility:</simpara>
<figure>
<title>Boxed function expression for online dating compatibility</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured3.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured3</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Custom data type definitions for online dating compatibility</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured3a.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured3a</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Parameter definitions with custom data types for online dating compatibility</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-manage-data-types-structured3b.png"/>
</imageobject>
<textobject><phrase>dmn manage data types structured3b</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-included-models-con_dmn-models">
<title>Included models in DMN files in Business Central</title>
<simpara>In the DMN designer in Business Central, you can use the <emphasis role="strong">Included Models</emphasis> tab to include other DMN models and Predictive Model Markup Language (PMML) models from your project in a specified DMN file. When you include a DMN model within another DMN file, you can use all of the nodes and logic from both models in the same decision requirements diagram (DRD). When you include a PMML model within a DMN file, you can invoke that PMML model as a boxed function expression for a DMN decision node or business knowledge model node.</simpara>
<simpara>You cannot include DMN or PMML models from other projects in Business Central.</simpara>
<section xml:id="dmn-included-models-dmn-proc_dmn-models">
<title>Including other DMN models within a DMN file in Business Central</title>
<simpara>In Business Central, you can include other DMN models from your project in a specified DMN file. When you include a DMN model within another DMN file, you can use all of the nodes and logic from both models in the same decision requirements diagram (DRD), but you cannot edit the nodes from the included model. To edit nodes from included models, you must update the source file for the included model directly. If you update the source file for an included DMN model, open the DMN file where the DMN model is included (or close an re-open) to verify the changes.</simpara>
<simpara>You cannot include DMN models from other projects in Business Central.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The DMN models are created or imported (as <literal>.dmn</literal> files) in the same project in Business Central as the DMN file in which you want to include the models.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis>, click the project name, and select the DMN file you want to modify.</simpara>
</listitem>
<listitem>
<simpara>In the DMN designer, click the <emphasis role="strong">Included Models</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Include Model</emphasis>, select a DMN model from your project in the <emphasis role="strong">Models</emphasis> list, enter a unique name for the included model, and click <emphasis role="strong">Include</emphasis>:</simpara>
<figure>
<title>Including a DMN model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model.png"/>
</imageobject>
<textobject><phrase>dmn include model</phrase></textobject>
</mediaobject>
</figure>
<simpara>The DMN model is added to this DMN file, and all DRD nodes from the included model are listed under <emphasis role="strong">Decision Components</emphasis> in the <emphasis role="strong">Decision Navigator</emphasis> view:</simpara>
<figure>
<title>DMN file with decision components from the included DMN model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-list.png"/>
</imageobject>
<textobject><phrase>dmn include model list</phrase></textobject>
</mediaobject>
</figure>
<simpara>All data types from the included model are also listed in read-only mode in the <emphasis role="strong">Data Types</emphasis> tab for the DMN file:</simpara>
<figure>
<title>DMN file with data types from the included DMN model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-data-types.png"/>
</imageobject>
<textobject><phrase>dmn include model data types</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> tab of the DMN designer, click and drag the included DRD components onto the canvas to begin implementing them in your DRD:</simpara>
<figure>
<title>Adding DRD components from the included DMN model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-drd.png"/>
</imageobject>
<textobject><phrase>dmn include model drd</phrase></textobject>
</mediaobject>
</figure>
<simpara>To edit DRD nodes or data types from included models, you must update the source file for the included model directly. If you update the source file for an included DMN model, open the DMN file where the DMN model is included (or close an re-open) to verify the changes.</simpara>
<simpara>To edit the included model name or to remove the included model from the DMN file, use the <emphasis role="strong">Included Models</emphasis> tab in the DMN designer.</simpara>
<important>
<simpara>When you remove an included model, any nodes from that included model that are currently used in the DRD are also removed.</simpara>
</important>
</listitem>
</orderedlist>
</section>
<section xml:id="dmn-included-models-pmml-proc_dmn-models">
<title>Including PMML models within a DMN file in Business Central</title>
<simpara>In Business Central, you can include Predictive Model Markup Language (PMML) models from your project in a specified DMN file. When you include a PMML model within a DMN file, you can invoke that PMML model as a boxed function expression for a DMN decision node or business knowledge model node. If you update the source file for an included PMML model, you must remove and re-include the PMML model in the DMN file to apply the source changes.</simpara>
<simpara>You cannot include PMML models from other projects in Business Central.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The PMML models are imported (as <literal>.pmml</literal> files) in the same project in Business Central as the DMN file in which you want to include the models.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your DMN project, add the following dependencies to the project <literal>pom.xml</literal> file to enable PMML evaluation:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Required for the PMML compiler --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;kie-pmml&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- Alternative dependencies for JPMML Evaluator, override `kie-pmml` dependency --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-dmn-jpmml&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jpmml&lt;/groupId&gt;
  &lt;artifactId&gt;pmml-evaluator&lt;/artifactId&gt;
  &lt;version&gt;1.5.1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jpmml&lt;/groupId&gt;
  &lt;artifactId&gt;pmml-evaluator-extension&lt;/artifactId&gt;
  &lt;version&gt;1.5.1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</programlisting>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, you can select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>If you want to use the full PMML specification implementation with the Java Evaluator API for PMML (JPMML), use the alternative set of JPMML dependencies in your DMN project. If the JPMML dependencies and the standard <literal>kie-pmml</literal> dependency are both present, the <literal>kie-pmml</literal> dependency is disabled. For information about JPMML licensing terms, see <link xlink:href="https://openscoring.io/">Openscoring.io</link>.</simpara>
<important>
<simpara>The legacy <literal>kie-pmml</literal> dependency is deprecated with Red Hat Decision Manager 7.10.0 and will be replaced by <literal>kie-pmml-trusty</literal> dependency in a future Red Hat Decision Manager release.</simpara>
</important>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between RHDM product and maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>If you added the JPMML dependencies in your DMN project to use the JPMML Evaluator, download the following JAR files and add them to the <literal>~/kie-server.war/WEB-INF/lib</literal> and <literal>~/business-central.war/WEB-INF/lib</literal> directories in your Red Hat Decision Manager distribution:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-dmn-jpmml</literal> JAR file in the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Maven Repository</emphasis> distribution (<literal>rhdm-7.10.0-maven-repository/maven-repository/org/kie/kie-dmn-jpmml/7.48.0.Final-redhat-00002/kie-dmn-jpmml-7.48.0.Final-redhat-00002.jar</literal>) from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html?downloadType=distributions&amp;product=rhdm&amp;version=7.10.0">Red Hat Customer Portal</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://mvnrepository.com/artifact/org.jpmml/pmml-evaluator/1.5.1">JPMML Evaluator 1.5.1</link> JAR file from the online Maven repository</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://mvnrepository.com/artifact/org.jpmml/pmml-evaluator-extension/1.5.1">JPMML Evaluator Extensions 1.5.1</link> JAR file from the online Maven repository</simpara>
</listitem>
</itemizedlist>
<simpara>These artifacts are required to enable JPMML evaluation in KIE Server and Business Central.</simpara>
<important>
<simpara>Red Hat supports integration with the Java Evaluator API for PMML (JPMML) for PMML execution in Red Hat Decision Manager. However, Red Hat does not support the JPMML libraries directly. If you include JPMML libraries in your Red Hat Decision Manager distribution, see the <link xlink:href="https://openscoring.io/">Openscoring.io</link> licensing terms for JPMML.</simpara>
</important>
</listitem>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis>, click the project name, and select the DMN file you want to modify.</simpara>
</listitem>
<listitem>
<simpara>In the DMN designer, click the <emphasis role="strong">Included Models</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Include Model</emphasis>, select a PMML model from your project in the <emphasis role="strong">Models</emphasis> list, enter a unique name for the included model, and click <emphasis role="strong">Include</emphasis>:</simpara>
<figure>
<title>Including a PMML model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-pmml.png"/>
</imageobject>
<textobject><phrase>dmn include model pmml</phrase></textobject>
</mediaobject>
</figure>
<simpara>The PMML model is added to this DMN file:</simpara>
<figure>
<title>DMN file with included PMML model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-list-pmml.png"/>
</imageobject>
<textobject><phrase>dmn include model list pmml</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> tab of the DMN designer, select or create the decision node or business knowledge model node in which you want to invoke the PMML model and click the <emphasis role="strong">Edit</emphasis> icon to open the DMN boxed expression designer:</simpara>
<figure>
<title>Opening a new decision node boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-decision-edit.png"/>
</imageobject>
<textobject><phrase>dmn decision edit</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Opening a new business knowledge model boxed expression</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-bkm-edit.png"/>
</imageobject>
<textobject><phrase>dmn bkm edit</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Set the expression type to <emphasis role="strong">Function</emphasis> (default for business knowledge model nodes), click the top-left function cell, and select <emphasis role="strong">PMML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">document</emphasis> and <emphasis role="strong">model</emphasis> rows in the table, double-click the undefined cells to specify the included PMML document and the relevant PMML model within that document:</simpara>
<figure>
<title>Adding a PMML model in a DMN business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-include-model-expression-pmml.png"/>
</imageobject>
<textobject><phrase>dmn include model expression pmml</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Example PMML definition in a DMN business knowledge model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-function-expression-example5.png"/>
</imageobject>
<textobject><phrase>dmn function expression example5</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you update the source file for an included PMML model, you must remove and re-include the PMML model in the DMN file to apply the source changes.</simpara>
<simpara>To edit the included model name or to remove the included model from the DMN file, use the <emphasis role="strong">Included Models</emphasis> tab in the DMN designer.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="dmn-model-creating-multiples-proc_dmn-models">
<title>Creating DMN models with multiple diagrams in Business Central</title>
<simpara>For complex DMN models, you can use the DMN designer in Business Central to design multiple DMN decision requirements diagrams (DRDs) that represent parts of the overall decision requirements graph (DRG) for the DMN decision model. In simple cases, you can use a single DRD to represent all of the overall DRG for the decision model, but in complex cases, a single DRD can become large and difficult to follow. Therefore, to better organize DMN decision models with many decision requirements, you can divide the model into smaller nested DRDs that constitute the larger central DRD representation of the overall DRG.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You understand how to design DRDs in Business Central. For information about creating DRDs, see <xref linkend="dmn-model-creating-proc_dmn-models"/>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, navigate to your DMN project and create or import a DMN file in the project.</simpara>
</listitem>
<listitem>
<simpara>Open the new or imported DMN file to view the DRD in the DMN designer, and begin designing or modifying the DRD using the DMN nodes in the left toolbar.</simpara>
</listitem>
<listitem>
<simpara>For any DMN nodes that you want to define in a separate nested DRD, select the node, click the <emphasis role="strong">DRD Actions</emphasis> icon, and select from the available options.</simpara>
<figure>
<title>DRD actions icon for subdividing a DRD</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-actions.png"/>
</imageobject>
<textobject><phrase>dmn drd actions</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following options are available:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Create</emphasis>: Use this option to create a nested DRD where you can separately define the DMN components and diagram for the selected node.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Add to</emphasis>: If you already created a nested DRD, use this option to add the selected node to an existing DRD.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Remove</emphasis>: If the node that you selected is already within a nested DRD, use this option to remove the node from that nested DRD.</simpara>
</listitem>
</itemizedlist>
<simpara>After you create a nested DRD within your DMN decision model, the new DRD opens in a separate DRD canvas and the available DRD and components are listed in the <emphasis role="strong">Decision Navigator</emphasis> left menu. You can use the <emphasis role="strong">Decision Navigator</emphasis> menu to rename or remove a nested DRD.</simpara>
<figure>
<title>Rename new nested DRD in the Decision Navigator menu</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-actions-rename.png"/>
</imageobject>
<textobject><phrase>dmn drd actions rename</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>In the separate canvas for the new nested DRD, design the flow and logic for all required components in this portion of the DMN model, as usual.</simpara>
</listitem>
<listitem>
<simpara>Continue adding and defining any other nested DRDs for your decision model and save the completed DMN file.</simpara>
<simpara>For example, the following DRD for a loan prequalification decision model contains all DMN components for the model without any nested DRDs. This example relies on the single DRD for all components and logic, resulting in a large and complex diagram.</simpara>
<figure>
<title>Single DRD for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-example-drd.png"/>
</imageobject>
<textobject><phrase>dmn example drd</phrase></textobject>
</mediaobject>
</figure>
<simpara>Alternatively, by following the steps in this procedure, you can divide this example DRD into multiple nested DRDs to better organize the decision requirements, as shown in the following example:</simpara>
<figure>
<title>Multiple nested DRDs for loan prequalification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Overview of front end ratio DRD</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-front-end.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple front end</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>DRD for front end ratio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-front-end-details.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple front end details</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Overview of credit score rating DRD</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-credit-score.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple credit score</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>DRD for credit score rating</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-credit-score-details.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple credit score details</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Overview of back end ratio DRD</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-back-end.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple back end</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>DRD for back end ratio</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-drd-multiple-back-end-details.png"/>
</imageobject>
<textobject><phrase>dmn drd multiple back end details</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
</section>
<section xml:id="dmn-documentation-con_dmn-models">
<title>DMN model documentation in Business Central</title>
<simpara>In the DMN designer in Business Central, you can use the <emphasis role="strong">Documentation</emphasis> tab to generate a report of your DMN model that you can print or download as an HTML file for offline use. The DMN model report contains all decision requirements diagrams (DRDs), data types, and boxed expressions in your DMN model. You can use this report to share your DMN model details or as part of your internal reporting workflow.</simpara>
<figure>
<title>Example DMN model report</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-documentation.png"/>
</imageobject>
<textobject><phrase>dmn documentation</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="dmn-designer-nav-ref_dmn-models">
<title>DMN designer navigation and properties in Business Central</title>
<simpara>The DMN designer in Business Central provides the following additional features to help you navigate through the components and properties of decision requirements diagrams (DRDs).</simpara>
<variablelist>
<varlistentry>
<term>DMN file and diagram views</term>
<listitem>
<simpara>In the upper-left corner of the DMN designer, select the <emphasis role="strong">Project Explorer</emphasis> view to navigate between all DMN and other files or select the <emphasis role="strong">Decision Navigator</emphasis> view to navigate between the decision components, graphs, and boxed expressions of a selected DRD:</simpara>
<figure>
<title>Project Explorer view</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-project-view.png"/>
</imageobject>
<textobject><phrase>dmn designer project view</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Decision Navigator view</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-nav-view.png"/>
</imageobject>
<textobject><phrase>dmn designer nav view</phrase></textobject>
</mediaobject>
</figure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-nav-view2.png"/>
</imageobject>
<textobject><phrase>dmn designer nav view2</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>The DRD components from any DMN models included in the DMN file (in the <emphasis role="strong">Included Models</emphasis> tab) are also listed in the <emphasis role="strong">Decision Components</emphasis> panel for the DMN file.</simpara>
</note>
<simpara>In the upper-right corner of the DMN designer, select the <emphasis role="strong">Explore diagram</emphasis> icon to view an elevated preview of the selected DRD and to navigate between the nodes of the selected DRD:</simpara>
<figure>
<title>Explore diagram view</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-preview.png"/>
</imageobject>
<textobject><phrase>dmn designer preview</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
<varlistentry>
<term>DRD properties and design</term>
<listitem>
<simpara>In the upper-right corner of the DMN designer, select the <emphasis role="strong">Properties</emphasis> icon to modify the identifying information, data types, and appearance of a selected DRD, DRD node, or boxed expression cell:</simpara>
<figure>
<title>DRD node properties</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-properties.png"/>
</imageobject>
<textobject><phrase>dmn designer properties</phrase></textobject>
</mediaobject>
</figure>
<simpara>To view the properties of the entire DRD, click the DRD canvas background instead of a specific node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DRD search</term>
<listitem>
<simpara>In the upper-right corner of the DMN designer, use the search bar to search for text that appears in your DRD. The search feature is especially helpful in complex DRDs with many nodes:</simpara>
<figure>
<title>DRD search</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-designer-search.png"/>
</imageobject>
<textobject><phrase>dmn designer search</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</varlistentry>
</variablelist>
</section>
</chapter>
<chapter xml:id="dmn-execution-con_dmn-models">
<title>DMN model execution</title>
<simpara>You can create or import DMN files in your Red Hat Decision Manager project using Business Central or package the DMN files as part of your project knowledge JAR (KJAR) file without Business Central. After you implement your DMN files in your Red Hat Decision Manager project, you can execute the DMN decision service by deploying the KIE container that contains it to KIE Server for remote access
or by manipulating the KIE container directly as a dependency of the calling application. Other options for creating and deploying DMN knowledge packages are also available, and most are similar for all types of knowledge assets, such as DRL files or process definitions.</simpara>
<simpara>For information about including external DMN assets with your project packaging and deployment method, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<section xml:id="dmn-execution-embedded-proc">
<title>Embedding a DMN call directly in a Java application</title>
<simpara>A KIE container is local when the knowledge assets are either embedded directly into the calling program or are physically pulled in using Maven dependencies for the KJAR. You typically embed knowledge assets directly into a project if there is a tight relationship between the version of the code and the version of the DMN definition. Any changes to the decision take effect after you have intentionally updated and redeployed the application. A benefit of this approach is that proper operation does not rely on any external dependencies to the run time, which can be a limitation of locked-down environments.</simpara>
<simpara>Using Maven dependencies enables further flexibility because the specific version of the decision can dynamically change, (for example, by using a system property), and it can be periodically scanned for updates and automatically updated. This introduces an external dependency on the deploy time of the service, but executes the decision locally, reducing reliance on an external service being available during run time.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have built the DMN project as a KJAR artifact and deployed it to a Maven repository, or you have included your DMN assets as part of your project classpath. Ideally, you have built the DMN project as an executable model for more efficient execution:</simpara>
<screen>mvn clean install -DgenerateDMNModel=yes</screen>
<simpara>For more information about project packaging and deployment and executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your client application, add the following dependencies to the relevant classpath of your Java project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Required for the DMN runtime API --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-dmn-core&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Required if not using classpath KIE container --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>The <literal>&lt;version&gt;</literal> is the Maven artifact version for Red Hat Decision Manager currently used in your project (for example, 7.48.0.Final-redhat-00002).</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between RHDM product and maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a KIE container from <literal>classpath</literal> or <literal>ReleaseId</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "my-kjar", "1.0.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );</programlisting>
<simpara>Alternative option:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

KieContainer kieContainer = kieServices.getKieClasspathContainer();</programlisting>
</listitem>
<listitem>
<simpara>Obtain <literal>DMNRuntime</literal> from the KIE container and a reference to the DMN model to be evaluated, by using the model <literal>namespace</literal> and <literal>modelName</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">DMNRuntime dmnRuntime = KieRuntimeFactory.of(kieContainer.getKieBase()).get(DMNRuntime.class);

String namespace = "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a";
String modelName = "dmn-movieticket-ageclassification";

DMNModel dmnModel = dmnRuntime.getModel(namespace, modelName);</programlisting>
</listitem>
<listitem>
<simpara>Execute the decision services for the desired model:</simpara>
<programlisting language="java" linenumbering="unnumbered">DMNContext dmnContext = dmnRuntime.newContext();  <co xml:id="CO1-1"/>

for (Integer age : Arrays.asList(1,12,13,64,65,66)) {
    dmnContext.set("Age", age);  <co xml:id="CO1-2"/>
    DMNResult dmnResult =
        dmnRuntime.evaluateAll(dmnModel, dmnContext);  <co xml:id="CO1-3"/>

    for (DMNDecisionResult dr : dmnResult.getDecisionResults()) {  <co xml:id="CO1-4"/>
        log.info("Age: " + age + ", " +
                 "Decision: '" + dr.getDecisionName() + "', " +
                 "Result: " + dr.getResult());
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Instantiate a new DMN Context to be the input for the model evaluation. Note that this example is looping through the Age Classification decision multiple times.</para>
</callout>
<callout arearefs="CO1-2">
<para>Assign input variables for the input DMN context.</para>
</callout>
<callout arearefs="CO1-3">
<para>Evaluate all DMN decisions defined in the DMN model.</para>
</callout>
<callout arearefs="CO1-4">
<para>Each evaluation may result in one or more results, creating the loop.</para>
</callout>
</calloutlist>
<simpara>This example prints the following output:</simpara>
<screen>Age 1 Decision 'AgeClassification' : Child
Age 12 Decision 'AgeClassification' : Child
Age 13 Decision 'AgeClassification' : Adult
Age 64 Decision 'AgeClassification' : Adult
Age 65 Decision 'AgeClassification' : Senior
Age 66 Decision 'AgeClassification' : Senior</screen>
<simpara>If the DMN model was not previously compiled as an executable model for more efficient execution, you can enable the following property when you execute your DMN models:</simpara>
<screen>-Dorg.kie.dmn.compiler.execmodel=true</screen>
</listitem>
</orderedlist>
</section>
<section xml:id="dmn-execution-remote-java-proc">
<title>Executing a DMN service using the KIE Server Java client API</title>
<simpara>The KIE Server Java client API provides a lightweight approach to invoking a remote DMN service either through the REST or JMS interfaces of KIE Server. This approach reduces the number of runtime dependencies necessary to interact with a KIE base. Decoupling the calling code from the decision definition also increases flexibility by enabling them to iterate independently at the appropriate pace.</simpara>
<simpara>For more information about the KIE Server Java client API, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-kie-apis"><emphasis>Interacting with Red Hat Decision Manager using KIE APIs</emphasis></link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>KIE Server is installed and configured, including a known user name and credentials for a user with the <literal>kie-server</literal> role. For installation options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have built the DMN project as a KJAR artifact and deployed it to KIE Server. Ideally, you have built the DMN project as an executable model for more efficient execution:</simpara>
<screen>mvn clean install -DgenerateDMNModel=yes</screen>
<simpara>For more information about project packaging and deployment and executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have the ID of the KIE container containing the DMN model. If more than one model is present, you must also know the model namespace and model name of the relevant model.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your client application, add the following dependency to the relevant classpath of your Java project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Required for the KIE Server Java client API --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>The <literal>&lt;version&gt;</literal> is the Maven artifact version for Red Hat Decision Manager currently used in your project (for example, 7.48.0.Final-redhat-00002).</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between RHDM product and maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Instantiate a <literal>KieServicesClient</literal> instance with the appropriate connection information.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServicesConfiguration conf =
    KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD); <co xml:id="CO2-1"/>

conf.setMarshallingFormat(MarshallingFormat.JSON);  <co xml:id="CO2-2"/>

KieServicesClient kieServicesClient = KieServicesFactory.newKieServicesClient(conf);</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>The connection information:</para>
<itemizedlist>
<listitem>
<simpara>Example URL: <literal>http://localhost:8080/kie-server/services/rest/server</literal></simpara>
</listitem>
<listitem>
<simpara>The credentials should reference a user with the <literal>kie-server</literal> role.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO2-2">
<para>The Marshalling format is an instance of <literal>org.kie.server.api.marshalling.MarshallingFormat</literal>. It controls whether the messages will be JSON or XML. Options for Marshalling format are JSON, JAXB, or XSTREAM.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Obtain a <literal>DMNServicesClient</literal> from the KIE server Java client connected to the related KIE Server by invoking the method <literal>getServicesClient()</literal> on the KIE server Java client instance:</simpara>
<programlisting language="java" linenumbering="unnumbered">DMNServicesClient dmnClient = kieServicesClient.getServicesClient(DMNServicesClient.class );</programlisting>
<simpara>The <literal>dmnClient</literal> can now execute decision services on KIE Server.</simpara>
</listitem>
<listitem>
<simpara>Execute the decision services for the desired model.</simpara>
<simpara>Example:</simpara>
<programlisting language="java" linenumbering="unnumbered">for (Integer age : Arrays.asList(1,12,13,64,65,66)) {
    DMNContext dmnContext = dmnClient.newContext(); <co xml:id="CO3-1"/>
    dmnContext.set("Age", age);  <co xml:id="CO3-2"/>
    ServiceResponse&lt;DMNResult&gt; serverResp =   <co xml:id="CO3-3"/>
        dmnClient.evaluateAll($kieContainerId,
                              $modelNamespace,
                              $modelName,
                              dmnContext);

    DMNResult dmnResult = serverResp.getResult();  <co xml:id="CO3-4"/>
    for (DMNDecisionResult dr : dmnResult.getDecisionResults()) {
        log.info("Age: " + age + ", " +
                 "Decision: '" + dr.getDecisionName() + "', " +
                 "Result: " + dr.getResult());
    }
}</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>Instantiate a new DMN Context to be the input for the model evaluation. Note that this example is looping through the Age Classification decision multiple times.</para>
</callout>
<callout arearefs="CO3-2">
<para>Assign input variables for the input DMN Context.</para>
</callout>
<callout arearefs="CO3-3">
<para>Evaluate all the DMN Decisions defined in the DMN model:</para>
<itemizedlist>
<listitem>
<simpara><literal>$kieContainerId</literal> is the ID of the container where the KJAR containing the DMN model is deployed</simpara>
</listitem>
<listitem>
<simpara><literal>$modelNamespace</literal> is the namespace for the model.</simpara>
</listitem>
<listitem>
<simpara><literal>$modelName</literal> is the name for the model.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO3-4">
<para>The DMN Result object is available from the server response.</para>
</callout>
</calloutlist>
<simpara>At this point, the <literal>dmnResult</literal> contains all the decision results from the evaluated DMN model.</simpara>
<simpara>You can also execute only a specific DMN decision in the model by using alternative methods of the <literal>DMNServicesClient</literal>.</simpara>
<note>
<simpara>If the KIE container only contains one DMN model, you can omit <literal>$modelNamespace</literal> and <literal>$modelName</literal> because the KIE Server API selects it by default.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="dmn-execution-rest-proc_dmn-models">
<title>Executing a DMN service using the KIE Server REST API</title>
<simpara>Directly interacting with the REST endpoints of KIE Server provides the most separation between the calling code and the decision logic definition. The calling code is completely free of direct dependencies, and you can implement it in an entirely different development platform such as <literal>Node.js</literal> or <literal>.NET</literal>. The examples in this section demonstrate Nix-style curl commands but provide relevant information to adapt to any REST client.</simpara>
<simpara>For more information about the KIE Server REST API, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-kie-apis"><emphasis>Interacting with Red Hat Decision Manager using KIE APIs</emphasis></link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>KIE Server is installed and configured, including a known user name and credentials for a user with the <literal>kie-server</literal> role. For installation options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have built the DMN project as a KJAR artifact and deployed it to KIE Server. Ideally, you have built the DMN project as an executable model for more efficient execution:</simpara>
<screen>mvn clean install -DgenerateDMNModel=yes</screen>
<simpara>For more information about project packaging and deployment and executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have the ID of the KIE container containing the DMN model. If more than one model is present, you must also know the model namespace and model name of the relevant model.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Determine the base URL for accessing the KIE Server REST API endpoints. This requires knowing the following values (with the default local deployment values as an example):</simpara>
<itemizedlist>
<listitem>
<simpara>Host (<literal>localhost</literal>)</simpara>
</listitem>
<listitem>
<simpara>Port (<literal>8080</literal>)</simpara>
</listitem>
<listitem>
<simpara>Root context (<literal>kie-server</literal>)</simpara>
</listitem>
<listitem>
<simpara>Base REST path (<literal>services/rest/</literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>Example base URL in local deployment:</simpara>
<simpara><literal>http://localhost:8080/kie-server/services/rest/</literal></simpara>
</listitem>
<listitem>
<simpara>Determine user authentication requirements.</simpara>
<simpara>When users are defined directly in the KIE Server configuration, HTTP Basic authentication is used and requires the user name and password. Successful requests require that the user have the <literal>kie-server</literal> role.</simpara>
<simpara>The following example demonstrates how to add credentials to a curl request:</simpara>
<screen>curl -u username:password &lt;request&gt;</screen>
<simpara>If KIE Server is configured with Red Hat Single Sign-On, the request must include a bearer token:</simpara>
<programlisting language="java" linenumbering="unnumbered">curl -H "Authorization: bearer $TOKEN" &lt;request&gt;</programlisting>
</listitem>
<listitem>
<simpara>Specify the format of the request and response. The REST API endpoints work with both JSON and XML formats and are set using request headers:</simpara>
<formalpara>
<title>JSON</title>
<para>
<screen>curl -H "accept: application/json" -H "content-type: application/json"</screen>
</para>
</formalpara>
<formalpara>
<title>XML</title>
<para>
<screen>curl -H "accept: application/xml" -H "content-type: application/xml"</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Query the container for a list of deployed decision models:</simpara>
<simpara><emphasis role="strong">[GET]</emphasis> <literal>server/containers/{containerId}/dmn</literal></simpara>
<simpara>Example curl request:</simpara>
<screen>curl -u krisv:krisv -H "accept: application/xml" -X GET "http://localhost:8080/kie-server/services/rest/server/containers/MovieDMNContainer/dmn"</screen>
<simpara>Sample XML output:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;response type="SUCCESS" msg="OK models successfully retrieved from container 'MovieDMNContainer'"&gt;
    &lt;dmn-model-info-list&gt;
        &lt;model&gt;
            &lt;model-namespace&gt;http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a&lt;/model-namespace&gt;
            &lt;model-name&gt;dmn-movieticket-ageclassification&lt;/model-name&gt;
            &lt;model-id&gt;_99&lt;/model-id&gt;
            &lt;decisions&gt;
                &lt;dmn-decision-info&gt;
                    &lt;decision-id&gt;_3&lt;/decision-id&gt;
                    &lt;decision-name&gt;AgeClassification&lt;/decision-name&gt;
                &lt;/dmn-decision-info&gt;
            &lt;/decisions&gt;
        &lt;/model&gt;
    &lt;/dmn-model-info-list&gt;
&lt;/response&gt;</programlisting>
<simpara>Sample JSON output:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "type" : "SUCCESS",
  "msg" : "OK models successfully retrieved from container 'MovieDMNContainer'",
  "result" : {
    "dmn-model-info-list" : {
      "models" : [ {
        "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
        "model-name" : "dmn-movieticket-ageclassification",
        "model-id" : "_99",
        "decisions" : [ {
          "decision-id" : "_3",
          "decision-name" : "AgeClassification"
        } ]
      } ]
    }
  }
}</programlisting>
</listitem>
<listitem>
<simpara>Execute the model:</simpara>
<simpara><emphasis role="strong">[POST]</emphasis> <literal>server/containers/{containerId}/dmn</literal></simpara>
<simpara>Example curl request:</simpara>
<screen>curl -u krisv:krisv -H "accept: application/json" -H "content-type: application/json" -X POST "http://localhost:8080/kie-server/services/rest/server/containers/MovieDMNContainer/dmn" -d "{ \"model-namespace\" : \"http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a\", \"model-name\" : \"dmn-movieticket-ageclassification\", \"decision-name\" : [ ], \"decision-id\" : [ ], \"dmn-context\" : {\"Age\" : 66}}"</screen>
<simpara>Example JSON request:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
  "model-name" : "dmn-movieticket-ageclassification",
  "decision-name" : [ ],
  "decision-id" : [ ],
  "dmn-context" : {"Age" : 66}
}</programlisting>
<simpara>Example XML request (JAXB format):</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dmn-evaluation-context&gt;
    &lt;model-namespace&gt;http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a&lt;/model-namespace&gt;
    &lt;model-name&gt;dmn-movieticket-ageclassification&lt;/model-name&gt;
    &lt;dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
        &lt;type&gt;MAP&lt;/type&gt;
        &lt;element xsi:type="jaxbStringObjectPair" key="Age"&gt;
            &lt;value xsi:type="xs:int" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;66&lt;/value&gt;
        &lt;/element&gt;
    &lt;/dmn-context&gt;
&lt;/dmn-evaluation-context&gt;</programlisting>
<note>
<simpara>Regardless of the request format, the request requires the following elements:</simpara>
<itemizedlist>
<listitem>
<simpara>Model namespace</simpara>
</listitem>
<listitem>
<simpara>Model name</simpara>
</listitem>
<listitem>
<simpara>Context object containing input values</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>Example JSON response:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "type" : "SUCCESS",
  "msg" : "OK from container 'MovieDMNContainer'",
  "result" : {
    "dmn-evaluation-result" : {
      "messages" : [ ],
      "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
      "model-name" : "dmn-movieticket-ageclassification",
      "decision-name" : [ ],
      "dmn-context" : {
        "Age" : 66,
        "AgeClassification" : "Senior"
      },
      "decision-results" : {
        "_3" : {
          "messages" : [ ],
          "decision-id" : "_3",
          "decision-name" : "AgeClassification",
          "result" : "Senior",
          "status" : "SUCCEEDED"
        }
      }
    }
  }
}</programlisting>
<simpara>Example XML (JAXB format) response:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;response type="SUCCESS" msg="OK from container 'MovieDMNContainer'"&gt;
      &lt;dmn-evaluation-result&gt;
            &lt;model-namespace&gt;http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a&lt;/model-namespace&gt;
            &lt;model-name&gt;dmn-movieticket-ageclassification&lt;/model-name&gt;
            &lt;dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
                  &lt;type&gt;MAP&lt;/type&gt;
                  &lt;element xsi:type="jaxbStringObjectPair" key="Age"&gt;
                        &lt;value xsi:type="xs:int" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;66&lt;/value&gt;
                  &lt;/element&gt;
                  &lt;element xsi:type="jaxbStringObjectPair" key="AgeClassification"&gt;
                        &lt;value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;Senior&lt;/value&gt;
                  &lt;/element&gt;
            &lt;/dmn-context&gt;
            &lt;messages/&gt;
            &lt;decisionResults&gt;
                  &lt;entry&gt;
                        &lt;key&gt;_3&lt;/key&gt;
                        &lt;value&gt;
                              &lt;decision-id&gt;_3&lt;/decision-id&gt;
                              &lt;decision-name&gt;AgeClassification&lt;/decision-name&gt;
                              &lt;result xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;Senior&lt;/result&gt;
                              &lt;messages/&gt;
                              &lt;status&gt;SUCCEEDED&lt;/status&gt;
                        &lt;/value&gt;
                  &lt;/entry&gt;
            &lt;/decisionResults&gt;
      &lt;/dmn-evaluation-result&gt;
&lt;/response&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="additional_resources" remap="_additional_resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://www.omg.org/spec/DMN">Decision Model and Notation specification</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://dmn-tck.github.io/tck/">DMN Technology Compatibility Kit</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-kie-apis"><emphasis>Interacting with Red Hat Decision Manager using KIE APIs</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-pmml-models">
<title>Designing a decision service using PMML models</title>
<partintro>
<simpara>As a business rules developer, you can use Predictive Model Markup Language (PMML) to define statistical or data-mining models that you can integrate with your decision services in Red Hat Decision Manager. Red Hat Decision Manager includes consumer conformance support of PMML 4.2.1 for Regression, Scorecard, Tree, and Mining models. Red Hat Decision Manager does not include a built-in PMML model editor, but you can use an XML or PMML-specific authoring tool to create PMML models and then integrate them with your Red Hat Decision Manager projects.</simpara>
<simpara>For more information about PMML, see the DMG <link xlink:href="http://dmg.org/pmml/pmml-v4-2-1.html">PMML specification</link>.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models and include your PMML models as part of your DMN service. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#dmn-included-models-pmml-proc_dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_pmml-models">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="pmml-con_pmml-models">
<title>Predictive Model Markup Language (PMML)</title>
<simpara>Predictive Model Markup Language (PMML) is an XML-based standard established by the Data Mining Group (DMG) for defining statistical and data-mining models. PMML models can be shared between PMML-compliant platforms and across organizations so that business analysts and developers are unified in designing, analyzing, and implementing PMML-based assets and services.</simpara>
<simpara>For more information about the background and applications of PMML, see the DMG <link xlink:href="http://dmg.org/pmml/pmml-v4-2-1.html">PMML specification</link>.</simpara>
<section xml:id="pmml-conformance-con_pmml-models">
<title>PMML conformance levels</title>
<simpara>The PMML specification defines producer and consumer conformance levels in a software implementation to ensure that PMML models are created and integrated reliably. For the formal definitions of each conformance level, see the DMG <link xlink:href="http://dmg.org/pmml/v4-2-1/Conformance.html">PMML conformance</link> page.</simpara>
<simpara>The following list summarizes the PMML conformance levels:</simpara>
<variablelist>
<varlistentry>
<term>Producer conformance</term>
<listitem>
<simpara>A tool or application is producer conforming if it generates valid PMML documents for at least one type of model. Satisfying PMML producer conformance requirements ensures that a model definition document is syntactically correct and defines a model instance that is consistent with semantic criteria that are defined in model specifications.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Consumer conformance</term>
<listitem>
<simpara>An application is consumer conforming if it accepts valid PMML documents for at least one type of model. Satisfying consumer conformance requirements ensures that a PMML model created according to producer conformance can be integrated and used as defined. For example, if an application is consumer conforming for Regression model types, then valid PMML documents defining models of this type produced by different conforming producers would be interchangeable in the application.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Red Hat Decision Manager includes consumer conformance support for the following PMML 4.2.1 model types:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/Regression.html">Regression models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/Scorecard.html">Scorecard models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/TreeModel.html">Tree models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/MultipleModels.html#xsdElement_MiningModel">Mining models</link> (with sub-types <literal>modelChain</literal>, <literal>selectAll</literal>, and <literal>selectFirst</literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>For a list of all PMML model types, including those not supported in Red Hat Decision Manager, see the DMG <link xlink:href="http://dmg.org/pmml/v4-2-1/GeneralStructure.html">PMML specification</link>.</simpara>
</section>
</chapter>
<chapter xml:id="pmml-examples-ref_pmml-models">
<title>PMML model examples</title>
<simpara>PMML defines an <link xlink:href="http://dmg.org/pmml/v4-2-1/pmml-4-2.xsd">XML schema</link> that enables PMML models to be used between different PMML-compliant platforms. The PMML specification enables multiple software platforms to work with the same file for authoring, testing, and production execution, assuming producer and consumer conformance are met.</simpara>
<simpara>The following are examples of PMML Regression, Scorecard, Tree, and Mining models. These examples illustrate the supported types of models that you can integrate with your decision services in Red Hat Decision Manager.</simpara>
<simpara>For more PMML examples, see the DMG <link xlink:href="http://dmg.org/pmml/pmml_examples/index.html">PMML Sample Files</link> page.</simpara>
<formalpara>
<title>Example PMML Regression model</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;PMML version="4.2" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 http://www.dmg.org/v4-2-1/pmml-4-2.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.dmg.org/PMML-4_2"&gt;
  &lt;Header copyright="JBoss"/&gt;
  &lt;DataDictionary numberOfFields="5"&gt;
    &lt;DataField dataType="double" name="fld1" optype="continuous"/&gt;
    &lt;DataField dataType="double" name="fld2" optype="continuous"/&gt;
    &lt;DataField dataType="string" name="fld3" optype="categorical"&gt;
      &lt;Value value="x"/&gt;
      &lt;Value value="y"/&gt;
    &lt;/DataField&gt;
    &lt;DataField dataType="double" name="fld4" optype="continuous"/&gt;
    &lt;DataField dataType="double" name="fld5" optype="continuous"/&gt;
  &lt;/DataDictionary&gt;
  &lt;RegressionModel algorithmName="linearRegression" functionName="regression" modelName="LinReg" normalizationMethod="logit" targetFieldName="fld4"&gt;
    &lt;MiningSchema&gt;
      &lt;MiningField name="fld1"/&gt;
      &lt;MiningField name="fld2"/&gt;
      &lt;MiningField name="fld3"/&gt;
      &lt;MiningField name="fld4" usageType="predicted"/&gt;
      &lt;MiningField name="fld5" usageType="target"/&gt;
    &lt;/MiningSchema&gt;
    &lt;RegressionTable intercept="0.5"&gt;
      &lt;NumericPredictor coefficient="5" exponent="2" name="fld1"/&gt;
      &lt;NumericPredictor coefficient="2" exponent="1" name="fld2"/&gt;
      &lt;CategoricalPredictor coefficient="-3" name="fld3" value="x"/&gt;
      &lt;CategoricalPredictor coefficient="3" name="fld3" value="y"/&gt;
      &lt;PredictorTerm coefficient="0.4"&gt;
        &lt;FieldRef field="fld1"/&gt;
        &lt;FieldRef field="fld2"/&gt;
      &lt;/PredictorTerm&gt;
    &lt;/RegressionTable&gt;
  &lt;/RegressionModel&gt;
&lt;/PMML&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example PMML Scorecard model</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;PMML version="4.2" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 http://www.dmg.org/v4-2-1/pmml-4-2.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.dmg.org/PMML-4_2"&gt;
  &lt;Header copyright="JBoss"/&gt;
  &lt;DataDictionary numberOfFields="4"&gt;
    &lt;DataField name="param1" optype="continuous" dataType="double"/&gt;
    &lt;DataField name="param2" optype="continuous" dataType="double"/&gt;
    &lt;DataField name="overallScore" optype="continuous" dataType="double" /&gt;
    &lt;DataField name="finalscore" optype="continuous" dataType="double" /&gt;
  &lt;/DataDictionary&gt;
  &lt;Scorecard modelName="ScorecardCompoundPredicate" useReasonCodes="true" isScorable="true" functionName="regression"    baselineScore="15" initialScore="0.8" reasonCodeAlgorithm="pointsAbove"&gt;
    &lt;MiningSchema&gt;
      &lt;MiningField name="param1" usageType="active" invalidValueTreatment="asMissing"&gt;
      &lt;/MiningField&gt;
      &lt;MiningField name="param2" usageType="active" invalidValueTreatment="asMissing"&gt;
      &lt;/MiningField&gt;
      &lt;MiningField name="overallScore" usageType="target"/&gt;
      &lt;MiningField name="finalscore" usageType="predicted"/&gt;
    &lt;/MiningSchema&gt;
    &lt;Characteristics&gt;
      &lt;Characteristic name="ch1" baselineScore="50" reasonCode="reasonCh1"&gt;
        &lt;Attribute partialScore="20"&gt;
          &lt;SimplePredicate field="param1" operator="lessThan" value="20"/&gt;
        &lt;/Attribute&gt;
        &lt;Attribute partialScore="100"&gt;
          &lt;CompoundPredicate booleanOperator="and"&gt;
            &lt;SimplePredicate field="param1" operator="greaterOrEqual" value="20"/&gt;
            &lt;SimplePredicate field="param2" operator="lessOrEqual" value="25"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Attribute&gt;
        &lt;Attribute partialScore="200"&gt;
          &lt;CompoundPredicate booleanOperator="and"&gt;
            &lt;SimplePredicate field="param1" operator="greaterOrEqual" value="20"/&gt;
            &lt;SimplePredicate field="param2" operator="greaterThan" value="25"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Attribute&gt;
      &lt;/Characteristic&gt;
      &lt;Characteristic name="ch2" reasonCode="reasonCh2"&gt;
        &lt;Attribute partialScore="10"&gt;
          &lt;CompoundPredicate booleanOperator="or"&gt;
            &lt;SimplePredicate field="param2" operator="lessOrEqual" value="-5"/&gt;
            &lt;SimplePredicate field="param2" operator="greaterOrEqual" value="50"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Attribute&gt;
        &lt;Attribute partialScore="20"&gt;
          &lt;CompoundPredicate booleanOperator="and"&gt;
            &lt;SimplePredicate field="param2" operator="greaterThan" value="-5"/&gt;
            &lt;SimplePredicate field="param2" operator="lessThan" value="50"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Attribute&gt;
      &lt;/Characteristic&gt;
    &lt;/Characteristics&gt;
  &lt;/Scorecard&gt;
&lt;/PMML&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example PMML Tree model</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;PMML version="4.2" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 http://www.dmg.org/v4-2-1/pmml-4-2.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.dmg.org/PMML-4_2"&gt;
  &lt;Header copyright="JBOSS"/&gt;
  &lt;DataDictionary numberOfFields="5"&gt;
    &lt;DataField dataType="double" name="fld1" optype="continuous"/&gt;
    &lt;DataField dataType="double" name="fld2" optype="continuous"/&gt;
    &lt;DataField dataType="string" name="fld3" optype="categorical"&gt;
      &lt;Value value="true"/&gt;
      &lt;Value value="false"/&gt;
    &lt;/DataField&gt;
    &lt;DataField dataType="string" name="fld4" optype="categorical"&gt;
      &lt;Value value="optA"/&gt;
      &lt;Value value="optB"/&gt;
      &lt;Value value="optC"/&gt;
    &lt;/DataField&gt;
    &lt;DataField dataType="string" name="fld5" optype="categorical"&gt;
      &lt;Value value="tgtX"/&gt;
      &lt;Value value="tgtY"/&gt;
      &lt;Value value="tgtZ"/&gt;
    &lt;/DataField&gt;
  &lt;/DataDictionary&gt;
  &lt;TreeModel functionName="classification" modelName="TreeTest"&gt;
    &lt;MiningSchema&gt;
      &lt;MiningField name="fld1"/&gt;
      &lt;MiningField name="fld2"/&gt;
      &lt;MiningField name="fld3"/&gt;
      &lt;MiningField name="fld4"/&gt;
      &lt;MiningField name="fld5" usageType="predicted"/&gt;
    &lt;/MiningSchema&gt;
    &lt;Node score="tgtX"&gt;
      &lt;True/&gt;
      &lt;Node score="tgtX"&gt;
        &lt;SimplePredicate field="fld4" operator="equal" value="optA"/&gt;
        &lt;Node score="tgtX"&gt;
          &lt;CompoundPredicate booleanOperator="surrogate"&gt;
            &lt;SimplePredicate field="fld1" operator="lessThan" value="30.0"/&gt;
            &lt;SimplePredicate field="fld2" operator="greaterThan" value="20.0"/&gt;
          &lt;/CompoundPredicate&gt;
          &lt;Node score="tgtX"&gt;
            &lt;SimplePredicate field="fld2" operator="lessThan" value="40.0"/&gt;
          &lt;/Node&gt;
          &lt;Node score="tgtZ"&gt;
            &lt;SimplePredicate field="fld2" operator="greaterOrEqual" value="10.0"/&gt;
          &lt;/Node&gt;
        &lt;/Node&gt;
        &lt;Node score="tgtZ"&gt;
          &lt;CompoundPredicate booleanOperator="or"&gt;
            &lt;SimplePredicate field="fld1" operator="greaterOrEqual" value="60.0"/&gt;
            &lt;SimplePredicate field="fld1" operator="lessOrEqual" value="70.0"/&gt;
          &lt;/CompoundPredicate&gt;
          &lt;Node score="tgtZ"&gt;
            &lt;SimpleSetPredicate booleanOperator="isNotIn" field="fld4"&gt;
              &lt;Array type="string"&gt;optA optB&lt;/Array&gt;
            &lt;/SimpleSetPredicate&gt;
          &lt;/Node&gt;
        &lt;/Node&gt;
      &lt;/Node&gt;
      &lt;Node score="tgtY"&gt;
        &lt;CompoundPredicate booleanOperator="or"&gt;
          &lt;SimplePredicate field="fld4" operator="equal" value="optA"/&gt;
          &lt;SimplePredicate field="fld4" operator="equal" value="optC"/&gt;
        &lt;/CompoundPredicate&gt;
        &lt;Node score="tgtY"&gt;
          &lt;CompoundPredicate booleanOperator="and"&gt;
            &lt;SimplePredicate field="fld1" operator="greaterThan" value="10.0"/&gt;
            &lt;SimplePredicate field="fld1" operator="lessThan" value="50.0"/&gt;
            &lt;SimplePredicate field="fld4" operator="equal" value="optA"/&gt;
            &lt;SimplePredicate field="fld2" operator="lessThan" value="100.0"/&gt;
            &lt;SimplePredicate field="fld3" operator="equal" value="false"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Node&gt;
        &lt;Node score="tgtZ"&gt;
          &lt;CompoundPredicate booleanOperator="and"&gt;
            &lt;SimplePredicate field="fld4" operator="equal" value="optC"/&gt;
            &lt;SimplePredicate field="fld2" operator="lessThan" value="30.0"/&gt;
          &lt;/CompoundPredicate&gt;
        &lt;/Node&gt;
      &lt;/Node&gt;
    &lt;/Node&gt;
  &lt;/TreeModel&gt;
&lt;/PMML&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example PMML Mining model (modelChain)</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;PMML version="4.2" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 http://www.dmg.org/v4-2-1/pmml-4-2.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"   xmlns="http://www.dmg.org/PMML-4_2"&gt;
  &lt;Header&gt;
    &lt;Application name="Drools-PMML" version="7.0.0-SNAPSHOT" /&gt;
  &lt;/Header&gt;
  &lt;DataDictionary numberOfFields="7"&gt;
    &lt;DataField name="age" optype="continuous" dataType="double" /&gt;
    &lt;DataField name="occupation" optype="categorical" dataType="string"&gt;
      &lt;Value value="SKYDIVER" /&gt;
      &lt;Value value="ASTRONAUT" /&gt;
      &lt;Value value="PROGRAMMER" /&gt;
      &lt;Value value="TEACHER" /&gt;
      &lt;Value value="INSTRUCTOR" /&gt;
    &lt;/DataField&gt;
    &lt;DataField name="residenceState" optype="categorical" dataType="string"&gt;
      &lt;Value value="AP" /&gt;
      &lt;Value value="KN" /&gt;
      &lt;Value value="TN" /&gt;
    &lt;/DataField&gt;
    &lt;DataField name="validLicense" optype="categorical" dataType="boolean" /&gt;
    &lt;DataField name="overallScore" optype="continuous" dataType="double" /&gt;
    &lt;DataField name="grade" optype="categorical" dataType="string"&gt;
      &lt;Value value="A" /&gt;
      &lt;Value value="B" /&gt;
      &lt;Value value="C" /&gt;
      &lt;Value value="D" /&gt;
      &lt;Value value="F" /&gt;
    &lt;/DataField&gt;
    &lt;DataField name="qualificationLevel" optype="categorical" dataType="string"&gt;
      &lt;Value value="Unqualified" /&gt;
      &lt;Value value="Barely" /&gt;
      &lt;Value value="Well" /&gt;
      &lt;Value value="Over" /&gt;
    &lt;/DataField&gt;
  &lt;/DataDictionary&gt;
  &lt;MiningModel modelName="SampleModelChainMine" functionName="classification"&gt;
    &lt;MiningSchema&gt;
      &lt;MiningField name="age" /&gt;
      &lt;MiningField name="occupation" /&gt;
      &lt;MiningField name="residenceState" /&gt;
      &lt;MiningField name="validLicense" /&gt;
      &lt;MiningField name="overallScore" /&gt;
      &lt;MiningField name="qualificationLevel" usageType="target"/&gt;
    &lt;/MiningSchema&gt;
    &lt;Segmentation multipleModelMethod="modelChain"&gt;
      &lt;Segment id="1"&gt;
        &lt;True /&gt;
        &lt;Scorecard modelName="Sample Score 1" useReasonCodes="true" isScorable="true" functionName="regression"               baselineScore="0.0" initialScore="0.345"&gt;
          &lt;MiningSchema&gt;
            &lt;MiningField name="age" usageType="active" invalidValueTreatment="asMissing" /&gt;
            &lt;MiningField name="occupation" usageType="active" invalidValueTreatment="asMissing" /&gt;
            &lt;MiningField name="residenceState" usageType="active" invalidValueTreatment="asMissing" /&gt;
            &lt;MiningField name="validLicense" usageType="active" invalidValueTreatment="asMissing" /&gt;
            &lt;MiningField name="overallScore" usageType="predicted" /&gt;
          &lt;/MiningSchema&gt;
          &lt;Output&gt;
            &lt;OutputField name="calculatedScore" displayName="Final Score" dataType="double" feature="predictedValue"                     targetField="overallScore" /&gt;
          &lt;/Output&gt;
          &lt;Characteristics&gt;
            &lt;Characteristic name="AgeScore" baselineScore="0.0" reasonCode="ABZ"&gt;
              &lt;Extension name="cellRef" value="$B$8" /&gt;
              &lt;Attribute partialScore="10.0"&gt;
                &lt;Extension name="cellRef" value="$C$10" /&gt;
                &lt;SimplePredicate field="age" operator="lessOrEqual" value="5" /&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="30.0" reasonCode="CX1"&gt;
                &lt;Extension name="cellRef" value="$C$11" /&gt;
                &lt;CompoundPredicate booleanOperator="and"&gt;
                  &lt;SimplePredicate field="age" operator="greaterOrEqual" value="5" /&gt;
                  &lt;SimplePredicate field="age" operator="lessThan" value="12" /&gt;
                &lt;/CompoundPredicate&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="40.0" reasonCode="CX2"&gt;
                &lt;Extension name="cellRef" value="$C$12" /&gt;
                &lt;CompoundPredicate booleanOperator="and"&gt;
                  &lt;SimplePredicate field="age" operator="greaterOrEqual" value="13" /&gt;
                  &lt;SimplePredicate field="age" operator="lessThan" value="44" /&gt;
                &lt;/CompoundPredicate&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="25.0"&gt;
                &lt;Extension name="cellRef" value="$C$13" /&gt;
                &lt;SimplePredicate field="age" operator="greaterOrEqual" value="45" /&gt;
              &lt;/Attribute&gt;
            &lt;/Characteristic&gt;
            &lt;Characteristic name="OccupationScore" baselineScore="0.0"&gt;
              &lt;Extension name="cellRef" value="$B$16" /&gt;
              &lt;Attribute partialScore="-10.0" reasonCode="CX2"&gt;
                &lt;Extension name="description" value="skydiving is a risky occupation" /&gt;
                &lt;Extension name="cellRef" value="$C$18" /&gt;
                &lt;SimpleSetPredicate field="occupation" booleanOperator="isIn"&gt;
                  &lt;Array n="2" type="string"&gt;SKYDIVER ASTRONAUT&lt;/Array&gt;
                &lt;/SimpleSetPredicate&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="10.0"&gt;
                &lt;Extension name="cellRef" value="$C$19" /&gt;
                &lt;SimpleSetPredicate field="occupation" booleanOperator="isIn"&gt;
                  &lt;Array n="2" type="string"&gt;TEACHER INSTRUCTOR&lt;/Array&gt;
                &lt;/SimpleSetPredicate&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="5.0"&gt;
                &lt;Extension name="cellRef" value="$C$20" /&gt;
                &lt;SimplePredicate field="occupation" operator="equal" value="PROGRAMMER" /&gt;
              &lt;/Attribute&gt;
            &lt;/Characteristic&gt;
            &lt;Characteristic name="ResidenceStateScore" baselineScore="0.0" reasonCode="RES"&gt;
              &lt;Extension name="cellRef" value="$B$22" /&gt;
              &lt;Attribute partialScore="-10.0"&gt;
                &lt;Extension name="cellRef" value="$C$24" /&gt;
                &lt;SimplePredicate field="residenceState" operator="equal" value="AP" /&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="10.0"&gt;
                &lt;Extension name="cellRef" value="$C$25" /&gt;
                &lt;SimplePredicate field="residenceState" operator="equal" value="KN" /&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="5.0"&gt;
                &lt;Extension name="cellRef" value="$C$26" /&gt;
                &lt;SimplePredicate field="residenceState" operator="equal" value="TN" /&gt;
              &lt;/Attribute&gt;
            &lt;/Characteristic&gt;
            &lt;Characteristic name="ValidLicenseScore" baselineScore="0.0"&gt;
              &lt;Extension name="cellRef" value="$B$28" /&gt;
              &lt;Attribute partialScore="1.0" reasonCode="LX00"&gt;
                &lt;Extension name="cellRef" value="$C$30" /&gt;
                &lt;SimplePredicate field="validLicense" operator="equal" value="true" /&gt;
              &lt;/Attribute&gt;
              &lt;Attribute partialScore="-1.0" reasonCode="LX00"&gt;
                &lt;Extension name="cellRef" value="$C$31" /&gt;
                &lt;SimplePredicate field="validLicense" operator="equal" value="false" /&gt;
              &lt;/Attribute&gt;
            &lt;/Characteristic&gt;
          &lt;/Characteristics&gt;
        &lt;/Scorecard&gt;
      &lt;/Segment&gt;
      &lt;Segment id="2"&gt;
        &lt;True /&gt;
        &lt;TreeModel modelName="SampleTree" functionName="classification" missingValueStrategy="lastPrediction" noTrueChildStrategy="returnLastPrediction"&gt;
          &lt;MiningSchema&gt;
            &lt;MiningField name="age" usageType="active" /&gt;
            &lt;MiningField name="validLicense" usageType="active" /&gt;
            &lt;MiningField name="calculatedScore" usageType="active" /&gt;
            &lt;MiningField name="qualificationLevel" usageType="predicted" /&gt;
          &lt;/MiningSchema&gt;
          &lt;Output&gt;
            &lt;OutputField name="qualification" displayName="Qualification Level" dataType="string" feature="predictedValue"                     targetField="qualificationLevel" /&gt;
          &lt;/Output&gt;
          &lt;Node score="Well" id="1"&gt;
            &lt;True/&gt;
            &lt;Node score="Barely" id="2"&gt;
              &lt;CompoundPredicate booleanOperator="and"&gt;
                &lt;SimplePredicate field="age" operator="greaterOrEqual" value="16" /&gt;
                &lt;SimplePredicate field="validLicense" operator="equal" value="true" /&gt;
              &lt;/CompoundPredicate&gt;
              &lt;Node score="Barely" id="3"&gt;
                &lt;SimplePredicate field="calculatedScore" operator="lessOrEqual" value="50.0" /&gt;
              &lt;/Node&gt;
              &lt;Node score="Well" id="4"&gt;
                &lt;CompoundPredicate booleanOperator="and"&gt;
                  &lt;SimplePredicate field="calculatedScore" operator="greaterThan" value="50.0" /&gt;
                  &lt;SimplePredicate field="calculatedScore" operator="lessOrEqual" value="60.0" /&gt;
                &lt;/CompoundPredicate&gt;
              &lt;/Node&gt;
              &lt;Node score="Over" id="5"&gt;
                &lt;SimplePredicate field="calculatedScore" operator="greaterThan" value="60.0" /&gt;
              &lt;/Node&gt;
            &lt;/Node&gt;
            &lt;Node score="Unqualified" id="6"&gt;
              &lt;CompoundPredicate booleanOperator="surrogate"&gt;
                &lt;SimplePredicate field="age" operator="lessThan" value="16" /&gt;
                &lt;SimplePredicate field="calculatedScore" operator="lessOrEqual" value="40.0" /&gt;
                &lt;True /&gt;
              &lt;/CompoundPredicate&gt;
            &lt;/Node&gt;
          &lt;/Node&gt;
        &lt;/TreeModel&gt;
      &lt;/Segment&gt;
    &lt;/Segmentation&gt;
  &lt;/MiningModel&gt;
&lt;/PMML&gt;</programlisting>
</para>
</formalpara>
</chapter>
<chapter xml:id="pmml-support-con_pmml-models">
<title>PMML support in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager includes consumer conformance support for the following PMML 4.2.1 model types:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/Regression.html">Regression models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/Scorecard.html">Scorecard models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/TreeModel.html">Tree models</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/v4-2-1/MultipleModels.html#xsdElement_MiningModel">Mining models</link> (with sub-types <literal>modelChain</literal>, <literal>selectAll</literal>, and <literal>selectFirst</literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>For a list of all PMML model types, including those not supported in Red Hat Decision Manager, see the DMG <link xlink:href="http://dmg.org/pmml/v4-2-1/GeneralStructure.html">PMML specification</link>.</simpara>
<simpara>Red Hat Decision Manager does not include a built-in PMML model editor, but you can use an XML or PMML-specific authoring tool to create PMML models and then integrate the PMML models in your decision services in Red Hat Decision Manager. You can import PMML files into your project in Business Central (<emphasis role="strong">Menu → Design → Projects → Import Asset</emphasis>) or package the PMML files as part of your project knowledge JAR (KJAR) file without Business Central.</simpara>
<simpara>When you add a PMML file to a project in Red Hat Decision Manager, multiple assets are generated. Each type of PMML model generates a different set of assets, but all PMML model types generate at least the following set of assets:</simpara>
<itemizedlist>
<listitem>
<simpara>A DRL file that contains all of the rules associated with your PMML model</simpara>
</listitem>
<listitem>
<simpara>At least two Java classes:</simpara>
<itemizedlist>
<listitem>
<simpara>A data class that is used as the default object type for the model type</simpara>
</listitem>
<listitem>
<simpara>A <literal>RuleUnit</literal> class that is used to manage data sources and rule execution</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>If a PMML file has <literal>MiningModel</literal> as the root model, multiple instances of each of these files are generated.</simpara>
<simpara>For more information about including assets such as PMML files with your project packaging and deployment method, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<section xml:id="pmml-naming-conventions-ref_pmml-models">
<title>PMML naming conventions in Red Hat Decision Manager</title>
<simpara>The following are naming conventions for generated PMML packages, classes, and rules:</simpara>
<itemizedlist>
<listitem>
<simpara>If no package name is given in a PMML model file, then the default package name <literal>org.kie.pmml.pmml_4_2</literal> is prefixed to the model name for the generated rules in the format <literal>"org.kie.pmml.pmml_4_2"+modelName</literal>.</simpara>
</listitem>
<listitem>
<simpara>The package name for the generated <literal>RuleUnit</literal> Java class is the same as the package name for the generated rules.</simpara>
</listitem>
<listitem>
<simpara>The name of the generated <literal>RuleUnit</literal> Java class is the model name with <literal>RuleUnit</literal> added to it in the format <literal>modelName+"RuleUnit"</literal>.</simpara>
</listitem>
<listitem>
<simpara>Each PMML model has at least one data class that is generated. The package name for these classes is <literal>org.kie.pmml.pmml_4_2.model</literal>.</simpara>
</listitem>
<listitem>
<simpara>The names of generated data classes are determined by the model type, prefixed with the model name:</simpara>
<itemizedlist>
<listitem>
<simpara>Regression models: One data class named <literal>modelName+"RegressionData"</literal></simpara>
</listitem>
<listitem>
<simpara>Scorecard models: One data class named <literal>modelName+"ScoreCardData"</literal></simpara>
</listitem>
<listitem>
<simpara>Tree models: Two data classes, the first named <literal>modelName+"TreeNode"</literal> and the second named <literal>modelName+"TreeToken"</literal></simpara>
</listitem>
<listitem>
<simpara>Mining models: One data class named <literal>modelName+"MiningModelData"</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>The mining model also generates all of the rules and classes that are within each of its segments.</simpara>
</note>
</section>
<section xml:id="pmml-extensions-ref_pmml-models">
<title>PMML extensions in Red Hat Decision Manager</title>
<simpara>The PMML specification supports <literal>Extension</literal> elements that extend the content of a PMML model. You can use extensions at almost every level of a PMML model definition, and as the first and last child in the main element of a model for maximum flexibility. For more information about PMML extensions, see the DMG PMML <link xlink:href="http://dmg.org/pmml/v4-2-1/GeneralStructure.html#xsdElement_Extension">Extension Mechanism</link>.</simpara>
<simpara>To optimize PMML integration, Red Hat Decision Manager supports the following additional PMML extensions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>modelPackage</literal>: Designates a package name for the generated rules and Java classes. Include this extension in the <literal>Header</literal> section of the PMML model file.</simpara>
</listitem>
<listitem>
<simpara><literal>adapter</literal>: Designates the type of construct (<literal>bean</literal> or <literal>trait</literal>) that is used to contain input and output data for rules. Insert this extension in the <literal>MiningSchema</literal> or <literal>Output</literal> section (or both) of the PMML model file.</simpara>
</listitem>
<listitem>
<simpara><literal>externalClass</literal>: Used in conjunction with the <literal>adapter</literal> extension in defining a <literal>MiningField</literal> or <literal>OutputField</literal>. This extension contains a class with an attribute name that matches the name of the <literal>MiningField</literal> or <literal>OutputField</literal> element.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="pmml-invocation-options-con_pmml-models">
<title>PMML model execution</title>
<simpara>You can import PMML files into your Red Hat Decision Manager project using Business Central (<emphasis role="strong">Menu → Design → Projects → Import Asset</emphasis>) or package the PMML files as part of your project knowledge JAR (KJAR) file without Business Central. After you implement your PMML files in your Red Hat Decision Manager project, you can execute the PMML-based decision service by embedding PMML calls directly in your Java application or by sending an <literal>ApplyPmmlModelCommand</literal> command to a configured KIE Server.</simpara>
<simpara>For more information about including PMML assets with your project packaging and deployment method, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>You can also include a PMML model as part of a Decision Model and Notation (DMN) service in Business Central. When you include a PMML model within a DMN file, you can invoke that PMML model as a boxed function expression for a DMN decision node or business knowledge model node. For more information about including PMML models in a DMN service, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#dmn-included-models-pmml-proc_dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link>.</simpara>
</note>
<section xml:id="pmml-invocation-embedded-proc_pmml-models">
<title>Embedding a PMML call directly in a Java application</title>
<simpara>A KIE container is local when the knowledge assets are either embedded directly into the calling program or are physically pulled in using Maven dependencies for the KJAR. You typically embed knowledge assets directly into a project if there is a tight relationship between the version of the code and the version of the PMML definition. Any changes to the decision take effect after you have intentionally updated and redeployed the application. A benefit of this approach is that proper operation does not rely on any external dependencies to the run time, which can be a limitation of locked-down environments.</simpara>
<simpara>Using Maven dependencies enables further flexibility because the specific version of the decision can dynamically change (for example, by using a system property), and it can be periodically scanned for updates and automatically updated. This introduces an external dependency on the deploy time of the service, but executes the decision locally, reducing reliance on an external service being available during run time.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A KJAR containing the PMML model to execute has been created. For more information about project packaging, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your client application, add the following dependencies to the relevant classpath of your Java project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Required for the PMML compiler --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;kie-pmml&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Required for the KIE public API --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-api&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependencies&gt;

&lt;!-- Required if not using classpath KIE container --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>The <literal>&lt;version&gt;</literal> is the Maven artifact version for Red Hat Decision Manager currently used in your project (for example, 7.48.0.Final-redhat-00002).</simpara>
<important>
<simpara>The legacy <literal>kie-pmml</literal> dependency is deprecated with Red Hat Decision Manager 7.10.0 and will be replaced by <literal>kie-pmml-trusty</literal> dependency in a future Red Hat Decision Manager release.</simpara>
</important>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between RHDM product and maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a KIE container from <literal>classpath</literal> or <literal>ReleaseId</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "my-kjar", "1.0.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );</programlisting>
<simpara>Alternative option:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

KieContainer kieContainer = kieServices.getKieClasspathContainer();</programlisting>
</listitem>
<listitem>
<simpara>Create an instance of the <literal>PMMLRequestData</literal> class, which applies your PMML model to a set of data:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class PMMLRequestData {
    private String correlationId; <co xml:id="CO4-1"/>
    private String modelName; <co xml:id="CO4-2"/>
    private String source; <co xml:id="CO4-3"/>
    private List&lt;ParameterInfo&lt;?&gt;&gt; requestParams; <co xml:id="CO4-4"/>
    ...
}</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Identifies data that is associated with a particular request or result</para>
</callout>
<callout arearefs="CO4-2">
<para>The name of the model that should be applied to the request data</para>
</callout>
<callout arearefs="CO4-3">
<para>Used by internally generated <literal>PMMLRequestData</literal> objects to identify the segment that generated the request</para>
</callout>
<callout arearefs="CO4-4">
<para>The default mechanism for sending input data points</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create an instance of the <literal>PMML4Result</literal> class, which holds the output information that is the result of applying the PMML-based rules to the input data:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class PMML4Result {
    private String correlationId;
    private String segmentationId; <co xml:id="CO5-1"/>
    private String segmentId; <co xml:id="CO5-2"/>
    private int segmentIndex; <co xml:id="CO5-3"/>
    private String resultCode; <co xml:id="CO5-4"/>
    private Map&lt;String, Object&gt; resultVariables; <co xml:id="CO5-5"/>
    ...
}</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Used when the model type is <literal>MiningModel</literal>. The <literal>segmentationId</literal> is used to differentiate between multiple segmentations.</para>
</callout>
<callout arearefs="CO5-2">
<para>Used in conjunction with the <literal>segmentationId</literal> to identify which segment generated the results.</para>
</callout>
<callout arearefs="CO5-3">
<para>Used to maintain the order of segments.</para>
</callout>
<callout arearefs="CO5-4">
<para>Used to determine whether the model was successfully applied, where <literal>OK</literal> indicates success.</para>
</callout>
<callout arearefs="CO5-5">
<para>Contains the name of a resultant variable and its associated value.</para>
</callout>
</calloutlist>
<simpara>In addition to the normal getter methods, the <literal>PMML4Result</literal> class also supports the following methods for directly retrieving the values for result variables:</simpara>
<programlisting language="java" linenumbering="unnumbered">public &lt;T&gt; Optional&lt;T&gt; getResultValue(String objName, String objField, Class&lt;T&gt; clazz, Object...params)

public Object getResultValue(String objName, String objField, Object...params)</programlisting>
</listitem>
<listitem>
<simpara>Create an instance of the <literal>ParameterInfo</literal> class, which serves as a wrapper for basic data type objects used as part of the <literal>PMMLRequestData</literal> class:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class ParameterInfo&lt;T&gt; { <co xml:id="CO6-1"/>
    private String correlationId;
    private String name; <co xml:id="CO6-2"/>
    private String capitalizedName;
    private Class&lt;T&gt; type; <co xml:id="CO6-3"/>
    private T value; <co xml:id="CO6-4"/>
    ...
}</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>The parameterized class to handle many different types</para>
</callout>
<callout arearefs="CO6-2">
<para>The name of the variable that is expected as input for the model</para>
</callout>
<callout arearefs="CO6-3">
<para>The class that is the actual type of the variable</para>
</callout>
<callout arearefs="CO6-4">
<para>The actual value of the variable</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Execute the PMML model based on the required PMML class instances that you have created:</simpara>
<programlisting language="java" linenumbering="unnumbered">public void executeModel(KieBase kbase,
                         Map&lt;String,Object&gt; variables,
                         String modelName,
                         String correlationId,
                         String modelPkgName) {
    RuleUnitExecutor executor = RuleUnitExecutor.create().bind(kbase);
    PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
    PMML4Result resultHolder = new PMML4Result(correlationId);
    variables.entrySet().forEach( es -&gt; {
        request.addRequestParam(es.getKey(), es.getValue());
    });

    DataSource&lt;PMMLRequestData&gt; requestData = executor.newDataSource("request");
    DataSource&lt;PMML4Result&gt; resultData = executor.newDataSource("results");
    DataSource&lt;PMMLData&gt; internalData = executor.newDataSource("pmmlData");

    requestData.insert(request);
    resultData.insert(resultHolder);

    List&lt;String&gt; possiblePackageNames = calculatePossiblePackageNames(modelName,
                                                                    modelPkgName);
    Class&lt;? extends RuleUnit&gt; ruleUnitClass = getStartingRuleUnit("RuleUnitIndicator",
                                                                (InternalKnowledgeBase)kbase,
                                                                possiblePackageNames);

    if (ruleUnitClass != null) {
        executor.run(ruleUnitClass);
        if ( "OK".equals(resultHolder.getResultCode()) ) {
          // extract result variables here
        }
    }
}

protected Class&lt;? extends RuleUnit&gt; getStartingRuleUnit(String startingRule, InternalKnowledgeBase ikb, List&lt;String&gt; possiblePackages) {
    RuleUnitRegistry unitRegistry = ikb.getRuleUnitRegistry();
    Map&lt;String,InternalKnowledgePackage&gt; pkgs = ikb.getPackagesMap();
    RuleImpl ruleImpl = null;
    for (String pkgName: possiblePackages) {
      if (pkgs.containsKey(pkgName)) {
          InternalKnowledgePackage pkg = pkgs.get(pkgName);
          ruleImpl = pkg.getRule(startingRule);
          if (ruleImpl != null) {
              RuleUnitDescr descr = unitRegistry.getRuleUnitFor(ruleImpl).orElse(null);
              if (descr != null) {
                  return descr.getRuleUnitClass();
              }
          }
      }
    }
    return null;
}

protected List&lt;String&gt; calculatePossiblePackageNames(String modelId, String...knownPackageNames) {
    List&lt;String&gt; packageNames = new ArrayList&lt;&gt;();
    String javaModelId = modelId.replaceAll("\\s","");
    if (knownPackageNames != null &amp;&amp; knownPackageNames.length &gt; 0) {
        for (String knownPkgName: knownPackageNames) {
            packageNames.add(knownPkgName + "." + javaModelId);
        }
    }
    String basePkgName = PMML4UnitImpl.DEFAULT_ROOT_PACKAGE+"."+javaModelId;
    packageNames.add(basePkgName);
    return packageNames;
}</programlisting>
<simpara>Rules are executed by the <literal>RuleUnitExecutor</literal> class. The <literal>RuleUnitExecutor</literal> class creates KIE sessions and adds the required <literal>DataSource</literal> objects to those sessions, and then executes the rules based on the <literal>RuleUnit</literal> that is passed as a parameter to the <literal>run()</literal> method. The <literal>calculatePossiblePackageNames</literal> and the <literal>getStartingRuleUnit</literal> methods determine the fully qualified name of the <literal>RuleUnit</literal> class that is passed to the <literal>run()</literal> method.</simpara>
</listitem>
</orderedlist>
<simpara>To facilitate your PMML model execution, you can also use a <literal>PMML4ExecutionHelper</literal> class supported in Red Hat Decision Manager. For more information about the PMML helper class, see <xref linkend="pmml-invocation-helper-classes-ref_pmml-models"/>.</simpara>
<section xml:id="pmml-invocation-helper-classes-ref_pmml-models">
<title>PMML execution helper class</title>
<simpara>Red Hat Decision Manager provides a <literal>PMML4ExecutionHelper</literal> class that helps create the <literal>PMMLRequestData</literal> class required for PMML model execution and that helps execute rules using the <literal>RuleUnitExecutor</literal> class.</simpara>
<simpara>The following are examples of a PMML model execution without and with the <literal>PMML4ExecutionHelper</literal> class, as a comparison:</simpara>
<formalpara>
<title>Example PMML model execution without using <literal>PMML4ExecutionHelper</literal></title>
<para>
<programlisting language="java" linenumbering="unnumbered">public void executeModel(KieBase kbase,
                         Map&lt;String,Object&gt; variables,
                         String modelName,
                         String correlationId,
                         String modelPkgName) {
    RuleUnitExecutor executor = RuleUnitExecutor.create().bind(kbase);
    PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
    PMML4Result resultHolder = new PMML4Result(correlationId);
    variables.entrySet().forEach( es -&gt; {
        request.addRequestParam(es.getKey(), es.getValue());
    });

    DataSource&lt;PMMLRequestData&gt; requestData = executor.newDataSource("request");
    DataSource&lt;PMML4Result&gt; resultData = executor.newDataSource("results");
    DataSource&lt;PMMLData&gt; internalData = executor.newDataSource("pmmlData");

    requestData.insert(request);
    resultData.insert(resultHolder);

    List&lt;String&gt; possiblePackageNames = calculatePossiblePackageNames(modelName,
                                                                    modelPkgName);
    Class&lt;? extends RuleUnit&gt; ruleUnitClass = getStartingRuleUnit("RuleUnitIndicator",
                                                                (InternalKnowledgeBase)kbase,
                                                                possiblePackageNames);

    if (ruleUnitClass != null) {
        executor.run(ruleUnitClass);
        if ( "OK".equals(resultHolder.getResultCode()) ) {
          // extract result variables here
        }
    }
}

protected Class&lt;? extends RuleUnit&gt; getStartingRuleUnit(String startingRule, InternalKnowledgeBase ikb, List&lt;String&gt; possiblePackages) {
    RuleUnitRegistry unitRegistry = ikb.getRuleUnitRegistry();
    Map&lt;String,InternalKnowledgePackage&gt; pkgs = ikb.getPackagesMap();
    RuleImpl ruleImpl = null;
    for (String pkgName: possiblePackages) {
      if (pkgs.containsKey(pkgName)) {
          InternalKnowledgePackage pkg = pkgs.get(pkgName);
          ruleImpl = pkg.getRule(startingRule);
          if (ruleImpl != null) {
              RuleUnitDescr descr = unitRegistry.getRuleUnitFor(ruleImpl).orElse(null);
              if (descr != null) {
                  return descr.getRuleUnitClass();
              }
          }
      }
    }
    return null;
}

protected List&lt;String&gt; calculatePossiblePackageNames(String modelId, String...knownPackageNames) {
    List&lt;String&gt; packageNames = new ArrayList&lt;&gt;();
    String javaModelId = modelId.replaceAll("\\s","");
    if (knownPackageNames != null &amp;&amp; knownPackageNames.length &gt; 0) {
        for (String knownPkgName: knownPackageNames) {
            packageNames.add(knownPkgName + "." + javaModelId);
        }
    }
    String basePkgName = PMML4UnitImpl.DEFAULT_ROOT_PACKAGE+"."+javaModelId;
    packageNames.add(basePkgName);
    return packageNames;
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example PMML model execution using <literal>PMML4ExecutionHelper</literal></title>
<para>
<programlisting language="java" linenumbering="unnumbered">public void executeModel(KieBase kbase,
                         Map&lt;String,Object&gt; variables,
                         String modelName,
                         String modelPkgName,
                         String correlationId) {
   PMML4ExecutionHelper helper = PMML4ExecutionHelperFactory.getExecutionHelper(modelName, kbase);
   helper.addPossiblePackageName(modelPkgName);

   PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
   variables.entrySet().forEach(entry -&gt; {
     request.addRequestParam(entry.getKey(), entry.getValue);
   });

   PMML4Result resultHolder = helper.submitRequest(request);
   if ("OK".equals(resultHolder.getResultCode)) {
     // extract result variables here
   }
}</programlisting>
</para>
</formalpara>
<simpara>When you use the <literal>PMML4ExecutionHelper</literal>, you do not need to specify the possible package names nor the <literal>RuleUnit</literal> class as you would in a typical PMML model execution.</simpara>
<simpara>To construct a <literal>PMML4ExecutionHelper</literal> class, you use the <literal>PMML4ExecutionHelperFactory</literal> class to determine how instances of <literal>PMML4ExecutionHelper</literal> are retrieved.</simpara>
<simpara>The following are the available <literal>PMML4ExecutionHelperFactory</literal> class methods for constructing a <literal>PMML4ExecutionHelper</literal> class:</simpara>
<variablelist>
<varlistentry>
<term>PMML4ExecutionHelperFactory methods for PMML assets in a KIE base</term>
<listitem>
<simpara>Use these methods when PMML assets have already been compiled and are being used from an existing KIE base:</simpara>
<programlisting language="java" linenumbering="unnumbered">public static PMML4ExecutionHelper getExecutionHelper(String modelName, KieBase kbase)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, KieBase kbase, boolean includeMiningDataSources)</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>PMML4ExecutionHelperFactory methods for PMML assets on the project classpath</term>
<listitem>
<simpara>Use these methods when PMML assets are on the project classpath. The <literal>classPath</literal> argument is the project classpath location of the PMML file:</simpara>
<programlisting language="java" linenumbering="unnumbered">public static PMML4ExecutionHelper getExecutionHelper(String modelName,  String classPath, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName,String classPath, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>PMML4ExecutionHelperFactory methods for PMML assets in a byte array</term>
<listitem>
<simpara>Use these methods when PMML assets are in the form of a byte array:</simpara>
<programlisting language="java" linenumbering="unnumbered">public static PMML4ExecutionHelper getExecutionHelper(String modelName, byte[] content, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, byte[] content, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>PMML4ExecutionHelperFactory methods for PMML assets in a <literal>Resource</literal></term>
<listitem>
<simpara>Use these methods when PMML assets are in the form of an <literal>org.kie.api.io.Resource</literal> object:</simpara>
<programlisting language="java" linenumbering="unnumbered">public static PMML4ExecutionHelper getExecutionHelper(String modelName, Resource resource, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, Resource resource, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)</programlisting>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>The classpath, byte array, and resource <literal>PMML4ExecutionHelperFactory</literal> methods create a KIE container for the generated rules and Java classes. The container is used as the source of the KIE base that the <literal>RuleUnitExecutor</literal> uses. The container is not persisted. The <literal>PMML4ExecutionHelperFactory</literal> method for PMML assets that are already in a KIE base does not create a KIE container in this way.</simpara>
</note>
</section>
</section>
<section xml:id="pmml-invocation-kie-server-proc_pmml-models">
<title>Executing a PMML model using KIE Server</title>
<simpara>You can execute PMML models that have been deployed to KIE Server by sending the <literal>ApplyPmmlModelCommand</literal> command to the configured KIE Server. When you use this command, a <literal>PMMLRequestData</literal> object is sent to the KIE Server and a <literal>PMML4Result</literal> result object is received as a reply. You can send PMML requests to KIE Server through the KIE Server REST API from a configured Java class or directly from a REST client.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>KIE Server is installed and configured, including a known user name and credentials for a user with the <literal>kie-server</literal> role. For installation options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>A KIE container is deployed in KIE Server in the form of a KJAR that includes the PMML model. For more information about project packaging, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have the container ID of the KIE container containing the PMML model.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your client application, add the following dependencies to the relevant classpath of your Java project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- Required for the PMML compiler --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;kie-pmml&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Required for the KIE public API --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-api&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependencies&gt;

&lt;!-- Required for the KIE Server Java client API --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Required if not using classpath KIE container --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>The <literal>&lt;version&gt;</literal> is the Maven artifact version for Red Hat Decision Manager currently used in your project (for example, 7.48.0.Final-redhat-00002).</simpara>
<important>
<simpara>The legacy <literal>kie-pmml</literal> dependency is deprecated with Red Hat Decision Manager 7.10.0 and will be replaced by <literal>kie-pmml-trusty</literal> dependency in a future Red Hat Decision Manager release.</simpara>
</important>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between RHDM product and maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a KIE container from <literal>classpath</literal> or <literal>ReleaseId</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "my-kjar", "1.0.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );</programlisting>
<simpara>Alternative option:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

KieContainer kieContainer = kieServices.getKieClasspathContainer();</programlisting>
</listitem>
<listitem>
<simpara>Create a class for sending requests to KIE Server and receiving responses:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class ApplyScorecardModel {
  private static final ReleaseId releaseId =
          new ReleaseId("org.acme","my-kjar","1.0.0");
  private static final String containerId = "SampleModelContainer";
  private static KieCommands commandFactory;
  private static ClassLoader kjarClassLoader; <co xml:id="CO7-1"/>
  private RuleServicesClient serviceClient; <co xml:id="CO7-2"/>

  // Attributes specific to your class instance
  private String rankedFirstCode;
  private Double score;

  // Initialization of non-final static attributes
  static {
    commandFactory = KieServices.Factory.get().getCommands();

    // Specifications for kjarClassLoader, if used
    KieMavenRepository kmp = KieMavenRepository.getMavenRepository();
    File artifactFile = kmp.resolveArtifact(releaseId).getFile();
    if (artifactFile != null) {
      URL urls[] = new URL[1];
      try {
        urls[0] = artifactFile.toURI().toURL();
        classLoader = new KieURLClassLoader(urls,PMML4Result.class.getClassLoader());
      } catch (MalformedURLException e) {
        logger.error("Error getting classLoader for "+containerId);
        logger.error(e.getMessage());
      }
    } else {
      logger.warn("Did not find the artifact file for "+releaseId.toString());
    }
  }

  public ApplyScorecardModel(KieServicesConfiguration kieConfig) {
    KieServicesClient clientFactory = KieServicesFactory.newKieServicesClient(kieConfig);
    serviceClient = clientFactory.getServicesClient(RuleServicesClient.class);
  }
  ...
  // Getters and setters
  ...

  // Method for executing the PMML model on KIE Server
  public void applyModel(String occupation, int age) {
    PMMLRequestData input = new PMMLRequestData("1234","SampleModelName"); <co xml:id="CO7-3"/>
    input.addRequestParam(new ParameterInfo("1234","occupation",String.class,occupation));
    input.addRequestParam(new ParameterInfo("1234","age",Integer.class,age));

    CommandFactoryServiceImpl cf = (CommandFactoryServiceImpl)commandFactory;
    ApplyPmmlModelCommand command = (ApplyPmmlModelCommand) cf.newApplyPmmlModel(request); <co xml:id="CO7-4"/>

    ServiceResponse&lt;ExecutionResults&gt; results =
        ruleClient.executeCommandsWithResults(CONTAINER_ID, command); <co xml:id="CO7-5"/>

    if (results != null) {  <co xml:id="CO7-6"/>
      PMML4Result resultHolder = (PMML4Result)results.getResult().getValue("results");
      if (resultHolder != null &amp;&amp; "OK".equals(resultHolder.getResultCode())) {
        this.score = resultHolder.getResultValue("ScoreCard","score",Double.class).get();
        Map&lt;String,Object&gt; rankingMap =
             (Map&lt;String,Object&gt;)resultHolder.getResultValue("ScoreCard","ranking");
        if (rankingMap != null &amp;&amp; !rankingMap.isEmpty()) {
          this.rankedFirstCode = rankingMap.keySet().iterator().next();
        }
      }
    }
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Defines the class loader if you did not include the KJAR in your client project dependencies</para>
</callout>
<callout arearefs="CO7-2">
<para>Identifies the service client as defined in the configuration settings, including KIE Server REST API access credentials</para>
</callout>
<callout arearefs="CO7-3">
<para>Initializes a <literal>PMMLRequestData</literal> object</para>
</callout>
<callout arearefs="CO7-4">
<para>Creates an instance of the <literal>ApplyPmmlModelCommand</literal></para>
</callout>
<callout arearefs="CO7-5">
<para>Sends the command using the service client</para>
</callout>
<callout arearefs="CO7-6">
<para>Retrieves the results of the executed PMML model</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Execute the class instance to send the PMML invocation request to KIE Server.</simpara>
<simpara>Alternatively, you can use JMS and REST interfaces to send the <literal>ApplyPmmlModelCommand</literal> command to KIE Server. For REST requests, you use the <literal>ApplyPmmlModelCommand</literal> command as a <literal>POST</literal> request to <literal>http://SERVER:PORT/kie-server/services/rest/server/containers/instances/{containerId}</literal> in JSON, JAXB, or XStream request format.</simpara>
<formalpara>
<title>Example POST endpoint</title>
<para>
<screen>http://localhost:8080/kie-server/services/rest/server/containers/instances/SampleModelContainer</screen>
</para>
</formalpara>
<formalpara>
<title>Example JSON request body</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "commands": [ {
      "apply-pmml-model-command": {
        "outIdentifier": null,
        "packageName": null,
        "hasMining": false,
        "requestData": {
          "correlationId": "123",
          "modelName": "SimpleScorecard",
          "source": null,
          "requestParams": [
            {
              "correlationId": "123",
              "name": "param1",
              "type": "java.lang.Double",
              "value": "10.0"
            },
            {
              "correlationId": "123",
              "name": "param2",
              "type": "java.lang.Double",
              "value": "15.0"
            }
          ]
        }
      }
    }
  ]
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example curl request with endpoint and body</title>
<para>
<screen>curl -X POST "http://localhost:8080/kie-server/services/rest/server/containers/instances/SampleModelContainer" -H "accept: application/json" -H "content-type: application/json" -d "{ \"commands\": [ { \"apply-pmml-model-command\": { \"outIdentifier\": null, \"packageName\": null, \"hasMining\": false, \"requestData\": { \"correlationId\": \"123\", \"modelName\": \"SimpleScorecard\", \"source\": null, \"requestParams\": [ { \"correlationId\": \"123\", \"name\": \"param1\", \"type\": \"java.lang.Double\", \"value\": \"10.0\" }, { \"correlationId\": \"123\", \"name\": \"param2\", \"type\": \"java.lang.Double\", \"value\": \"15.0\" } ] } } } ]}"</screen>
</para>
</formalpara>
<formalpara>
<title>Example JSON response</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "results" : [ {
    "value" : {"org.kie.api.pmml.DoubleFieldOutput":{
  "value" : 40.8,
  "correlationId" : "123",
  "segmentationId" : null,
  "segmentId" : null,
  "name" : "OverallScore",
  "displayValue" : "OverallScore",
  "weight" : 1.0
}},
    "key" : "OverallScore"
  }, {
    "value" : {"org.kie.api.pmml.PMML4Result":{
  "resultVariables" : {
    "OverallScore" : {
      "value" : 40.8,
      "correlationId" : "123",
      "segmentationId" : null,
      "segmentId" : null,
      "name" : "OverallScore",
      "displayValue" : "OverallScore",
      "weight" : 1.0
    },
    "ScoreCard" : {
      "modelName" : "SimpleScorecard",
      "score" : 40.8,
      "holder" : {
        "modelName" : "SimpleScorecard",
        "correlationId" : "123",
        "voverallScore" : null,
        "moverallScore" : true,
        "vparam1" : 10.0,
        "mparam1" : false,
        "vparam2" : 15.0,
        "mparam2" : false
      },
      "enableRC" : true,
      "pointsBelow" : true,
      "ranking" : {
        "reasonCh1" : 5.0,
        "reasonCh2" : -6.0
      }
    }
  },
  "correlationId" : "123",
  "segmentationId" : null,
  "segmentId" : null,
  "segmentIndex" : 0,
  "resultCode" : "OK",
  "resultObjectName" : null
}},
    "key" : "results"
  } ],
  "facts" : [ ]
}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="additional_resources_2" remap="_additional_resources_2">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="http://dmg.org/pmml/pmml-v4-2-1.html">PMML specification</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-kie-apis"><emphasis>Interacting with Red Hat Decision Manager using KIE APIs</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-drl-rules">
<title>Designing a decision service using DRL rules</title>
<partintro>
<simpara>As a business rules developer, you can define business rules using the DRL (Drools Rule Language) designer in Business Central. DRL rules are defined directly in free-form <literal>.drl</literal> text files instead of in a guided or tabular format like other types of rule assets in Business Central. These DRL files form the core of the decision service for your project.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the DRL rules have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_drl-rules">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="drl-rules-con_drl-rules">
<title>DRL (Drools Rule Language) rules</title>
<simpara>DRL (Drools Rule Language) rules are business rules that you define directly in <literal>.drl</literal> text files. These DRL files are the source in which all other rule assets in Business Central are ultimately rendered. You can create and manage DRL files within the Business Central interface, or create them externally as part of a Maven or Java project using Red Hat CodeReady Studio or another integrated development environment (IDE). A DRL file can contain one or more rules that define at a minimum the rule conditions (<literal>when</literal>) and actions (<literal>then</literal>). The DRL designer in Business Central provides syntax highlighting for Java, DRL, and XML.</simpara>
<simpara>DRL files consist of the following components:</simpara>
<formalpara>
<title>Components in a DRL file</title>
<para>
<screen>package

import

function  // Optional

query  // Optional

declare   // Optional

global   // Optional

rule "rule name"
    // Attributes
    when
        // Conditions
    then
        // Actions
end

rule "rule2 name"

...</screen>
</para>
</formalpara>
<simpara>The following example DRL rule determines the age limit in a loan application decision service:</simpara>
<formalpara>
<title>Example rule for loan application age limit</title>
<para>
<screen>rule "Underage"
  salience 15
  agenda-group "applicationGroup"
  when
    $application : LoanApplication()
    Applicant( age &lt; 21 )
  then
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end</screen>
</para>
</formalpara>
<simpara>A DRL file can contain single or multiple rules, queries, and functions, and can define resource declarations such as imports, globals, and attributes that are assigned and used by your rules and queries. The DRL package must be listed at the top of a DRL file and the rules are typically listed last. All other DRL components can follow any order.</simpara>
<simpara>Each rule must have a unique name within the rule package. If you use the same rule name more than once in any DRL file in the package, the rules fail to compile. Always enclose rule names with double quotation marks (<literal>rule "rule name"</literal>) to  prevent possible compilation errors, especially if you use spaces in rule names.</simpara>
<simpara>All data objects related to a DRL rule must be in the same project package as the DRL file in Business Central. Assets in the same package are imported by default. Existing assets in other packages can be imported with the DRL rule.</simpara>
<section xml:id="drl-packages-con_drl-rules">
<title>Packages in DRL</title>
<simpara>A package is a folder of related assets in Red Hat Decision Manager, such as data objects, DRL files, decision tables, and other asset types. A package also serves as a unique namespace for each group of rules. A single rule base can contain multiple packages. You typically store all the rules for a package in the same file as the package declaration so that the package is self-contained. However, you can import objects from other packages that you want to use in the rules.</simpara>
<simpara>The following example is a package name and namespace for a DRL file in a mortgage application decision service:</simpara>
<formalpara>
<title>Example package definition in a DRL file</title>
<para>
<screen>package org.mortgages;</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-imports-con_drl-rules">
<title>Import statements in DRL</title>
<simpara>Similar to import statements in Java, imports in DRL files identify the fully qualified paths and type names for any objects that you want to use in the rules. You specify the package and data object in the format <literal>packageName.objectName</literal>, with multiple imports on separate lines. The decision engine automatically imports classes from the Java package with the same name as the DRL package and from the package <literal>java.lang</literal>.</simpara>
<simpara>The following example is an import statement for a loan application object in a mortgage application decision service:</simpara>
<formalpara>
<title>Example import statement in a DRL file</title>
<para>
<screen>import org.mortgages.LoanApplication;</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-functions-con_drl-rules">
<title>Functions in DRL</title>
<simpara>Functions in DRL files put semantic code in your rule source file instead of in Java classes. Functions are especially useful if an action (<literal>then</literal>) part of a rule is used repeatedly and only the parameters differ for each rule. Above the rules in the DRL file, you can declare the function or import a static method from a helper class as a function, and then use the function by name in an action (<literal>then</literal>) part of the rule.</simpara>
<simpara>The following examples illustrate a function that is either declared or imported in a DRL file:</simpara>
<formalpara>
<title>Example function declaration with a rule (option 1)</title>
<para>
<screen>function String hello(String applicantName) {
    return "Hello " + applicantName + "!";
}

rule "Using a function"
  when
    // Empty
  then
    System.out.println( hello( "James" ) );
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example function import with a rule (option 2)</title>
<para>
<screen>import function my.package.applicant.hello;

rule "Using a function"
  when
    // Empty
  then
    System.out.println( hello( "James" ) );
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-queries-con_drl-rules">
<title>Queries in DRL</title>
<simpara>Queries in DRL files search the working memory of the decision engine for facts related to the rules in the DRL file. You add the query definitions in DRL files and then obtain the matching results in your application code. Queries search for a set of defined conditions and do not require <literal>when</literal> or <literal>then</literal> specifications. Query names are global to the KIE base and therefore must be unique among all other rule queries in the project. To return the results of a query, you construct a <literal>QueryResults</literal> definition using <literal>ksession.getQueryResults("name")</literal>, where <literal>"name"</literal> is the query name. This returns a list of query results, which enable you to retrieve the objects that matched the query. You define the query and query results parameters above the rules in the DRL file.</simpara>
<simpara>The following example is a query definition in a DRL file for underage applicants in a mortgage application decision service, with the accompanying application code:</simpara>
<formalpara>
<title>Example query definition in a DRL file</title>
<para>
<screen>query "people under the age of 21"
    $person : Person( age &lt; 21 )
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example application code to obtain query results</title>
<para>
<programlisting language="java" linenumbering="unnumbered">QueryResults results = ksession.getQueryResults( "people under the age of 21" );
System.out.println( "we have " + results.size() + " people under the age  of 21" );</programlisting>
</para>
</formalpara>
<simpara>You can also iterate over the returned <literal>QueryResults</literal> using a standard <literal>for</literal> loop. Each element is a <literal>QueryResultsRow</literal> that you can use to access each of the columns in the tuple.</simpara>
<formalpara>
<title>Example application code to obtain and iterate over query results</title>
<para>
<programlisting language="java" linenumbering="unnumbered">QueryResults results = ksession.getQueryResults( "people under the age of 21" );
System.out.println( "we have " + results.size() + " people under the age of 21" );

System.out.println( "These people are under the age of 21:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-con_drl-rules">
<title>Type declarations and metadata in DRL</title>
<simpara>Declarations in DRL files define new fact types or metadata for fact types to be used by rules in the DRL file:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">New fact types:</emphasis> The default fact type in the <literal>java.lang</literal> package of Red Hat Decision Manager is <literal>Object</literal>, but you can declare other types in DRL files as needed. Declaring fact types in DRL files enables you to define a new fact model directly in the decision engine, without creating models in a lower-level language like Java. You can also declare a new type when a domain model is already built and you want to complement this model with additional entities that are used mainly during the reasoning process.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Metadata for fact types:</emphasis> You can associate metadata in the format <literal>@key(value)</literal> with new or existing facts. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the decision engine and used in the reasoning process.</simpara>
</listitem>
</itemizedlist>
<section xml:id="drl-declarations-without-metadata-con_drl-rules">
<title>Type declarations without metadata in DRL</title>
<simpara>A declaration of a new fact does not require any metadata, but must include a list of attributes or fields. If a type declaration does not include identifying attributes, the decision engine searches for an existing fact class in the classpath and raises an error if the class is missing.</simpara>
<simpara>The following example is a declaration of a new fact type <literal>Person</literal> with no metadata in a DRL file:</simpara>
<formalpara>
<title>Example declaration of a new fact type with a rule</title>
<para>
<screen>declare Person
  name : String
  dateOfBirth : java.util.Date
  address : Address
end

rule "Using a declared type"
  when
    $p : Person( name == "James" )
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    insert( mark );
end</screen>
</para>
</formalpara>
<simpara>In this example, the new fact type <literal>Person</literal> has the three attributes <literal>name</literal>, <literal>dateOfBirth</literal>, and <literal>address</literal>. Each attribute has a type that can be any valid Java type, including another class that you create or a fact type that you previously declared. The <literal>dateOfBirth</literal> attribute has the type <literal>java.util.Date</literal>, from the Java API, and the <literal>address</literal> attribute has the previously defined fact type <literal>Address</literal>.</simpara>
<simpara>To avoid writing the fully qualified name of a class every time you declare it, you can define the full class name as part of the <literal>import</literal> clause:</simpara>
<formalpara>
<title>Example type declaration with the fully qualified class name in the import</title>
<para>
<screen>import java.util.Date

declare Person
    name : String
    dateOfBirth : Date
    address : Address
end</screen>
</para>
</formalpara>
<simpara>When you declare a new fact type, the decision engine generates at compile time a Java class representing the fact type. The generated Java class is a one-to-one JavaBeans mapping of the type definition.</simpara>
<simpara>For example, the following Java class is generated from the example <literal>Person</literal> type declaration:</simpara>
<formalpara>
<title>Generated Java class for the Person fact type declaration</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Person implements Serializable {
    private String name;
    private java.util.Date dateOfBirth;
    private Address address;

    // Empty constructor
    public Person() {...}

    // Constructor with all fields
    public Person( String name, Date dateOfBirth, Address address ) {...}

    // If keys are defined, constructor with keys
    public Person( ...keys... ) {...}

    // Getters and setters
    // `equals` and `hashCode`
    // `toString`
}</programlisting>
</para>
</formalpara>
<simpara>You can then use the generated class in your rules like any other fact, as illustrated in the previous rule example with the <literal>Person</literal> type declaration:</simpara>
<formalpara>
<title>Example rule that uses the declared Person fact type</title>
<para>
<screen>rule "Using a declared type"
  when
    $p : Person( name == "James" )
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    insert( mark );
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-enumerative-con_drl-rules">
<title>Enumerative type declarations in DRL</title>
<simpara>DRL supports the declaration of enumerative types in the format <literal>declare enum &lt;factType&gt;</literal>, followed by a comma-separated list of values ending with a semicolon. You can then use the enumerative list in the rules in the DRL file.</simpara>
<simpara>For example, the following enumerative type declaration defines days of the week for an employee scheduling rule:</simpara>
<formalpara>
<title>Example enumerative type declaration with a scheduling rule</title>
<para>
<screen>declare enum DaysOfWeek
   SUN("Sunday"),MON("Monday"),TUE("Tuesday"),WED("Wednesday"),THU("Thursday"),FRI("Friday"),SAT("Saturday");

   fullName : String
end

rule "Using a declared Enum"
when
   $emp : Employee( dayOff == DaysOfWeek.MONDAY )
then
   ...
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-extended-con_drl-rules">
<title>Extended type declarations in DRL</title>
<simpara>DRL supports type declaration inheritance in the format <literal>declare &lt;factType1&gt; extends &lt;factType2&gt;</literal>. To extend a type declared in Java by a subtype declared in DRL, you repeat the parent type in a declaration statement without any fields.</simpara>
<simpara>For example, the following type declarations extend a <literal>Student</literal> type from a top-level <literal>Person</literal> type, and a <literal>LongTermStudent</literal> type from the <literal>Student</literal> subtype:</simpara>
<formalpara>
<title>Example extended type declarations</title>
<para>
<screen>import org.people.Person

declare Person end

declare Student extends Person
    school : String
end

declare LongTermStudent extends Student
    years : int
    course : String
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-with-metadata-con_drl-rules">
<title>Type declarations with metadata in DRL</title>
<simpara>You can associate metadata in the format <literal>@key(value)</literal> (the value is optional) with fact types or fact attributes. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the decision engine and used in the reasoning process. Any metadata that you declare before the attributes of a fact type are assigned to the fact type, while metadata that you declare after an attribute are assigned to that particular attribute.</simpara>
<simpara>In the following example, the two metadata attributes <literal>@author</literal> and <literal>@dateOfCreation</literal> are declared for the <literal>Person</literal> fact type, and the two metadata items <literal>@key</literal> and <literal>@maxLength</literal> are declared for the <literal>name</literal> attribute. The <literal>@key</literal> metadata attribute has no required value, so the parentheses and the value are omitted.</simpara>
<formalpara>
<title>Example metadata declaration for fact types and attributes</title>
<para>
<screen>import java.util.Date

declare Person
    @author( Bob )
    @dateOfCreation( 01-Feb-2009 )

    name : String @key @maxLength( 30 )
    dateOfBirth : Date
    address : Address
end</screen>
</para>
</formalpara>
<simpara>For declarations of metadata attributes for existing types, you can identify the fully qualified class name as part of the <literal>import</literal> clause for all declarations or as part of the individual <literal>declare</literal> clause:</simpara>
<formalpara>
<title>Example metadata declaration for an imported type</title>
<para>
<screen>import org.drools.examples.Person

declare Person
    @author( Bob )
    @dateOfCreation( 01-Feb-2009 )
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example metadata declaration for a declared type</title>
<para>
<screen>declare org.drools.examples.Person
    @author( Bob )
    @dateOfCreation( 01-Feb-2009 )
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-metadata-tags-ref_drl-rules">
<title>Metadata tags for fact type and attribute declarations in DRL</title>
<simpara>Although you can define custom metadata attributes in DRL declarations, the decision engine also supports the following predefined metadata tags for declarations of fact types or fact type attributes.</simpara>
<note>
<simpara>The examples in this section that refer to the <literal>VoiceCall</literal> class assume that the sample application domain model includes the following class details:</simpara>
<formalpara>
<title>VoiceCall fact class in an example Telecom domain model</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class VoiceCall {
  private String  originNumber;
  private String  destinationNumber;
  private Date    callDateTime;
  private long    callDuration;  // in milliseconds

  // Constructors, getters, and setters
}</programlisting>
</para>
</formalpara>
</note>
<variablelist>
<varlistentry>
<term>@role</term>
<listitem>
<simpara>This tag determines whether a given fact type is handled as a regular fact or an event in the decision engine during complex event processing.</simpara>
<simpara>Default parameter: <literal>fact</literal></simpara>
<simpara>Supported parameters: <literal>fact</literal>, <literal>event</literal></simpara>
<screen>@role( fact | event )</screen>
<formalpara>
<title>Example: Declare VoiceCall as event type</title>
<para>
<screen>declare VoiceCall
  @role( event )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@timestamp</term>
<listitem>
<simpara>This tag is automatically assigned to every event in the decision engine. By default, the time is provided by the session clock and assigned to the event when it is inserted into the working memory of the decision engine. You can specify a custom time stamp attribute instead of the default time stamp added by the session clock.</simpara>
<simpara>Default parameter: The time added by the decision engine session clock</simpara>
<simpara>Supported parameters: Session clock time or custom time stamp attribute</simpara>
<screen>@timestamp( &lt;attributeName&gt; )</screen>
<formalpara>
<title>Example: Declare VoiceCall timestamp attribute</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@duration</term>
<listitem>
<simpara>This tag determines the duration time for events in the decision engine. Events can be interval-based events or point-in-time events. Interval-based events have a duration time and persist in the working memory of the decision engine until their duration time has lapsed. Point-in-time events have no duration and are essentially interval-based events with a duration of zero. By default, every event in the decision engine has a duration of zero. You can specify a custom duration attribute instead of the default.</simpara>
<simpara>Default parameter: Null (zero)</simpara>
<simpara>Supported parameters: Custom duration attribute</simpara>
<screen>@duration( &lt;attributeName&gt; )</screen>
<formalpara>
<title>Example: Declare VoiceCall duration attribute</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
  @duration( callDuration )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@expires</term>
<listitem>
<simpara>This tag determines the time duration before an event expires in the working memory of the decision engine. By default, an event expires when the event can no longer match and activate any of the current rules. You can define an amount of time after which an event should expire. This tag definition also overrides the implicit expiration offset calculated from temporal constraints and sliding windows in the KIE base. This tag is available only when the decision engine is running in stream mode.</simpara>
<simpara>Default parameter: Null (event expires after event can no longer match and activate rules)</simpara>
<simpara>Supported parameters: Custom <literal>timeOffset</literal> attribute in the format <literal>[<emphasis role="marked">#d][#h][#m][#s][</emphasis>[ms]]</literal></simpara>
<screen>@expires( &lt;timeOffset&gt; )</screen>
<formalpara>
<title>Example: Declare expiration offset for VoiceCall events</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
  @duration( callDuration )
  @expires( 1h35m )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@typesafe</term>
<listitem>
<simpara>This tab determines whether a given fact type is compiled with or without type safety. By default, all type declarations are compiled with type safety enabled. You can override this behavior to type-unsafe evaluation, where all constraints are generated as MVEL constraints and executed dynamically. This is useful when dealing with collections that do not have any generics or mixed type collections.</simpara>
<simpara>Default parameter: <literal>true</literal></simpara>
<simpara>Supported parameters: <literal>true</literal>, <literal>false</literal></simpara>
<screen>@typesafe( &lt;boolean&gt; )</screen>
<formalpara>
<title>Example: Declare VoiceCall for type-unsafe evaluation</title>
<para>
<screen>declare VoiceCall
  @role( fact )
  @typesafe( false )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@serialVersionUID</term>
<listitem>
<simpara>This tag defines an identifying <literal>serialVersionUID</literal> value for a serializable class in a fact declaration. If a serializable class does not explicitly declare a <literal>serialVersionUID</literal>, the serialization run time calculates a default <literal>serialVersionUID</literal> value for that class based on various aspects of the class, as described in the <link xlink:href="https://docs.oracle.com/javase/10/docs/specs/serialization/index.html">Java Object Serialization Specification</link>. However, for optimal deserialization results and for greater compatibility with serialized KIE sessions, set the <literal>serialVersionUID</literal> as needed in the relevant class or in your DRL declarations.</simpara>
<simpara>Default parameter: Null</simpara>
<simpara>Supported parameters: Custom <literal>serialVersionUID</literal> integer</simpara>
<screen>@serialVersionUID( &lt;integer&gt; )</screen>
<formalpara>
<title>Example: Declare serialVersionUID for a VoiceCall class</title>
<para>
<screen>declare VoiceCall
  @serialVersionUID( 42 )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@key</term>
<listitem>
<simpara>This tag enables a fact type attribute to be used as a key identifier for the fact type. The generated class can then implement the <literal>equals()</literal> and <literal>hashCode()</literal> methods to determine if two instances of the type are equal to each other. The decision engine can also generate a constructor using all the key attributes as parameters.</simpara>
<simpara>Default parameter: None</simpara>
<simpara>Supported parameters: None</simpara>
<screen>&lt;attributeDefinition&gt; @key</screen>
<formalpara>
<title>Example: Declare Person type attributes as keys</title>
<para>
<screen>declare Person
    firstName : String @key
    lastName : String @key
    age : int
end</screen>
</para>
</formalpara>
<simpara>For this example, the decision engine checks the <literal>firstName</literal> and <literal>lastName</literal> attributes to determine if two instances of <literal>Person</literal> are equal to each other, but it does not check the <literal>age</literal> attribute. The decision engine also implicitly generates three constructors: one without parameters, one with the <literal>@key</literal> fields, and one with all fields:</simpara>
<formalpara>
<title>Example constructors from the key declarations</title>
<para>
<screen>Person() // Empty constructor

Person( String firstName, String lastName )

Person( String firstName, String lastName, int age )</screen>
</para>
</formalpara>
<simpara>You can then create instances of the type based on the key constructors, as shown in the following example:</simpara>
<formalpara>
<title>Example instance using the key constructor</title>
<para>
<programlisting language="java" linenumbering="unnumbered">Person person = new Person( "John", "Doe" );</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@position</term>
<listitem>
<simpara>This tag determines the position of a declared fact type attribute or field in a positional argument, overriding the default declared order of attributes. You can use this tag to modify positional constraints in patterns while maintaining a consistent format in your type declarations and positional arguments. You can use this tag only for fields in classes on the classpath. If some fields in a single class use this tag and some do not, the attributes without this tag are positioned last, in the declared order. Inheritance of classes is supported, but not interfaces of methods.</simpara>
<simpara>Default parameter: None</simpara>
<simpara>Supported parameters: Any integer</simpara>
<screen>&lt;attributeDefinition&gt; @position ( &lt;integer&gt; )</screen>
<formalpara>
<title>Example: Declare a fact type and override declared order</title>
<para>
<screen>declare Person
    firstName : String @position( 1 )
    lastName : String @position( 0 )
    age : int @position( 2 )
    occupation: String
end</screen>
</para>
</formalpara>
<simpara>In this example, the attributes are prioritized in positional arguments in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>lastName</literal></simpara>
</listitem>
<listitem>
<simpara><literal>firstName</literal></simpara>
</listitem>
<listitem>
<simpara><literal>age</literal></simpara>
</listitem>
<listitem>
<simpara><literal>occupation</literal></simpara>
</listitem>
</orderedlist>
<simpara>In positional arguments, you do not need to specify the field name because the position maps to a known named field. For example, the argument <literal>Person( lastName == "Doe" )</literal> is the same as <literal>Person( "Doe"; )</literal>, where the <literal>lastName</literal> field has the highest position annotation in the DRL declaration. The semicolon <literal>;</literal> indicates that everything before it is a positional argument. You can mix positional and named arguments on a pattern by using the semicolon to separate them. Any variables in a positional argument that have not yet been bound are bound to the field that maps to that position.</simpara>
<simpara>The following example patterns illustrate different ways of constructing positional and named arguments. The patterns have two constraints and a binding, and the semicolon differentiates the positional section from the named argument section. Variables and literals and expressions using only literals are supported in positional arguments, but not variables alone.</simpara>
<formalpara>
<title>Example patterns with positional and named arguments</title>
<para>
<screen>Person( "Doe", "John", $a; )

Person( "Doe", "John"; $a : age )

Person( "Doe"; firstName == "John", $a : age )

Person( lastName == "Doe"; firstName == "John", $a : age )</screen>
</para>
</formalpara>
<simpara>Positional arguments can be classified as <emphasis>input arguments</emphasis> or <emphasis>output arguments</emphasis>. Input arguments contain a previously declared binding and constrain against that binding using unification. Output arguments generate the declaration and bind it to the field represented by the positional argument when the binding does not yet exist.</simpara>
<simpara>In extended type declarations, use caution when defining <literal>@position</literal> annotations because the attribute positions are inherited in subtypes. This inheritance can result in a mixed attribute order that can be confusing in some cases. Two fields can have the same <literal>@position</literal> value and consecutive values do not need to be declared. If a position is repeated, the conflict is solved using inheritance, where position values in the parent type have precedence, and then using the declaration order from the first to last declaration.</simpara>
<simpara>For example, the following extended type declarations result in mixed positional priorities:</simpara>
<formalpara>
<title>Example extended fact type with mixed position annotations</title>
<para>
<screen>declare Person
    firstName : String @position( 1 )
    lastName : String @position( 0 )
    age : int @position( 2 )
    occupation: String
end

declare Student extends Person
    degree : String @position( 1 )
    school : String @position( 0 )
    graduationDate : Date
end</screen>
</para>
</formalpara>
<simpara>In this example, the attributes are prioritized in positional arguments in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>lastName</literal> (position 0 in the parent type)</simpara>
</listitem>
<listitem>
<simpara><literal>school</literal> (position 0 in the subtype)</simpara>
</listitem>
<listitem>
<simpara><literal>firstName</literal> (position 1 in the parent type)</simpara>
</listitem>
<listitem>
<simpara><literal>degree</literal> (position 1 in the subtype)</simpara>
</listitem>
<listitem>
<simpara><literal>age</literal> (position 2 in the parent type)</simpara>
</listitem>
<listitem>
<simpara><literal>occupation</literal> (first field with no position annotation)</simpara>
</listitem>
<listitem>
<simpara><literal>graduationDate</literal> (second field with no position annotation)</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="property-change-listeners-con_drl-rules">
<title>Property-change settings and listeners for fact types</title>
<simpara>By default, the decision engine does not re-evaluate all fact patterns for fact types each time a rule is triggered, but instead reacts only to modified properties that are constrained or bound inside a given pattern. For example, if a rule calls <literal>modify()</literal> as part of the rule actions but the action does not generate new data in the KIE base, the decision engine does not automatically re-evaluate all fact patterns because no data was modified. This property reactivity behavior prevents unwanted recursions in the KIE base and results in more efficient rule evaluation. This behavior also means that you do not always need to use the <literal>no-loop</literal> rule attribute to avoid infinite recursion.</simpara>
<simpara>You can modify or disable this property reactivity behavior with the following <literal>KnowledgeBuilderConfiguration</literal> options, and then use a property-change setting in your Java class or DRL files to fine-tune property reactivity as needed:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ALWAYS</literal>: (Default) All types are property reactive, but you can disable property reactivity for a specific type by using the <literal>@classReactive</literal> property-change setting.</simpara>
</listitem>
<listitem>
<simpara><literal>ALLOWED</literal>: No types are property reactive, but you can enable property reactivity for a specific type by using the <literal>@propertyReactive</literal> property-change setting.</simpara>
</listitem>
<listitem>
<simpara><literal>DISABLED</literal>: No types are property reactive. All property-change listeners are ignored.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example property reactivity setting in KnowledgeBuilderConfiguration</title>
<para>
<screen>KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
config.setOption(PropertySpecificOption.ALLOWED);
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);</screen>
</para>
</formalpara>
<simpara>Alternatively, you can update the <literal>drools.propertySpecific</literal> system property in the <literal>standalone.xml</literal> file of your Red Hat Decision Manager distribution:</simpara>
<formalpara>
<title>Example property reactivity setting in system properties</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;system-properties&gt;
  ...
  &lt;property name="drools.propertySpecific" value="ALLOWED"/&gt;
  ...
&lt;/system-properties&gt;</programlisting>
</para>
</formalpara>
<simpara>The decision engine supports the following property-change settings and listeners for fact classes or declared DRL fact types:</simpara>
<variablelist>
<varlistentry>
<term>@classReactive</term>
<listitem>
<simpara>If property reactivity is set to <literal>ALWAYS</literal> in the decision engine (all types are property reactive), this tag disables the default property reactivity behavior for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to re-evaluate all fact patterns for the specified fact type each time the rule is triggered, instead of reacting only to modified properties that are constrained or bound inside a given pattern.</simpara>
<formalpara>
<title>Example: Disable default property reactivity in a DRL type declaration</title>
<para>
<screen>declare Person
  @classReactive
    firstName : String
    lastName : String
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example: Disable default property reactivity in a Java class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@classReactive
public static class Person {
    private String firstName;
    private String lastName;
}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@propertyReactive</term>
<listitem>
<simpara>If property reactivity is set to <literal>ALLOWED</literal> in the decision engine (no types are property reactive unless specified), this tag enables property reactivity for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to react only to modified properties that are constrained or bound inside a given pattern for the specified fact type, instead of re-evaluating all fact patterns for the fact each time the rule is triggered.</simpara>
<formalpara>
<title>Example: Enable property reactivity in a DRL type declaration (when reactivity is disabled globally)</title>
<para>
<screen>declare Person
  @propertyReactive
    firstName : String
    lastName : String
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example: Enable property reactivity in a Java class (when reactivity is disabled globally)</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@propertyReactive
public static class Person {
    private String firstName;
    private String lastName;
}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@watch</term>
<listitem>
<simpara>This tag enables property reactivity for additional properties that you specify in-line in fact patterns in DRL rules. This tag is supported only if property reactivity is set to <literal>ALWAYS</literal> in the decision engine, or if property reactivity is set to <literal>ALLOWED</literal> and the relevant fact type uses the <literal>@propertyReactive</literal> tag. You can use this tag in DRL rules to add or exclude specific properties in fact property reactivity logic.</simpara>
<simpara>Default parameter: None</simpara>
<simpara>Supported parameters: Property name, <literal>*</literal> (all), <literal>!</literal> (not), <literal>!*</literal> (no properties)</simpara>
<screen>&lt;factPattern&gt; @watch ( &lt;property&gt; )</screen>
<formalpara>
<title>Example: Enable or disable property reactivity in fact patterns</title>
<para>
<screen>// Listens for changes in both `firstName` (inferred) and `lastName`:
Person(firstName == $expectedFirstName) @watch( lastName )

// Listens for changes in all properties of the `Person` fact:
Person(firstName == $expectedFirstName) @watch( * )

// Listens for changes in `lastName` and explicitly excludes changes in `firstName`:
Person(firstName == $expectedFirstName) @watch( lastName, !firstName )

// Listens for changes in all properties of the `Person` fact except `age`:
Person(firstName == $expectedFirstName) @watch( *, !age )

// Excludes changes in all properties of the `Person` fact (equivalent to using `@classReactivity` tag):
Person(firstName == $expectedFirstName) @watch( !* )</screen>
</para>
</formalpara>
<simpara>The decision engine generates a compilation error if you use the <literal>@watch</literal> tag for properties in a fact type that uses the <literal>@classReactive</literal> tag (disables property reactivity) or when property reactivity is set to <literal>ALLOWED</literal> in the decision engine and the relevant fact type does not use the <literal>@propertyReactive</literal> tag. Compilation errors also arise if you duplicate properties in listener annotations, such as <literal>@watch( firstName, ! firstName )</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@propertyChangeSupport</term>
<listitem>
<simpara>For facts that implement support for property changes as defined in the <link xlink:href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans Specification</link>, this tag enables the decision engine to monitor changes in the fact properties.</simpara>
<formalpara>
<title>Example: Declare property change support in JavaBeans object</title>
<para>
<screen>declare Person
    @propertyChangeSupport
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="drl-declarations-access-con_drl-rules">
<title>Access to DRL declared types in application code</title>
<simpara>Declared types in DRL are typically used within the DRL files while Java models are typically used when the model is shared between rules and applications. Because declared types are generated at KIE base compile time, an application cannot access them until application run time. In some cases, an application needs to access and handle facts directly from the declared types, especially when the application wraps the decision engine and provides higher-level, domain-specific user interfaces for rules management.</simpara>
<simpara>To handle declared types directly from the application code, you can use the <literal>org.drools.definition.type.FactType</literal> API in Red Hat Decision Manager. Through this API, you can instantiate, read, and write fields in the declared fact types.</simpara>
<simpara>The following example code modifies a <literal>Person</literal> fact type directly from an application:</simpara>
<formalpara>
<title>Example application code to handle a declared fact type through the FactType API</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import java.util.Date;

import org.kie.api.definition.type.FactType;
import org.kie.api.KieBase;
import org.kie.api.runtime.KieSession;

...

// Get a reference to a KIE base with the declared type:
KieBase kbase = ...

// Get the declared fact type:
FactType personType = kbase.getFactType("org.drools.examples", "Person");

// Create instances:
Object bob = personType.newInstance();

// Set attribute values:
personType.set(bob, "name", "Bob" );
personType.set(bob, "dateOfBirth", new Date());
personType.set(bob, "address", new Address("King's Road","London","404"));

// Insert the fact into a KIE session:
KieSession ksession = ...
ksession.insert(bob);
ksession.fireAllRules();

// Read attributes:
String name = (String) personType.get(bob, "name");
Date date = (Date) personType.get(bob, "dateOfBirth");</programlisting>
</para>
</formalpara>
<simpara>The API also includes other helpful methods, such as setting all the attributes at once, reading values from a <literal>Map</literal> collection, or reading all attributes at once into a <literal>Map</literal> collection.</simpara>
<simpara>Although the API behavior is similar to Java reflection, the API does not use reflection and relies on more performant accessors that are implemented with generated bytecode.</simpara>
</section>
</section>
<section xml:id="drl-globals-con_drl-rules">
<title>Global variables in DRL</title>
<simpara>Global variables in DRL files typically provide data or services for the rules, such as application services used in rule consequences, and return data from rules, such as logs or values added in rule consequences. You set the global value in the working memory of the decision engine through a KIE session configuration or REST operation, declare the global variable above the rules in the DRL file, and then use it in an action (<literal>then</literal>) part of the rule. For multiple global variables, use separate lines in the DRL file.</simpara>
<simpara>The following example illustrates a global variable list configuration for the decision engine and the corresponding global variable definition in the DRL file:</simpara>
<formalpara>
<title>Example global list configuration for the decision engine</title>
<para>
<screen>List&lt;String&gt; list = new ArrayList&lt;&gt;();
KieSession kieSession = kiebase.newKieSession();
kieSession.setGlobal( "myGlobalList", list );</screen>
</para>
</formalpara>
<formalpara>
<title>Example global variable definition with a rule</title>
<para>
<screen>global java.util.List myGlobalList;

rule "Using a global"
  when
    // Empty
  then
    myGlobalList.add( "My global list" );
end</screen>
</para>
</formalpara>
<warning>
<simpara>Do not use global variables to establish conditions in rules unless a global variable has a constant immutable value. Global variables are not inserted into the working memory of the decision engine, so the decision engine cannot track value changes of variables.</simpara>
<simpara>Do not use global variables to share data between rules. Rules always reason and react to the working memory state, so if you want to pass data from rule to rule, assert the data as facts into the working memory of the decision engine.</simpara>
</warning>
<simpara>A use case for a global variable might be an instance of an email service. In your integration code that is calling the decision engine, you obtain your <literal>emailService</literal> object and then set it in the working memory of the decision engine. In the DRL file, you declare that you have a global of type <literal>emailService</literal> and give it the name <literal>"email"</literal>, and then in your rule consequences, you can use actions such as <literal>email.sendSMS(number, message)</literal>.</simpara>
<simpara>If you declare global variables with the same identifier in multiple packages, then you must set all the packages with the same type so that they all reference the same global value.</simpara>
</section>
<section xml:id="rules-attributes-ref_drl-rules">
<title>Rule attributes in DRL</title>
<simpara>Rule attributes are additional specifications that you can add to business rules to modify rule behavior.
In DRL files, you typically define rule attributes above the rule conditions and actions, with multiple attributes on separate lines, in the following format:</simpara>
<screen>rule "rule_name"
    // Attribute
    // Attribute
    when
        // Conditions
    then
        // Actions
end</screen>
<simpara>The following table lists the names and supported values of the attributes that you can assign to rules:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Rule attributes</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Attribute</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>salience</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An integer defining the priority of the rule. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara><simpara>Example: <literal>salience 10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule is enabled. When the option is not selected, the rule is disabled.</simpara><simpara>Example: <literal>enabled true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-effective</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule can be activated only if the current date and time is after a <literal>date-effective</literal> attribute.</simpara><simpara>Example: <literal>date-effective "4-Sep-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-expires</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule cannot be activated if the current date and time is after the <literal>date-expires</literal> attribute.</simpara><simpara>Example: <literal>date-expires "4-Oct-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>no-loop</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition. When the condition is not selected, the rule can be looped in these circumstances.</simpara><simpara>Example: <literal>no-loop true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>agenda-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated.</simpara><simpara>Example: <literal>agenda-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>activation-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an activation (or XOR) group to which you want to assign the rule. In activation groups, only one rule can be activated. The first rule to fire will cancel all pending activations of all rules in the activation group.</simpara><simpara>Example: <literal>activation-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>duration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met.</simpara><simpara>Example: <literal>duration 10000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>timer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>int</literal> (interval) or <literal>cron</literal> timer definitions for scheduling the rule.</simpara><simpara>Example: <literal>timer ( cron:* 0/15 * * * ? )</literal>  (every 15 minutes)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>calendar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A <link xlink:href="http://www.quartz-scheduler.org/">Quartz</link> calendar definition for scheduling the rule.</simpara><simpara>Example: <literal>calendars "* * 0-7,18-23 ? * *"</literal>  (exclude non-business hours)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>auto-focus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within agenda groups. When the option is selected, the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned.</simpara><simpara>Example: <literal>auto-focus true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>lock-on-active</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within rule flow groups or agenda groups. When the option is selected, the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the <literal>no-loop</literal> attribute, because the activation of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again.</simpara><simpara>Example: <literal>lock-on-active true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ruleflow-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow.</simpara><simpara>Example: <literal>ruleflow-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dialect</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>JAVA</literal> or <literal>MVEL</literal> as the language to be used for code expressions in the rule. By default, the rule uses the dialect specified at the package level. Any dialect specified here overrides the package dialect setting for the rule.</simpara>
<simpara>Example: <literal>dialect "JAVA"</literal></simpara>
<note>
<simpara>When you use Red Hat Decision Manager without the executable model, the <literal>dialect "JAVA"</literal> rule consequences support only Java 5 syntax. For more information about executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="drl-timers-calendars-con_drl-rules">
<title>Timer and calendar rule attributes in DRL</title>
<simpara>Timers and calendars are DRL rule attributes that enable you to apply scheduling and timing constraints to your DRL rules. These attributes require additional configurations depending on the use case.</simpara>
<simpara>The <literal>timer</literal> attribute in DRL rules is a string identifying either <literal>int</literal> (interval) or <literal>cron</literal> timer definitions for scheduling a rule and supports the following formats:</simpara>
<formalpara>
<title>Timer attribute formats</title>
<para>
<screen>timer ( int: &lt;initial delay&gt; &lt;repeat interval&gt; )

timer ( cron: &lt;cron expression&gt; )</screen>
</para>
</formalpara>
<formalpara>
<title>Example interval timer attributes</title>
<para>
<screen>// Run after a 30-second delay
timer ( int: 30s )

// Run every 5 minutes after a 30-second delay each time
timer ( int: 30s 5m )</screen>
</para>
</formalpara>
<formalpara>
<title>Example cron timer attribute</title>
<para>
<screen>// Run every 15 minutes
timer ( cron:* 0/15 * * * ? )</screen>
</para>
</formalpara>
<simpara>Interval timers follow the semantics of <literal>java.util.Timer</literal> objects, with an initial delay and an optional repeat interval. Cron timers follow standard Unix cron expressions.</simpara>
<simpara>The following example DRL rule uses a cron timer to send an SMS text message every 15 minutes:</simpara>
<formalpara>
<title>Example DRL rule with a cron timer</title>
<para>
<screen>rule "Send SMS message every 15 minutes"
  timer ( cron:* 0/15 * * * ? )
  when
    $a : Alarm( on == true )
  then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on." );
end</screen>
</para>
</formalpara>
<simpara>Generally, a rule that is controlled by a timer becomes active when the rule is triggered and the rule consequence is executed repeatedly, according to the timer settings. The execution stops when the rule condition no longer matches incoming facts. However, the way the decision engine handles rules with timers depends on whether the decision engine is in <emphasis>active mode</emphasis> or in <emphasis>passive mode</emphasis>.</simpara>
<simpara>By default, the decision engine runs in <emphasis>passive mode</emphasis> and evaluates rules, according to the defined timer settings, when a user or an application explicitly calls <literal>fireAllRules()</literal>. Conversely, if a user or application calls <literal>fireUntilHalt()</literal>, the decision engine starts in <emphasis>active mode</emphasis> and evaluates rules continually until the user or application explicitly calls <literal>halt()</literal>.</simpara>
<simpara>When the decision engine is in active mode, rule consequences are executed even after control returns from a call to <literal>fireUntilHalt()</literal> and the decision engine remains <emphasis>reactive</emphasis> to any changes made to the working memory. For example, removing a fact that was involved in triggering the timer rule execution causes the repeated execution to terminate, and inserting a fact so that some rule matches causes that rule to be executed. However, the decision engine is not continually <emphasis>active</emphasis>, but is active only after a rule is executed. Therefore, the decision engine does not react to asynchronous fact insertions until the next execution of a timer-controlled rule. Disposing a KIE session terminates all timer activity.</simpara>
<simpara>When the decision engine is in passive mode, rule consequences of timed rules are evaluated only when <literal>fireAllRules()</literal> is invoked again. However, you can change the default timer-execution behavior in passive mode by configuring the KIE session with a <literal>TimedRuleExecutionOption</literal> option, as shown in the following example:</simpara>
<formalpara>
<title>KIE session configuration to automatically execute timed rules in passive mode</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExecutionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, null);</programlisting>
</para>
</formalpara>
<simpara>You can additionally set a <literal>FILTERED</literal> specification on the <literal>TimedRuleExecutionOption</literal> option that enables you to define a
callback to filter those rules, as shown in the following example:</simpara>
<formalpara>
<title>KIE session configuration to filter which timed rules are automatically executed</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( new TimedRuleExecutionOption.FILTERED(new TimedRuleExecutionFilter() {
    public boolean accept(Rule[] rules) {
        return rules[0].getName().equals("MyRule");
    }
}) );</programlisting>
</para>
</formalpara>
<simpara>For interval timers, you can also use an expression timer with <literal>expr</literal> instead of <literal>int</literal> to define both the delay and interval as an expression instead of a fixed value.</simpara>
<simpara>The following example DRL file declares a fact type with a delay and period that are then used in the subsequent rule with an expression timer:</simpara>
<formalpara>
<title>Example rule with an expression timer</title>
<para>
<screen>declare Bean
  delay   : String = "30s"
  period  : long = 60000
end

rule "Expression timer"
  timer ( expr: $d, $p )
  when
    Bean( $d : delay, $p : period )
  then
    // Actions
end</screen>
</para>
</formalpara>
<simpara>The expressions, such as <literal>$d</literal> and <literal>$p</literal> in this example, can use any variable defined in the pattern-matching part of the rule. The variable can be any <literal>String</literal> value that can be parsed into a time duration or any numeric value that is internally converted in a <literal>long</literal> value for a duration in milliseconds.</simpara>
<simpara>Both interval and expression timers can use the following optional parameters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>start</literal> and <literal>end</literal>: A <literal>Date</literal> or a <literal>String</literal> representing a <literal>Date</literal> or a <literal>long</literal> value. The value can also be a <literal>Number</literal> that is transformed into a Java <literal>Date</literal> in the format <literal>new Date( ((Number) n).longValue() )</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>repeat-limit</literal>: An integer that defines the maximum number of repetitions allowed by the timer. If both the <literal>end</literal> and the <literal>repeat-limit</literal> parameters are set, the timer stops when the first of the two is reached.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example timer attribute with optional <literal>start</literal>, <literal>end</literal>, and <literal>repeat-limit</literal> parameters</title>
<para>
<programlisting language="java" linenumbering="unnumbered">timer (int: 30s 1h; start=3-JAN-2020, end=4-JAN-2020, repeat-limit=50)</programlisting>
</para>
</formalpara>
<simpara>In this example, the rule is scheduled for every hour, after a delay of 30 seconds each hour, beginning on 3 January 2020 and ending either on 4 January 2020 or when the cycle repeats 50 times.</simpara>
<simpara>If the system is paused (for example, the session is serialized and then later deserialized), the rule is scheduled only one time to recover from missing activations regardless of how many activations were missed during the pause, and then the rule is subsequently scheduled again to continue in sync with the timer setting.</simpara>
<simpara>The <literal>calendar</literal> attribute in DRL rules is a <link xlink:href="http://www.quartz-scheduler.org/">Quartz</link> calendar definition for scheduling a rule and supports the following format:</simpara>
<formalpara>
<title>Calendar attribute format</title>
<para>
<screen>calendars "&lt;definition or registered name&gt;"</screen>
</para>
</formalpara>
<formalpara>
<title>Example calendar attributes</title>
<para>
<screen>// Exclude non-business hours
calendars "* * 0-7,18-23 ? * *"

// Weekdays only, as registered in the KIE session
calendars "weekday"</screen>
</para>
</formalpara>
<simpara>You can adapt a Quartz calendar based on the Quartz calendar API and then register the calendar in the KIE session, as shown in the following example:</simpara>
<formalpara>
<title>Adapting a Quartz Calendar</title>
<para>
<programlisting language="java" linenumbering="unnumbered">Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Registering the calendar in the KIE session</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.getCalendars().set( "weekday", weekDayCal );</programlisting>
</para>
</formalpara>
<simpara>You can use calendars with standard rules and with rules that use timers. The calendar attribute can contain one or more comma-separated calendar names written as <literal>String</literal> literals.</simpara>
<simpara>The following example rules use both calendars and timers to schedule the rules:</simpara>
<formalpara>
<title>Example rules with calendars and timers</title>
<para>
<screen>rule "Weekdays are high priority"
  calendars "weekday"
  timer ( int:0 1h )
  when
    Alarm()
  then
    send( "priority high - we have an alarm" );
end

rule "Weekends are low priority"
  calendars "weekend"
  timer ( int:0 4h )
  when
    Alarm()
  then
    send( "priority low - we have an alarm" );
end</screen>
</para>
</formalpara>
</section>
</section>
<section xml:id="drl-rules-WHEN-con_drl-rules">
<title>Rule conditions in DRL (WHEN)</title>
<simpara>The <literal>when</literal> part of a DRL rule (also known as the <emphasis>Left Hand Side (LHS)</emphasis> of the rule) contains the conditions that must be met to execute an action. Conditions consist of a series of stated <emphasis>patterns</emphasis> and <emphasis>constraints</emphasis>, with optional <emphasis>bindings</emphasis> and supported rule condition elements (keywords), based on the available data objects in the package. For example, if a bank requires loan applicants to have over 21 years of age, then the <literal>when</literal> condition of an <literal>"Underage"</literal> rule would be <literal>Applicant( age &lt; 21 )</literal>.</simpara>
<note>
<simpara>DRL uses <literal>when</literal> instead of <literal>if</literal> because <literal>if</literal> is typically part of a procedural execution flow during which a condition is checked at a specific point in time. In contrast, <literal>when</literal> indicates that the condition evaluation is not limited to a specific evaluation sequence or point in time, but instead occurs continually at any time. Whenever the condition is met, the actions are executed.</simpara>
</note>
<simpara>If the <literal>when</literal> section is empty, then the conditions are considered to be true and the actions in the <literal>then</literal> section are executed the first time a <literal>fireAllRules()</literal> call is made in the decision engine. This is useful if you want to use rules to set up the decision engine state.</simpara>
<simpara>The following example rule uses empty conditions to insert a fact every time the rule is executed:</simpara>
<formalpara>
<title>Example rule without conditions</title>
<para>
<screen>rule "Always insert applicant"
  when
    // Empty
  then   // Actions to be executed once
    insert( new Applicant() );
end

// The rule is internally rewritten in the following way:

rule "Always insert applicant"
  when
    eval( true )
  then
    insert( new Applicant() );
end</screen>
</para>
</formalpara>
<simpara>If rule conditions use multiple patterns with no defined keyword conjunctions (such as <literal>and</literal>, <literal>or</literal>, or <literal>not</literal>), the default conjunction is <literal>and</literal>:</simpara>
<formalpara>
<title>Example rule without keyword conjunctions</title>
<para>
<screen>rule "Underage"
  when
    application : LoanApplication()
    Applicant( age &lt; 21 )
  then
    // Actions
end

// The rule is internally rewritten in the following way:

rule "Underage"
  when
    application : LoanApplication()
    and Applicant( age &lt; 21 )
  then
    // Actions
end</screen>
</para>
</formalpara>
<section xml:id="patterns_and_constraints" remap="_patterns_and_constraints">
<title>Patterns and constraints</title>
<simpara>A <emphasis>pattern</emphasis> in a DRL rule condition is the segment to be matched by the decision engine. A pattern can potentially match each fact that is inserted into the working memory of the decision engine. A pattern can also contain <emphasis>constraints</emphasis> to further define the facts to be matched.</simpara>
<simpara>In the simplest form, with no constraints, a pattern matches a fact of the given type. In the following example, the type is <literal>Person</literal>, so the pattern will match against all <literal>Person</literal> objects in the working memory of the decision engine:</simpara>
<formalpara>
<title>Example pattern for a single fact type</title>
<para>
<screen>Person()</screen>
</para>
</formalpara>
<simpara>The type does not need to be the actual class of some fact object. Patterns can refer to superclasses or even interfaces, potentially matching facts from many different classes. For example, the following pattern matches all objects in the working memory of the decision engine:</simpara>
<formalpara>
<title>Example pattern for all objects</title>
<para>
<screen>Object() // Matches all objects in the working memory</screen>
</para>
</formalpara>
<simpara>The parentheses of a pattern enclose the constraints, such as the following constraint on the person’s age:</simpara>
<formalpara>
<title>Example pattern with a constraint</title>
<para>
<screen>Person( age == 50 )</screen>
</para>
</formalpara>
<simpara>A <emphasis>constraint</emphasis> is an expression that returns <literal>true</literal> or <literal>false</literal>. Pattern constraints in DRL are essentially Java expressions with some enhancements, such as property access, and some differences, such as <literal>equals()</literal> and <literal>!equals()</literal> semantics for <literal>==</literal> and <literal>!=</literal> (instead of the usual <literal>same</literal> and <literal>not same</literal> semantics).</simpara>
<simpara>Any JavaBeans property can be accessed directly from pattern constraints. A bean property is exposed internally using a standard JavaBeans getter that takes no arguments and returns something. For example, the <literal>age</literal> property is written as <literal>age</literal> in DRL instead of the getter <literal>getAge()</literal>:</simpara>
<formalpara>
<title>DRL constraint syntax with JavaBeans properties</title>
<para>
<screen>Person( age == 50 )

// This is the same as the following getter format:

Person( getAge() == 50 )</screen>
</para>
</formalpara>
<simpara>Red Hat Decision Manager uses the standard JDK <literal>Introspector</literal> class to achieve this mapping, so it follows the standard JavaBeans specification. For optimal decision engine performance, use the property access format, such as <literal>age</literal>, instead of using getters explicitly, such as <literal>getAge()</literal>.</simpara>
<warning>
<simpara>Do not use property accessors to change the state of the object in a way that might affect the rules because the decision engine caches the results of the match between invocations for higher efficiency.</simpara>
<simpara>For example, do not use property accessors in the following ways:</simpara>
<programlisting language="java" linenumbering="unnumbered">public int getAge() {
    age++; // Do not do this.
    return age;
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public int getAge() {
    Date now = DateUtil.now(); // Do not do this.
    return DateUtil.differenceInYears(now, birthday);
}</programlisting>
<simpara>Instead of following the second example, insert a fact that wraps the current date in the working memory and update that fact between <literal>fireAllRules()</literal> as needed.</simpara>
</warning>
<simpara>However, if the getter of a property cannot be found, the compiler uses the property name as a fallback method name, without arguments:</simpara>
<formalpara>
<title>Fallback method if object is not found</title>
<para>
<screen>Person( age == 50 )

// If `Person.getAge()` does not exist, the compiler uses the following syntax:

Person( age() == 50 )</screen>
</para>
</formalpara>
<simpara>You can also nest access properties in patterns, as shown in the following example. Nested properties are indexed by the decision engine.</simpara>
<formalpara>
<title>Example pattern with nested property access</title>
<para>
<screen>Person( address.houseNumber == 50 )

// This is the same as the following format:

Person( getAddress().getHouseNumber() == 50 )</screen>
</para>
</formalpara>
<warning>
<simpara>In stateful KIE sessions, use nested accessors carefully because the working memory of the decision engine is not aware of any of the nested values and does not detect when they change. Either consider the nested values immutable while any of their parent references are inserted into the working memory, or, if you want to modify a nested value, mark all of the outer facts as updated. In the previous example, when the <literal>houseNumber</literal> property changes, any <literal>Person</literal> with that <literal>Address</literal> must be marked as updated.</simpara>
</warning>
<simpara>You can use any Java expression that returns a <literal>boolean</literal> value as a constraint inside the parentheses of a pattern. Java expressions can be mixed with other expression enhancements, such as property access:</simpara>
<formalpara>
<title>Example pattern with a constraint using property access and Java expression</title>
<para>
<screen>Person( age == 50 )</screen>
</para>
</formalpara>
<simpara>You can change the evaluation priority by using parentheses, as in any logical or mathematical expression:</simpara>
<formalpara>
<title>Example evaluation order of constraints</title>
<para>
<screen>Person( age &gt; 100 &amp;&amp; ( age % 10 == 0 ) )</screen>
</para>
</formalpara>
<simpara>You can also reuse Java methods in constraints, as shown in the following example:</simpara>
<formalpara>
<title>Example constraints with reused Java methods</title>
<para>
<screen>Person( Math.round( weight / ( height * height ) ) &lt; 25.0 )</screen>
</para>
</formalpara>
<warning>
<simpara>Do not use constraints to change the state of the object in a way that might affect the rules because the decision engine caches the results of the match between invocations for higher efficiency. Any method that is executed on a fact in the rule conditions must be a read-only method. Also, the state of a fact should not change between rule invocations unless those facts are marked as updated in the working memory on every change.</simpara>
<simpara>For example, do not use a pattern constraint in the following ways:</simpara>
<screen>Person( incrementAndGetAge() == 10 ) // Do not do this.</screen>
<screen>Person( System.currentTimeMillis() % 1000 == 0 ) // Do not do this.</screen>
</warning>
<simpara>Standard Java operator precedence applies to constraint operators in DRL, and DRL operators follow standard Java semantics except for the <literal>==</literal> and <literal>!=</literal> operators.</simpara>
<simpara>The <literal>==</literal> operator uses null-safe <literal>equals()</literal> semantics instead of the usual <literal>same</literal> semantics. For example, the pattern <literal>Person( firstName == "John" )</literal> is similar to <literal>java.util.Objects.equals(person.getFirstName(), "John")</literal>, and because <literal>"John"</literal> is not null, the pattern is also similar to <literal>"John".equals(person.getFirstName())</literal>.</simpara>
<simpara>The <literal>!=</literal> operator uses null-safe <literal>!equals()</literal> semantics instead of the usual <literal>not same</literal> semantics. For example, the pattern <literal>Person( firstName != "John" )</literal> is similar to <literal>!java.util.Objects.equals(person.getFirstName(), "John")</literal>.</simpara>
<simpara>If the field and the value of a constraint are of different types, the decision engine uses type coercion to resolve the conflict and reduce compilation errors. For instance, if <literal>"ten"</literal> is provided as a string in a numeric evaluator, a compilation error occurs, whereas <literal>"10"</literal> is coerced to a numeric 10. In coercion, the field type always takes precedence over the value type:</simpara>
<formalpara>
<title>Example constraint with a value that is coerced</title>
<para>
<screen>Person( age == "10" ) // "10" is coerced to 10</screen>
</para>
</formalpara>
<simpara>For groups of constraints, you can use a delimiting comma <literal>,</literal> to use implicit <literal>and</literal> connective semantics:</simpara>
<formalpara>
<title>Example patterns with multiple constraints</title>
<para>
<screen>// Person is at least 50 years old and weighs at least 80 kilograms:
Person( age &gt; 50, weight &gt; 80 )

// Person is at least 50 years old, weighs at least 80 kilograms, and is taller than 2 meters:
Person( age &gt; 50, weight &gt; 80, height &gt; 2 )</screen>
</para>
</formalpara>
<note>
<simpara>Although the <literal>&amp;&amp;</literal> and <literal>,</literal> operators have the same semantics, they are resolved with different priorities. The <literal>&amp;&amp;</literal> operator precedes the <literal>||</literal> operator, and both the <literal>&amp;&amp;</literal> and <literal>||</literal> operators together precede the <literal>,</literal> operator. Use the comma operator at the top-level constraint for optimal decision engine performance and human readability.</simpara>
</note>
<simpara>You cannot embed a comma operator in a composite constraint expression, such as in parentheses:</simpara>
<formalpara>
<title>Example of misused comma in composite constraint expression</title>
<para>
<screen>// Do not use the following format:
Person( ( age &gt; 50, weight &gt; 80 ) || height &gt; 2 )

// Use the following format instead:
Person( ( age &gt; 50 &amp;&amp; weight &gt; 80 ) || height &gt; 2 )</screen>
</para>
</formalpara>
</section>
<section xml:id="bound_variables_in_patterns_and_constraints" remap="_bound_variables_in_patterns_and_constraints">
<title>Bound variables in patterns and constraints</title>
<simpara>You can bind variables to patterns and constraints to refer to matched objects in other portions of a rule. Bound variables can help you define rules more efficiently or more consistently with how you annotate facts in your data model. To differentiate more easily between variables and fields in a rule, use the standard format <literal>$variable</literal> for variables, especially in complex rules. This convention is helpful but not required in DRL.</simpara>
<simpara>For example, the following DRL rule uses the variable <literal>$p</literal> for a pattern with the <literal>Person</literal> fact:</simpara>
<formalpara>
<title>Pattern with a bound variable</title>
<para>
<screen>rule "simple rule"
  when
    $p : Person()
  then
    System.out.println( "Person " + $p );
end</screen>
</para>
</formalpara>
<simpara>Similarly, you can also bind variables to properties in pattern constraints, as shown in the following example:</simpara>
<screen>// Two persons of the same age:
Person( $firstAge : age ) // Binding
Person( age == $firstAge ) // Constraint expression</screen>
<note>
<simpara>Ensure that you separate constraint bindings and constraint expressions for clearer and more efficient rule definitions. Although mixed bindings and expressions are supported, they can complicate patterns and affect evaluation efficiency.</simpara>
<screen>// Do not use the following format:
Person( $age : age * 2 &lt; 100 )

// Use the following format instead:
Person( age * 2 &lt; 100, $age : age )</screen>
</note>
<simpara>The decision engine does not support bindings to the same declaration, but does support <emphasis>unification</emphasis> of arguments across several properties. While positional arguments are always processed with unification, the unification symbol <literal>:=</literal> exists for named arguments.</simpara>
<simpara>The following example patterns unify the <literal>age</literal> property across two <literal>Person</literal> facts:</simpara>
<formalpara>
<title>Example pattern with unification</title>
<para>
<screen>Person( $age := age )
Person( $age := age )</screen>
</para>
</formalpara>
<simpara>Unification declares a binding for the first occurrence and constrains to the same value of the bound field for sequence occurrences.</simpara>
</section>
<section xml:id="nested_constraints_and_inline_casts" remap="_nested_constraints_and_inline_casts">
<title>Nested constraints and inline casts</title>
<simpara>In some cases, you might need to access multiple properties of a nested object, as shown in the following example:</simpara>
<formalpara>
<title>Example pattern to access multiple properties</title>
<para>
<screen>Person( name == "mark", address.city == "london", address.country == "uk" )</screen>
</para>
</formalpara>
<simpara>You can group these property accessors to nested objects with the syntax <literal>.( &lt;constraints&gt; )</literal> for more readable rules, as shown in the following example:</simpara>
<formalpara>
<title>Example pattern with grouped constraints</title>
<para>
<screen>Person( name == "mark", address.( city == "london", country == "uk") )</screen>
</para>
</formalpara>
<note>
<simpara>The period prefix <literal>.</literal> differentiates the nested object constraints from a method call.</simpara>
</note>
<simpara>When you work with nested objects in patterns, you can use the syntax <literal>&lt;type&gt;#&lt;subtype&gt;</literal> to cast to a subtype and make the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes, as shown in the following examples:</simpara>
<formalpara>
<title>Example patterns with inline casting to a subtype</title>
<para>
<screen>// Inline casting with subtype name:
Person( name == "mark", address#LongAddress.country == "uk" )

// Inline casting with fully qualified class name:
Person( name == "mark", address#org.domain.LongAddress.country == "uk" )

// Multiple inline casts:
Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</screen>
</para>
</formalpara>
<simpara>These example patterns cast <literal>Address</literal> to <literal>LongAddress</literal>, and additionally to <literal>DetailedCountry</literal> in the last example, making the parent getters available to the subtypes in each case.</simpara>
<simpara>You can use the <literal>instanceof</literal> operator to infer the results of the specified type in subsequent uses of that field with the pattern, as shown in the following example:</simpara>
<screen>Person( name == "mark", address instanceof LongAddress, address.country == "uk" )</screen>
<simpara>If an inline cast is not possible (for example, if <literal>instanceof</literal> returns <literal>false</literal>), the evaluation is considered <literal>false</literal>.</simpara>
</section>
<section xml:id="date_literal_in_constraints" remap="_date_literal_in_constraints">
<title>Date literal in constraints</title>
<simpara>By default, the decision engine supports the date format <literal>dd-mmm-yyyy</literal>. You can customize the date format, including a time format mask if needed, by providing an alternative format mask with the system property <literal>drools.dateformat="dd-mmm-yyyy hh:mm"</literal>. You can also customize the date format by changing the language locale with the <literal>drools.defaultlanguage</literal> and <literal>drools.defaultcountry</literal> system properties (for example, the locale of Thailand is set as <literal>drools.defaultlanguage=th</literal> and <literal>drools.defaultcountry=TH</literal>).</simpara>
<formalpara>
<title>Example pattern with a date literal restriction</title>
<para>
<screen>Person( bornBefore &lt; "27-Oct-2009" )</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-operators-ref_drl-rules">
<title>Supported operators in DRL pattern constraints</title>
<simpara>DRL supports standard Java semantics for operators in pattern constraints, with some exceptions and with some additional operators that are unique in DRL. The following list summarizes the operators that are handled differently in DRL constraints than in standard Java semantics or that are unique in DRL constraints.</simpara>
<variablelist>
<varlistentry>
<term><literal>.()</literal>, <literal>#</literal></term>
<listitem>
<simpara>Use the <literal>.()</literal> operator to group property accessors to nested objects, and use the <literal>#</literal> operator to cast to a subtype in nested objects. Casting to a subtype makes the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes.</simpara>
<formalpara>
<title>Example patterns with nested objects</title>
<para>
<screen>// Ungrouped property accessors:
Person( name == "mark", address.city == "london", address.country == "uk" )

// Grouped property accessors:
Person( name == "mark", address.( city == "london", country == "uk") )</screen>
</para>
</formalpara>
<note>
<simpara>The period prefix <literal>.</literal> differentiates the nested object constraints from a method call.</simpara>
</note>
<formalpara>
<title>Example patterns with inline casting to a subtype</title>
<para>
<screen>// Inline casting with subtype name:
Person( name == "mark", address#LongAddress.country == "uk" )

// Inline casting with fully qualified class name:
Person( name == "mark", address#org.domain.LongAddress.country == "uk" )

// Multiple inline casts:
Person( name == "mark", address#LongAddress.country#DetailedCountry.population &gt; 10000000 )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>!.</literal></term>
<listitem>
<simpara>Use this operator to dereference a property in a null-safe way. The value to the left of the <literal>!.</literal> operator must be not null (interpreted as <literal>!= null</literal>) in order to give a positive result for pattern matching.</simpara>
<formalpara>
<title>Example constraint with null-safe dereferencing</title>
<para>
<screen>Person( $streetName : address!.street )

// This is internally rewritten in the following way:

Person( address != null, $streetName : address.street )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>[]</literal></term>
<listitem>
<simpara>Use this operator to access a <literal>List</literal> value by index or a <literal>Map</literal> value by key.</simpara>
<formalpara>
<title>Example constraints with <literal>List</literal> and <literal>Map</literal> access</title>
<para>
<screen>// The following format is the same as `childList(0).getAge() == 18`:
Person(childList[0].age == 18)

// The following format is the same as `credentialMap.get("jdoe").isValid()`:
Person(credentialMap["jdoe"].valid)</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal>, <literal>&gt;=</literal></term>
<listitem>
<simpara>Use these operators on properties with natural ordering. For example, for <literal>Date</literal> fields, the <literal>&lt;</literal> operator means <emphasis>before</emphasis>, and for <literal>String</literal> fields, the operator means <emphasis>alphabetically before</emphasis>. These properties apply only to comparable properties.</simpara>
<formalpara>
<title>Example constraints with <literal>before</literal> operator</title>
<para>
<screen>Person( birthDate &lt; $otherBirthDate )

Person( firstName &lt; $otherFirstName )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>==</literal>, <literal>!=</literal></term>
<listitem>
<simpara>Use these operators as <literal>equals()</literal> and <literal>!equals()</literal> methods in constraints, instead of the usual <literal>same</literal> and <literal>not same</literal> semantics.</simpara>
<formalpara>
<title>Example constraint with null-safe equality</title>
<para>
<screen>Person( firstName == "John" )

// This is similar to the following formats:

java.util.Objects.equals(person.getFirstName(), "John")
"John".equals(person.getFirstName())</screen>
</para>
</formalpara>
<formalpara>
<title>Example constraint with null-safe not equality</title>
<para>
<screen>Person( firstName != "John" )

// This is similar to the following format:

!java.util.Objects.equals(person.getFirstName(), "John")</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&amp;&amp;</literal>, <literal>||</literal></term>
<listitem>
<simpara>Use these operators to create an abbreviated combined relation condition that adds more than one restriction on a field. You can group constraints with parentheses <literal>()</literal> to create a recursive syntax pattern.</simpara>
<formalpara>
<title>Example constraints with abbreviated combined relation</title>
<para>
<screen>// Simple abbreviated combined relation condition using a single `&amp;&amp;`:
Person(age &gt; 30 &amp;&amp; &lt; 40)

// Complex abbreviated combined relation using groupings:
Person(age ((&gt; 30 &amp;&amp; &lt; 40) || (&gt; 20 &amp;&amp; &lt; 25)))

// Mixing abbreviated combined relation with constraint connectives:
Person(age &gt; 30 &amp;&amp; &lt; 40 || location == "london")</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>matches</literal>, <literal>not matches</literal></term>
<listitem>
<simpara>Use these operators to indicate that a field matches or does not match a specified Java regular expression. Typically, the regular expression is a <literal>String</literal> literal, but variables that resolve to a valid regular expression are also supported. These operators apply only to <literal>String</literal> properties. If you use <literal>matches</literal> against a <literal>null</literal> value, the resulting evaluation is always <literal>false</literal>. If you use <literal>not matches</literal> against a <literal>null</literal> value, the resulting evaluation is always <literal>true</literal>. As in Java, regular expressions that you write as <literal>String</literal> literals must use a double backslash <literal>\\</literal> to escape.</simpara>
<formalpara>
<title>Example constraint to match or not match a regular expression</title>
<para>
<screen>Person( country matches "(USA)?\\S*UK" )

Person( country not matches "(USA)?\\S*UK" )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>contains</literal>, <literal>not contains</literal></term>
<listitem>
<simpara>Use these operators to verify whether a field that is an <literal>Array</literal> or a <literal>Collection</literal> contains or does not contain a specified value. These operators apply to <literal>Array</literal> or <literal>Collection</literal> properties, but you can also use these operators in place of <literal>String.contains()</literal> and <literal>!String.contains()</literal> constraints checks.</simpara>
<formalpara>
<title>Example constraints with <literal>contains</literal> and <literal>not contains</literal> for a Collection</title>
<para>
<screen>// Collection with a specified field:
FamilyTree( countries contains "UK" )

FamilyTree( countries not contains "UK" )


// Collection with a variable:
FamilyTree( countries contains $var )

FamilyTree( countries not contains $var )</screen>
</para>
</formalpara>
<formalpara>
<title>Example constraints with <literal>contains</literal> and <literal>not contains</literal> for a String literal</title>
<para>
<screen>// Sting literal with a specified field:
Person( fullName contains "Jr" )

Person( fullName not contains "Jr" )


// String literal with a variable:
Person( fullName contains $var )

Person( fullName not contains $var )</screen>
</para>
</formalpara>
<note>
<simpara>For backward compatibility, the <literal>excludes</literal> operator is a supported synonym for <literal>not contains</literal>.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>memberOf</literal>, <literal>not memberOf</literal></term>
<listitem>
<simpara>Use these operators to verify whether a field is a member of or is not a member of an <literal>Array</literal> or a <literal>Collection</literal> that is defined as a variable. The <literal>Array</literal> or <literal>Collection</literal> must be a variable.</simpara>
<formalpara>
<title>Example constraints with <literal>memberOf</literal> and <literal>not memberOf</literal> with a Collection</title>
<para>
<screen>FamilyTree( person memberOf $europeanDescendants )

FamilyTree( person not memberOf $europeanDescendants )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>soundslike</literal></term>
<listitem>
<simpara>Use this operator to verify whether a word has almost the same sound, using English pronunciation, as the given value (similar to the <literal>matches</literal> operator). This operator uses the Soundex algorithm.</simpara>
<formalpara>
<title>Example constraint with <literal>soundslike</literal></title>
<para>
<screen>// Match firstName "Jon" or "John":
Person( firstName soundslike "John" )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>str</literal></term>
<listitem>
<simpara>Use this operator to verify whether a field that is a <literal>String</literal> starts with or ends with a specified value. You can also use this operator to verify the length of the <literal>String</literal>.</simpara>
<formalpara>
<title>Example constraints with <literal>str</literal></title>
<para>
<screen>// Verify what the String starts with:
Message( routingValue str[startsWith] "R1" )

// Verify what the String ends with:
Message( routingValue str[endsWith] "R2" )

// Verify the length of the String:
Message( routingValue str[length] 17 )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>in</literal>, <literal>notin</literal></term>
<listitem>
<simpara>Use these operators to specify more than one possible value to match in a constraint (compound value restriction). This functionality of compound value restriction is supported only in the <literal>in</literal> and <literal>not in</literal> operators. The second operand of these operators must be a comma-separated list of values enclosed in parentheses. You can provide values as variables, literals, return values, or qualified identifiers. These operators are internally rewritten as a list of multiple restrictions using the operators <literal>==</literal> or <literal>!=</literal>.</simpara>
<formalpara>
<title>Example constraints with <literal>in</literal> and <literal>notin</literal></title>
<para>
<screen>Person( $color : favoriteColor )
Color( type in ( "red", "blue", $color ) )

Person( $color : favoriteColor )
Color( type notin ( "red", "blue", $color ) )</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="drl-operator-precedence-ref_drl-rules">
<title>Operator precedence in DRL pattern constraints</title>
<simpara>DRL supports standard Java operator precedence for applicable constraint operators, with some exceptions and with some additional operators that are unique in DRL. The following table lists DRL operator precedence where applicable, from highest to lowest precedence:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Operator precedence in DRL pattern constraints</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="29*"/>
<colspec colname="col_2" colwidth="29*"/>
<colspec colname="col_3" colwidth="43*"/>
<thead>
<row>
<entry align="left" valign="top">Operator type</entry>
<entry align="left" valign="top">Operators</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Nested or null-safe property access</simpara></entry>
<entry align="left" valign="top"><simpara><literal>.</literal>, <literal>.()</literal>, <literal>!.</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not standard Java semantics</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>List</literal> or <literal>Map</literal> access</simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not standard Java semantics</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Constraint binding</simpara></entry>
<entry align="left" valign="top"><simpara><literal>:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not standard Java semantics</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Multiplicative</simpara></entry>
<entry align="left" valign="top"><simpara><literal>*</literal>, <literal>/%</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Additive</simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal>, <literal>-</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Shift</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;&gt;</literal>, <literal>&gt;&gt;&gt;</literal>, <literal>&lt;&lt;</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Relational</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal>, <literal>&gt;=</literal>, <literal>instanceof</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Equality</simpara></entry>
<entry align="left" valign="top"><simpara><literal>== !=</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Uses <literal>equals()</literal> and <literal>!equals()</literal> semantics, not standard Java <literal>same</literal> and <literal>not same</literal> semantics</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Non-short-circuiting <literal>AND</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Non-short-circuiting exclusive <literal>OR</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>^</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Non-short-circuiting inclusive <literal>OR</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>|</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Logical <literal>AND</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&amp;&amp;</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Logical <literal>OR</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>||</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Ternary</simpara></entry>
<entry align="left" valign="top"><simpara><literal>? :</literal></simpara></entry>
<entry align="left" valign="top"/>
</row>
<row>
<entry align="left" valign="top"><simpara>Comma-separated <literal>AND</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>,</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not standard Java semantics</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="drl-rules-WHEN-elements-ref_drl-rules">
<title>Supported rule condition elements in DRL (keywords)</title>
<simpara>DRL supports the following rule condition elements (keywords) that you can use with the patterns that you define in DRL rule conditions:</simpara>
<variablelist>
<varlistentry>
<term><literal>and</literal></term>
<listitem>
<simpara>Use this to group conditional components into a logical conjunction. Infix and prefix <literal>and</literal> are supported. You can group patterns explicitly with parentheses <literal>()</literal>. By default, all listed patterns are combined with <literal>and</literal> when no conjunction is specified.</simpara>
<formalpara>
<title>Example patterns with <literal>and</literal></title>
<para>
<screen>//Infix `and`:
Color( colorType : type ) and Person( favoriteColor == colorType )

//Infix `and` with grouping:
(Color( colorType : type ) and (Person( favoriteColor == colorType ) or Person( favoriteColor == colorType ))

// Prefix `and`:
(and Color( colorType : type ) Person( favoriteColor == colorType ))

// Default implicit `and`:
Color( colorType : type )
Person( favoriteColor == colorType )</screen>
</para>
</formalpara>
<note>
<simpara>Do not use a leading declaration binding with the <literal>and</literal> keyword (as you can with <literal>or</literal>, for example). A declaration can only reference a single fact at a time, and if you use a declaration binding with <literal>and</literal>, then when <literal>and</literal> is satisfied, it matches both facts and results in an error.</simpara>
<formalpara>
<title>Example misuse of <literal>and</literal></title>
<para>
<screen>// Causes compile error:
$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))</screen>
</para>
</formalpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>or</literal></term>
<listitem>
<simpara>Use this to group conditional components into a logical disjunction. Infix and prefix <literal>or</literal> are supported. You can group patterns explicitly with parentheses <literal>()</literal>. You can also use pattern binding with <literal>or</literal>, but each pattern must be bound separately.</simpara>
<formalpara>
<title>Example patterns with <literal>or</literal></title>
<para>
<screen>//Infix `or`:
Color( colorType : type ) or Person( favoriteColor == colorType )

//Infix `or` with grouping:
(Color( colorType : type ) or (Person( favoriteColor == colorType ) and Person( favoriteColor == colorType ))

// Prefix `or`:
(or Color( colorType : type ) Person( favoriteColor == colorType ))</screen>
</para>
</formalpara>
<formalpara>
<title>Example patterns with <literal>or</literal> and pattern binding</title>
<para>
<screen>pensioner : (Person( sex == "f", age &gt; 60 ) or Person( sex == "m", age &gt; 65 ))

(or pensioner : Person( sex == "f", age &gt; 60 )
    pensioner : Person( sex == "m", age &gt; 65 ))</screen>
</para>
</formalpara>
<simpara>The behavior of the <literal>or</literal> condition element is different from the connective <literal>||</literal> operator for constraints and restrictions in field constraints. The decision engine does not directly interpret the <literal>or</literal> element but uses logical transformations to rewrite a rule with <literal>or</literal> as a number of sub-rules. This process ultimately results in a rule that has a single <literal>or</literal> as the root node and one sub-rule for each of its condition elements. Each sub-rule is activated and executed like any normal rule, with no special behavior or interaction between the sub-rules.</simpara>
<simpara>Therefore, consider the <literal>or</literal> condition element a shortcut for generating two or more similar rules that, in turn, can create multiple activations when two or more terms of the disjunction are true.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>exists</literal></term>
<listitem>
<simpara>Use this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches. If you use this element with multiple patterns, enclose the patterns with parentheses <literal>()</literal>.</simpara>
<formalpara>
<title>Example patterns with <literal>exists</literal></title>
<para>
<screen>exists Person( firstName == "John")

exists (Person( firstName == "John", age == 42 ))

exists (Person( firstName == "John" ) and
        Person( lastName == "Doe" ))</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>not</literal></term>
<listitem>
<simpara>Use this to specify facts and constraints that must not exist. If you use this element with multiple patterns, enclose the patterns with parentheses <literal>()</literal>.</simpara>
<formalpara>
<title>Example patterns with <literal>not</literal></title>
<para>
<screen>not Person( firstName == "John")

not (Person( firstName == "John", age == 42 ))

not (Person( firstName == "John" ) and
     Person( lastName == "Doe" ))</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>forall</literal></term>
<listitem>
<simpara>Use this to verify whether all facts that match the first pattern match all the remaining patterns. When a <literal>forall</literal> construct is satisfied, the rule evaluates to <literal>true</literal>. This element is a scope delimiter, so it can use any previously bound variable, but no variable bound inside of it is available for use outside of it.</simpara>
<formalpara>
<title>Example rule with <literal>forall</literal></title>
<para>
<screen>rule "All full-time employees have red ID badges"
  when
    forall( $emp : Employee( type == "fulltime" )
                   Employee( this == $emp, badgeColor = "red" ) )
  then
    // True, all full-time employees have red ID badges.
end</screen>
</para>
</formalpara>
<simpara>In this example, the rule selects all <literal>Employee</literal> objects whose type is <literal>"fulltime"</literal>. For each fact that matches this pattern, the rule evaluates the patterns that follow (badge color) and if they match, the rule evaluates to <literal>true</literal>.</simpara>
<simpara>To state that all facts of a given type in the working memory of the decision engine must match a set of constraints, you can use <literal>forall</literal> with a single pattern for simplicity.</simpara>
<formalpara>
<title>Example rule with <literal>forall</literal> and a single pattern</title>
<para>
<screen>rule "All full-time employees have red ID badges"
  when
    forall( Employee( badgeColor = "red" ) )
  then
    // True, all full-time employees have red ID badges.
end</screen>
</para>
</formalpara>
<simpara>You can use <literal>forall</literal> constructs with multiple patterns or nest them with other condition elements, such as inside a <literal>not</literal> element construct.</simpara>
<formalpara>
<title>Example rule with <literal>forall</literal> and multiple patterns</title>
<para>
<screen>rule "All employees have health and dental care programs"
  when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
  then
    // True, all employees have health and dental care.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example rule with <literal>forall</literal> and <literal>not</literal></title>
<para>
<screen>rule "Not all employees have health and dental care"
  when
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) )
        )
  then
    // True, not all employees have health and dental care.
end</screen>
</para>
</formalpara>
<note>
<simpara>The format <literal>forall( p1 p2 p3 …​)</literal> is equivalent to <literal>not( p1 and not( and p2 p3 …​ ) )</literal>.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>from</literal></term>
<listitem>
<simpara>Use this to specify a data source for a pattern. This enables the decision engine to reason over data that is not in the working memory. The data source can be a sub-field on a bound variable or the result of a method call. The expression used to define the object source is any expression that follows regular MVEL syntax. Therefore, the <literal>from</literal> element enables you to easily use object property navigation, execute method calls, and access maps and collection elements.</simpara>
<formalpara>
<title>Example rule with <literal>from</literal> and pattern binding</title>
<para>
<screen>rule "Validate zipcode"
  when
    Person( $personAddress : address )
    Address( zipcode == "23920W" ) from $personAddress
  then
    // Zip code is okay.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example rule with <literal>from</literal> and a graph notation</title>
<para>
<screen>rule "Validate zipcode"
  when
    $p : Person()
    $a : Address( zipcode == "23920W" ) from $p.address
  then
    // Zip code is okay.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example rule with <literal>from</literal> to iterate over all objects</title>
<para>
<screen>rule "Apply 10% discount to all items over US$ 100 in an order"
  when
    $order : Order()
    $item  : OrderItem( value &gt; 100 ) from $order.items
  then
    // Apply discount to `$item`.
end</screen>
</para>
</formalpara>
<note>
<simpara>For large collections of objects, instead of adding an object with a large graph that the decision engine must iterate over frequently, add the collection directly to the KIE session and then join the collection in the condition, as shown in the following example:</simpara>
<screen>when
  $order : Order()
  OrderItem( value &gt; 100, order == $order )</screen>
</note>
<formalpara>
<title>Example rule with <literal>from</literal> and <literal>lock-on-active</literal> rule attribute</title>
<para>
<screen>rule "Assign people in North Carolina (NC) to sales region 1"
  ruleflow-group "test"
  lock-on-active true
  when
    $p : Person()
    $a : Address( state == "NC" ) from $p.address
  then
    modify ($p) {} // Assign the person to sales region 1.
end

rule "Apply a discount to people in the city of Raleigh"
  ruleflow-group "test"
  lock-on-active true
  when
    $p : Person()
    $a : Address( city == "Raleigh" ) from $p.address
  then
    modify ($p) {} // Apply discount to the person.
end</screen>
</para>
</formalpara>
<important>
<simpara>Using <literal>from</literal> with <literal>lock-on-active</literal> rule attribute can result in rules not being executed. You can address this issue in one of the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Avoid using the <literal>from</literal> element when you can insert all facts into the working memory of the decision engine or use nested object references in your constraint expressions.</simpara>
</listitem>
<listitem>
<simpara>Place the variable used in the <literal>modify()</literal> block as the last sentence in your rule condition.</simpara>
</listitem>
<listitem>
<simpara>Avoid using the <literal>lock-on-active</literal> rule attribute when you can explicitly manage how rules within the same ruleflow group place activations on one another.</simpara>
</listitem>
</itemizedlist>
</important>
<simpara>The pattern that contains a <literal>from</literal> clause cannot be followed by another pattern starting with a parenthesis. The reason for this restriction is that the DRL parser reads the <literal>from</literal> expression as <literal>"from $l (String() or Number())"</literal> and it cannot differentiate this expression from a function call. The simplest workaround to this is to wrap the <literal>from</literal> clause in parentheses, as shown in the following example:</simpara>
<formalpara>
<title>Example rules with <literal>from</literal> used incorrectly and correctly</title>
<para>
<screen>// Do not use `from` in this way:
rule R
  when
    $l : List()
    String() from $l
    (String() or Number())
  then
    // Actions
end

// Use `from` in this way instead:
rule R
  when
    $l : List()
    (String() from $l)
    (String() or Number())
  then
    // Actions
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>entry-point</literal></term>
<listitem>
<simpara>Use this to define an entry point, or <emphasis>event stream</emphasis>, corresponding to a data source for the pattern. This element is typically used with the <literal>from</literal> condition element. You can declare an entry point for events so that the decision engine uses data from only that entry point to evaluate the rules. You can declare an entry point either implicitly by referencing it in DRL rules or explicitly in your Java application.</simpara>
<formalpara>
<title>Example rule with <literal>from entry-point</literal></title>
<para>
<screen>rule "Authorize withdrawal"
  when
    WithdrawRequest( $ai : accountId, $am : amount ) from entry-point "ATM Stream"
    CheckingAccount( accountId == $ai, balance &gt; $am )
  then
    // Authorize withdrawal.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example Java application code with EntryPoint object and inserted facts</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.rule.EntryPoint;

// Create your KIE base and KIE session as usual:
KieSession session = ...

// Create a reference to the entry point:
EntryPoint atmStream = session.getEntryPoint("ATM Stream");

// Start inserting your facts into the entry point:
atmStream.insert(aWithdrawRequest);</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>collect</literal></term>
<listitem>
<simpara>Use this to define a collection of objects that the rule can use as part of the condition. The rule obtains the collection either from a specified source or from the working memory of the decision engine. The result pattern of the <literal>collect</literal> element can be any concrete class that implements the <literal>java.util.Collection</literal> interface and provides a default no-arg public constructor. You can use Java collections like <literal>List</literal>, <literal>LinkedList</literal>, and <literal>HashSet</literal>, or your own class. If variables are bound before the <literal>collect</literal> element in a condition, you can use the variables to constrain both your source and result patterns. However, any binding made inside the <literal>collect</literal> element is not available for use outside of it.</simpara>
<formalpara>
<title>Example rule with <literal>collect</literal></title>
<para>
<screen>import java.util.List

rule "Raise priority when system has more than three pending alarms"
  when
    $system : System()
    $alarms : List( size &gt;= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
  then
    // Raise priority because `$system` has three or more `$alarms` pending.
end</screen>
</para>
</formalpara>
<simpara>In this example, the rule assesses all pending alarms in the working memory of the decision engine for each given system and groups them in a <literal>List</literal>. If three or more alarms are found for a given system, the rule is executed.</simpara>
<simpara>You can also use the <literal>collect</literal> element with nested <literal>from</literal> elements, as shown in the following example:</simpara>
<formalpara>
<title>Example rule with <literal>collect</literal> and nested <literal>from</literal></title>
<para>
<screen>import java.util.LinkedList;

rule "Send a message to all parents"
  when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList()
               from collect( Person( children &gt; 0 )
                             from $town.getPeople()
                           )
  then
    // Send a message to all parents.
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>accumulate</literal></term>
<listitem>
<simpara>Use this to iterate over a collection of objects, execute custom actions for each of the elements, and return one or more result objects (if the constraints evaluate to <literal>true</literal>). This element is a more flexible and powerful form of the <literal>collect</literal> condition element. You can use predefined functions in your <literal>accumulate</literal> conditions or implement custom functions as needed. You can also use the abbreviation <literal>acc</literal> for <literal>accumulate</literal> in rule conditions.</simpara>
<simpara>Use the following format to define <literal>accumulate</literal> conditions in rules:</simpara>
<formalpara>
<title>Preferred format for <literal>accumulate</literal></title>
<para>
<screen>accumulate( &lt;source pattern&gt;; &lt;functions&gt; [;&lt;constraints&gt;] )</screen>
</para>
</formalpara>
<note>
<simpara>Although the decision engine supports alternate formats for the <literal>accumulate</literal> element for backward compatibility, this format is preferred for optimal performance in rules and applications.</simpara>
</note>
<simpara>The decision engine supports the following predefined <literal>accumulate</literal> functions. These functions accept any expression as input.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>average</literal></simpara>
</listitem>
<listitem>
<simpara><literal>min</literal></simpara>
</listitem>
<listitem>
<simpara><literal>max</literal></simpara>
</listitem>
<listitem>
<simpara><literal>count</literal></simpara>
</listitem>
<listitem>
<simpara><literal>sum</literal></simpara>
</listitem>
<listitem>
<simpara><literal>collectList</literal></simpara>
</listitem>
<listitem>
<simpara><literal>collectSet</literal></simpara>
</listitem>
</itemizedlist>
<simpara>In the following example rule, <literal>min</literal>, <literal>max</literal>, and <literal>average</literal> are <literal>accumulate</literal> functions that calculate the minimum, maximum, and average temperature values over all the readings for each sensor:</simpara>
<formalpara>
<title>Example rule with <literal>accumulate</literal> to calculate temperature values</title>
<para>
<screen>rule "Raise alarm"
  when
    $s : Sensor()
    accumulate( Reading( sensor == $s, $temp : temperature );
                $min : min( $temp ),
                $max : max( $temp ),
                $avg : average( $temp );
                $min &lt; 20, $avg &gt; 70 )
  then
    // Raise the alarm.
end</screen>
</para>
</formalpara>
<simpara>The following example rule uses the <literal>average</literal> function with <literal>accumulate</literal> to calculate the average profit for all items in an order:</simpara>
<formalpara>
<title>Example rule with <literal>accumulate</literal> to calculate average profit</title>
<para>
<screen>rule "Average profit"
  when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
  then
    // Average profit for `$order` is `$avgProfit`.
end</screen>
</para>
</formalpara>
<simpara>To use custom, domain-specific functions in <literal>accumulate</literal> conditions, create a Java class that implements the <literal>org.kie.api.runtime.rule.AccumulateFunction</literal> interface. For example, the following Java class defines a custom implementation of an <literal>AverageData</literal> function:</simpara>
<formalpara>
<title>Example Java class with custom implementation of <literal>average</literal> function</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// An implementation of an accumulator capable of calculating average values

public class AverageAccumulateFunction implements org.kie.api.runtime.rule.AccumulateFunction&lt;AverageAccumulateFunction.AverageData&gt; {

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public static class AverageData implements Externalizable {
        public int    count = 0;
        public double total = 0;

        public AverageData() {}

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            count   = in.readInt();
            total   = in.readDouble();
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(count);
            out.writeDouble(total);
        }

    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#createContext()
     */
    public AverageData createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#init(java.io.Serializable)
     */
    public void init(AverageData context) {
        context.count = 0;
        context.total = 0;
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#accumulate(java.io.Serializable, java.lang.Object)
     */
    public void accumulate(AverageData context,
                           Object value) {
        context.count++;
        context.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#reverse(java.io.Serializable, java.lang.Object)
     */
    public void reverse(AverageData context, Object value) {
        context.count--;
        context.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#getResult(java.io.Serializable)
     */
    public Object getResult(AverageData context) {
        return new Double( context.count == 0 ? 0 : context.total / context.count );
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#getResultType()
     */
    public Class&lt; ? &gt; getResultType() {
        return Number.class;
    }

}</programlisting>
</para>
</formalpara>
<simpara>To use the custom function in a DRL rule, import the function using the <literal>import accumulate</literal> statement:</simpara>
<formalpara>
<title>Format to import a custom function</title>
<para>
<screen>import accumulate &lt;class_name&gt; &lt;function_name&gt;</screen>
</para>
</formalpara>
<formalpara>
<title>Example rule with the imported <literal>average</literal> function</title>
<para>
<screen>import accumulate AverageAccumulateFunction.AverageData average

rule "Average profit"
  when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
  then
    // Average profit for `$order` is `$avgProfit`.
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="drl-rules-oopath-con_drl-rules">
<title>OOPath syntax with graphs of objects in DRL rule conditions</title>
<simpara>OOPath is an object-oriented syntax extension of XPath that is designed for browsing graphs of objects in DRL rule condition constraints. OOPath uses the compact notation from XPath for navigating through related elements while handling collections and filtering constraints, and is specifically useful for graphs of objects.</simpara>
<simpara>When the field of a fact is a collection, you can use the <literal>from</literal> condition element (keyword) to bind and reason over all the items in that collection one by one. If you need to browse a graph of objects in the rule condition constraints, the extensive use of the <literal>from</literal> condition element results in a verbose and repetitive syntax, as shown in the following example:</simpara>
<formalpara>
<title>Example rule that browses a graph of objects with <literal>from</literal></title>
<para>
<screen>rule "Find all grades for Big Data exam"
  when
    $student: Student( $plan: plan )
    $exam: Exam( course == "Big Data" ) from $plan.exams
    $grade: Grade() from $exam.grades
  then
    // Actions
end</screen>
</para>
</formalpara>
<simpara>In this example, the domain model contains a <literal>Student</literal> object with a <literal>Plan</literal> of study. The <literal>Plan</literal> can have zero or more <literal>Exam</literal> instances and an <literal>Exam</literal> can have zero or more <literal>Grade</literal> instances. Only the root object of the graph, the <literal>Student</literal> in this case, needs to be in the working memory of the decision engine for this rule setup to function.</simpara>
<simpara>As a more efficient alternative to using extensive <literal>from</literal> statements, you can use the abbreviated OOPath syntax, as shown in the following example:</simpara>
<formalpara>
<title>Example rule that browses a graph of objects with OOPath syntax</title>
<para>
<screen>rule "Find all grades for Big Data exam"
  when
    Student( $grade: /plan/exams[course == "Big Data"]/grades )
  then
    // Actions
end</screen>
</para>
</formalpara>
<simpara>Formally, the core grammar of an OOPath expression is defined in extended Backus-Naur form (EBNF) notation in the following way:</simpara>
<formalpara>
<title>EBNF notation for OOPath expressions</title>
<para>
<screen>OOPExpr = [ID ( ":" | ":=" )] ( "/" | "?/" ) OOPSegment { ( "/" | "?/" | "." ) OOPSegment } ;
OOPSegment = ID ["#" ID] ["[" ( Number | Constraints ) "]"]</screen>
</para>
</formalpara>
<simpara>In practice, an OOPath expression has the following features and capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Starts with a forward slash <literal>/</literal> or with a question mark and forward slash <literal>?/</literal> if it is a non-reactive OOPath expression (described later in this section).</simpara>
</listitem>
<listitem>
<simpara>Can dereference a single property of an object with the period <literal>.</literal> operator.</simpara>
</listitem>
<listitem>
<simpara>Can dereference multiple properties of an object with the forward slash <literal>/</literal> operator. If a collection is returned, the expression iterates over the values in the collection.</simpara>
</listitem>
<listitem>
<simpara>Can filter out traversed objects that do not satisfy one or more constraints. The constraints are written as predicate expressions between square brackets, as shown in the following example:</simpara>
<formalpara>
<title>Constraints as a predicate expression</title>
<para>
<screen>Student( $grade: /plan/exams[ course == "Big Data" ]/grades )</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Can downcast a traversed object to a subclass of the class declared in the generic collection. Subsequent constraints can also safely access the properties declared only in that subclass, as shown in the following example. Objects that are not instances of the class specified in this inline cast are automatically filtered out.</simpara>
<formalpara>
<title>Constraints with downcast objects</title>
<para>
<screen>Student( $grade: /plan/exams#AdvancedExam[ course == "Big Data", level &gt; 3 ]/grades )</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Can backreference an object of the graph that was traversed before the currently iterated graph. For example, the following OOPath expression matches only the grades that are above the average for the passed exam:</simpara>
<formalpara>
<title>Constraints with backreferenced object</title>
<para>
<screen>Student( $grade: /plan/exams/grades[ result &gt; ../averageResult ] )</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Can recursively be another OOPath expression, as shown in the following example:</simpara>
<formalpara>
<title>Recursive constraint expression</title>
<para>
<screen>Student( $exam: /plan/exams[ /grades[ result &gt; 20 ] ] )</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Can access objects by their index between square brackets <literal>[]</literal>, as shown in the following example. To adhere to Java convention, OOPath indexes are 0-based, while XPath indexes are 1-based.</simpara>
<formalpara>
<title>Constraints with access to objects by index</title>
<para>
<screen>Student( $grade: /plan/exams[0]/grades )</screen>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>OOPath expressions can be reactive or non-reactive. The decision engine does not react to updates involving a deeply nested object that is traversed during the evaluation of an OOPath expression.</simpara>
<simpara>To make these objects reactive to changes, modify the objects to extend the class <literal>org.drools.core.phreak.ReactiveObject</literal>. After you modify an object to extend the <literal>ReactiveObject</literal> class, the domain object invokes the inherited method <literal>notifyModification</literal> to notify the decision engine when one of the fields has been updated, as shown in the following example:</simpara>
<formalpara>
<title>Example object method to notify the decision engine that an exam has been moved to a different course</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public void setCourse(String course) {
        this.course = course;
        notifyModification(this);
        }</programlisting>
</para>
</formalpara>
<simpara>With the following corresponding OOPath expression, when an exam is moved to a different course, the rule is re-executed and the list of grades matching the rule is recomputed:</simpara>
<formalpara>
<title>Example OOPath expression from "Big Data" rule</title>
<para>
<screen>Student( $grade: /plan/exams[ course == "Big Data" ]/grades )</screen>
</para>
</formalpara>
<simpara>You can also use the <literal>?/</literal> separator instead of the <literal>/</literal> separator to disable reactivity in only one sub-portion of an OOPath expression, as shown in the following example:</simpara>
<formalpara>
<title>Example OOPath expression that is partially non-reactive</title>
<para>
<screen>Student( $grade: /plan/exams[ course == "Big Data" ]?/grades )</screen>
</para>
</formalpara>
<simpara>With this example, the decision engine reacts to a change made to an exam or if an exam is added to the plan, but not if a new grade is added to an existing exam.</simpara>
<simpara>If an OOPath portion is non-reactive, all remaining portions of the OOPath expression also become non-reactive. For example, the following OOPath expression is completely non-reactive:</simpara>
<formalpara>
<title>Example OOPath expression that is completely non-reactive</title>
<para>
<screen>Student( $grade: ?/plan/exams[ course == "Big Data" ]/grades )</screen>
</para>
</formalpara>
<simpara>For this reason, you cannot use the <literal>?/</literal> separator more than once in the same OOPath expression. For example, the following expression causes a compilation error:</simpara>
<formalpara>
<title>Example OOPath expression with duplicate non-reactivity markers</title>
<para>
<screen>Student( $grade: /plan?/exams[ course == "Big Data" ]?/grades )</screen>
</para>
</formalpara>
<simpara>Another alternative for enabling OOPath expression reactivity is to use the dedicated implementations for <literal>List</literal> and <literal>Set</literal> interfaces in Red Hat Decision Manager. These implementations are the <literal>ReactiveList</literal> and <literal>ReactiveSet</literal> classes. A <literal>ReactiveCollection</literal> class is also available. The implementations also provide reactive support for performing mutable operations through the <literal>Iterator</literal> and <literal>ListIterator</literal> classes.</simpara>
<simpara>The following example class uses these classes to configure OOPath expression reactivity:</simpara>
<formalpara>
<title>Example Java class to configure OOPath expression reactivity</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class School extends AbstractReactiveObject {
    private String name;
    private final List&lt;Child&gt; children = new ReactiveList&lt;Child&gt;(); <co xml:id="CO8-1"/>

    public void setName(String name) {
        this.name = name;
        notifyModification(); <co xml:id="CO8-2"/>
    }

    public void addChild(Child child) {
        children.add(child); <co xml:id="CO8-3"/>
        // No need to call `notifyModification()` here
    }
  }</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<para>Uses the <literal>ReactiveList</literal> instance for reactive support over the standard Java <literal>List</literal> instance.</para>
</callout>
<callout arearefs="CO8-2">
<para>Uses the required <literal>notifyModification()</literal> method for when a field is changed in reactive support.</para>
</callout>
<callout arearefs="CO8-3">
<para>The <literal>children</literal> field is a <literal>ReactiveList</literal> instance, so the <literal>notifyModification()</literal> method call is not required. The notification is handled automatically, like all other mutating operations performed over the <literal>children</literal> field.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="drl-rules-THEN-con_drl-rules">
<title>Rule actions in DRL (THEN)</title>
<simpara>The <literal>then</literal> part of the rule (also known as the <emphasis>Right Hand Side (RHS)</emphasis> of the rule) contains the actions to be performed when the conditional part of the rule has been met. Actions consist of one or more <emphasis>methods</emphasis> that execute consequences based on the rule conditions and on available data objects in the package. For example, if a bank requires loan applicants to have over 21 years of age (with a rule condition <literal>Applicant( age &lt; 21 )</literal>) and a loan applicant is under 21 years old, the <literal>then</literal> action of an <literal>"Underage"</literal> rule would be <literal>setApproved( false )</literal>, declining the loan because the applicant is under age.</simpara>
<simpara>The main purpose of rule actions is to to insert, delete, or modify data in the working memory of the decision engine. Effective rule actions are small, declarative, and readable. If you need to use imperative or conditional code in rule actions, then divide the rule into multiple smaller and more declarative rules.</simpara>
<formalpara>
<title>Example rule for loan application age limit</title>
<para>
<screen>rule "Underage"
  when
    application : LoanApplication()
    Applicant( age &lt; 21 )
  then
    application.setApproved( false );
    application.setExplanation( "Underage" );
end</screen>
</para>
</formalpara>
<section xml:id="drl-rules-THEN-methods-ref_drl-rules">
<title>Supported rule action methods in DRL</title>
<simpara>DRL supports the following rule action methods that you can use in DRL rule actions. You can use these methods to modify the working memory of the decision engine without having to first reference a working memory instance. These methods act as shortcuts to the methods provided by the <literal>KnowledgeHelper</literal> class in your Red Hat Decision Manager distribution.</simpara>
<simpara>For all rule action methods,
download the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> ZIP file from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> and navigate to <literal>~/rhdm-7.10.0-sources/src/drools-$VERSION/drools-core/src/main/java/org/drools/core/spi/KnowledgeHelper.java</literal>.</simpara>
<variablelist>
<varlistentry>
<term><literal>set</literal></term>
<listitem>
<simpara>Use this to set the value of a field.</simpara>
<screen>set&lt;field&gt; ( &lt;value&gt; )</screen>
<formalpara>
<title>Example rule action to set the values of a loan application approval</title>
<para>
<screen>$application.setApproved ( false );
$application.setExplanation( "has been bankrupt" );</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>modify</literal></term>
<listitem>
<simpara>Use this to specify fields to be modified for a fact and to notify the decision engine of the change. This method provides a structured approach to fact updates. It combines the <literal>update</literal> operation with setter calls to change object fields.</simpara>
<screen>modify ( &lt;fact-expression&gt; ) {
    &lt;expression&gt;,
    &lt;expression&gt;,
    ...
}</screen>
<formalpara>
<title>Example rule action to modify a loan application amount and approval</title>
<para>
<screen>modify( LoanApplication ) {
        setAmount( 100 ),
        setApproved ( true )
}</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>update</literal></term>
<listitem>
<simpara>Use this to specify fields and the entire related fact to be updated and to notify the decision engine of the change. After a fact has changed, you must call <literal>update</literal> before changing another fact that might be affected by the updated values. To avoid this added step, use the <literal>modify</literal> method instead.</simpara>
<screen>update ( &lt;object, &lt;handle&gt; )  // Informs the decision engine that an object has changed

update ( &lt;object&gt; )  // Causes `KieSession` to search for a fact handle of the object</screen>
<formalpara>
<title>Example rule action to update a loan application amount and approval</title>
<para>
<screen>LoanApplication.setAmount( 100 );
update( LoanApplication );</screen>
</para>
</formalpara>
<note>
<simpara>If you provide property-change listeners, you do not need to call this method when an object changes. For more information about property-change listeners, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#property-change-listeners-con_decision-engine"><emphasis>Decision engine in Red Hat Decision Manager</emphasis></link>.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>insert</literal></term>
<listitem>
<simpara>Use this to insert a <literal>new</literal> fact into the working memory of the decision engine and to define resulting fields and values as needed for the fact.</simpara>
<screen>insert( new &lt;object&gt; );</screen>
<formalpara>
<title>Example rule action to insert a new loan applicant object</title>
<para>
<screen>insert( new Applicant() );</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>insertLogical</literal></term>
<listitem>
<simpara>Use this to insert a <literal>new</literal> fact logically into the decision engine. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts must be retracted explicitly. After logical insertions, the facts that were inserted are automatically retracted when the conditions in the rules that inserted the facts are no longer true.</simpara>
<screen>insertLogical( new &lt;object&gt; );</screen>
<formalpara>
<title>Example rule action to logically insert a new loan applicant object</title>
<para>
<screen>insertLogical( new Applicant() );</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>delete</literal></term>
<listitem>
<simpara>Use this to remove an object from the decision engine. The keyword <literal>retract</literal> is also supported in DRL and executes the same action, but <literal>delete</literal> is typically preferred in DRL code for consistency with the keyword <literal>insert</literal>.</simpara>
<screen>delete( &lt;object&gt; );</screen>
<formalpara>
<title>Example rule action to delete a loan applicant object</title>
<para>
<screen>delete( Applicant );</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="drl-rules-THEN-methods-variables-ref_drl-rules">
<title>Other rule action methods from <literal>drools</literal> and <literal>kcontext</literal> variables</title>
<simpara>In addition to the standard rule action methods, the decision engine supports methods in conjunction with the predefined <literal>drools</literal> and <literal>kcontext</literal> variables that you can also use in rule actions.</simpara>
<simpara>You can use the <literal>drools</literal> variable to call methods from the <literal>KnowledgeHelper</literal> class in your Red Hat Decision Manager distribution, which is also the class that the standard rule action methods are based on. For all <literal>drools</literal> rule action options,
download the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> ZIP file from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> and navigate to <literal>~/rhdm-7.10.0-sources/src/drools-$VERSION/drools-core/src/main/java/org/drools/core/spi/KnowledgeHelper.java</literal>.</simpara>
<simpara>The following examples are common methods that you can use with the <literal>drools</literal> variable:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>drools.halt()</literal>: Terminates rule execution if a user or application has previously called <literal>fireUntilHalt()</literal>. When a user or application calls <literal>fireUntilHalt()</literal>, the decision engine starts in <emphasis>active mode</emphasis> and evaluates rules continually until the user or application explicitly calls <literal>halt()</literal>. Otherwise, by default, the decision engine runs in <emphasis>passive mode</emphasis> and evaluates rules only when a user or an application explicitly calls <literal>fireAllRules()</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.getWorkingMemory()</literal>: Returns the <literal>WorkingMemory</literal> object.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.setFocus( "&lt;agenda_group&gt;" )</literal>: Sets the focus to a specified agenda group to which the rule belongs.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.getRule().getName()</literal>: Returns the name of the rule.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.getTuple()</literal>, <literal>drools.getActivation()</literal>: Returns the <literal>Tuple</literal> that matches the currently executing rule and then delivers the corresponding <literal>Activation</literal>. These calls are useful for logging and debugging purposes.</simpara>
</listitem>
</itemizedlist>
<simpara>You can use the <literal>kcontext</literal> variable with the <literal>getKieRuntime()</literal> method to call other methods from the <literal>KieContext</literal> class and, by extension, the <literal>RuleContext</literal> class in your Red Hat Decision Manager distribution. The full Knowledge Runtime API is exposed through the <literal>kcontext</literal> variable and provides extensive rule action methods. For all <literal>kcontext</literal> rule action options,
download the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> ZIP file from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> and navigate to <literal>~/rhdm-7.10.0-sources/src/kie-api-parent-$VERSION/kie-api/src/main/java/org/kie/api/runtime/rule/RuleContext.java</literal>.</simpara>
<simpara>The following examples are common methods that you can use with the <literal>kcontext.getKieRuntime()</literal> variable-method combination:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kcontext.getKieRuntime().halt()</literal>: Terminates rule execution if a user or application has previously called <literal>fireUntilHalt()</literal>. This method is equivalent to the <literal>drools.halt()</literal> method. When a user or application calls <literal>fireUntilHalt()</literal>, the decision engine starts in <emphasis>active mode</emphasis> and evaluates rules continually until the user or application explicitly calls <literal>halt()</literal>. Otherwise, by default, the decision engine runs in <emphasis>passive mode</emphasis> and evaluates rules only when a user or an application explicitly calls <literal>fireAllRules()</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext.getKieRuntime().getAgenda()</literal>: Returns a reference to the KIE session <literal>Agenda</literal>, and in turn provides access to rule activation groups, rule agenda groups, and ruleflow groups.</simpara>
<formalpara>
<title>Example call to access agenda group "CleanUp" and set the focus</title>
<para>
<programlisting language="java" linenumbering="unnumbered">kcontext.getKieRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();</programlisting>
</para>
</formalpara>
<simpara>This example is equivalent to <literal>drools.setFocus( "CleanUp" )</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext.getKieRuntime().getQueryResults(&lt;string&gt; query)</literal>: Runs a query and returns the results. This method is equivalent to <literal>drools.getKieRuntime().getQueryResults()</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext.getKieRuntime().getKieBase()</literal>: Returns the <literal>KieBase</literal> object. The KIE base is the source of all the knowledge in your rule system and the originator of the current KIE session.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext.getKieRuntime().setGlobal()</literal>, <literal>~.getGlobal()</literal>, <literal>~.getGlobals()</literal>: Sets or retrieves global variables.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext.getKieRuntime().getEnvironment()</literal>: Returns the runtime <literal>Environment</literal>, similar to your operating system environment.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="drl-rules-THEN-advanced-con_drl-rules">
<title>Advanced rule actions with conditional and named consequences</title>
<simpara>In general, effective rule actions are small, declarative, and readable. However, in some cases, the limitation of having a single consequence for each rule can be challenging and lead to verbose and repetitive rule syntax, as shown in the following example rules:</simpara>
<formalpara>
<title>Example rules with verbose and repetitive syntax</title>
<para>
<screen>rule "Give 10% discount to customers older than 60"
  when
    $customer : Customer( age &gt; 60 )
  then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
  when
    $customer : Customer( age &gt; 60 )
    $car : Car( owner == $customer )
  then
    modify($car) { setFreeParking( true ) };
end</screen>
</para>
</formalpara>
<simpara>A partial solution to the repetition is to make the second rule extend the first rule, as shown in the following modified example:</simpara>
<formalpara>
<title>Partially enhanced example rules with an extended condition</title>
<para>
<screen>rule "Give 10% discount to customers older than 60"
  when
    $customer : Customer( age &gt; 60 )
  then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
    extends "Give 10% discount to customers older than 60"
  when
    $car : Car( owner == $customer )
  then
    modify($car) { setFreeParking( true ) };
end</screen>
</para>
</formalpara>
<simpara>As a more efficient alternative, you can consolidate the two rules into a single rule with modified conditions and labelled corresponding rule actions, as shown in the following consolidated example:</simpara>
<formalpara>
<title>Consolidated example rule with conditional and named consequences</title>
<para>
<screen>rule "Give 10% discount and free parking to customers older than 60"
  when
    $customer : Customer( age &gt; 60 )
    do[giveDiscount]
    $car : Car( owner == $customer )
  then
    modify($car) { setFreeParking( true ) };
  then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</screen>
</para>
</formalpara>
<simpara>This example rule uses two actions: the usual default action and another action named <literal>giveDiscount</literal>. The <literal>giveDiscount</literal> action is activated in the condition with the keyword <literal>do</literal> when a customer older than 60 years old is found in the KIE base, regardless of whether or not the customer owns a car.</simpara>
<simpara>You can configure the activation of a named consequence with an additional condition, such as the <literal>if</literal> statement in the following example. The condition in the <literal>if</literal> statement is always evaluated on the pattern that immediately precedes it.</simpara>
<formalpara>
<title>Consolidated example rule with an additional condition</title>
<para>
<screen>rule "Give free parking to customers older than 60 and 10% discount to golden ones among them"
  when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount]
    $car : Car( owner == $customer )
  then
    modify($car) { setFreeParking( true ) };
  then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end</screen>
</para>
</formalpara>
<simpara>You can also evaluate different rule conditions using a nested <literal>if</literal> and <literal>else if</literal> construct, as shown in the following more complex example:</simpara>
<formalpara>
<title>Consolidated example rule with more complex conditions</title>
<para>
<screen>rule "Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones"
  when
    $customer : Customer( age &gt; 60 )
    if ( type == "Golden" ) do[giveDiscount10]
    else if ( type == "Silver" ) break[giveDiscount5]
    $car : Car( owner == $customer )
  then
    modify($car) { setFreeParking( true ) };
  then[giveDiscount10]
    modify($customer) { setDiscount( 0.1 ) };
  then[giveDiscount5]
    modify($customer) { setDiscount( 0.05 ) };
end</screen>
</para>
</formalpara>
<simpara>This example rule gives a 10% discount and free parking to Golden customers over 60, but only a 5% discount without free parking to Silver customers. The rule activates the consequence named <literal>giveDiscount5</literal> with the keyword <literal>break</literal> instead of <literal>do</literal>. The keyword <literal>do</literal> schedules a consequence in the decision engine agenda, enabling the remaining part of the rule conditions to continue being evaluated, while <literal>break</literal> blocks any further condition evaluation. If a named consequence does not correspond to any condition with <literal>do</literal> but is activated with <literal>break</literal>, the rule fails to compile because the conditional part of the rule is never reached.</simpara>
</section>
</section>
<section xml:id="drl-rules-comments-con_drl-rules">
<title>Comments in DRL files</title>
<simpara>DRL supports single-line comments prefixed with a double forward slash <literal>//</literal> and multi-line comments enclosed with a forward slash and asterisk <literal>/* …​ */</literal>. You can use DRL comments to annotate rules or any related components in DRL files. DRL comments are ignored by the decision engine when the DRL file is processed.</simpara>
<formalpara>
<title>Example rule with comments</title>
<para>
<screen>rule "Underage"
  // This is a single-line comment.
  when
    $application : LoanApplication()  // This is an in-line comment.
    Applicant( age &lt; 21 )
  then
    /* This is a multi-line comment
    in the rule actions. */
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end</screen>
</para>
</formalpara>
<important>
<simpara>The hash symbol <literal>#</literal> is not supported for DRL comments.</simpara>
</important>
</section>
<section xml:id="drl-rules-errors-ref_drl-rules">
<title>Error messages for DRL troubleshooting</title>
<simpara>Red Hat Decision Manager provides standardized messages for DRL errors to help you troubleshoot and resolve problems in your DRL files. The error messages use the following format:</simpara>
<figure>
<title>Error message format for DRL file problems</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/LanguageReference/error_message.png" align="center"/>
</imageobject>
<textobject><phrase>error message</phrase></textobject>
</mediaobject>
</figure>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">1st Block:</emphasis> Error code</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">2nd Block:</emphasis> Line and column in the DRL source where the error occurred</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">3rd Block:</emphasis> Description of the problem</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">4th Block:</emphasis> Component in the DRL source (rule, function, query) where the error occurred</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">5th Block:</emphasis> Pattern in the DRL source where the error occurred (if applicable)</simpara>
</listitem>
</itemizedlist>
<simpara>Red Hat Decision Manager supports the following standardized error messages:</simpara>
<variablelist>
<varlistentry>
<term>101: no viable alternative</term>
<listitem>
<simpara>Indicates that the parser reached a decision point but could not identify an alternative.</simpara>
<formalpara>
<title>Example rule with incorrect spelling</title>
<para>
<screen>1: rule "simple rule"
2:   when
3:     exists Person()
4:     exits Student()  // Must be `exists`
5:   then
6: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 101] Line 4:4 no viable alternative at input 'exits' in rule "simple rule"</screen>
</para>
</formalpara>
<formalpara>
<title>Example rule without a rule name</title>
<para>
<screen>1: package org.drools.examples;
2: rule    // Must be `rule "rule name"` (or `rule rule_name` if no spacing)
3:   when
4:     Object()
5:   then
6:     System.out.println("A RHS");
7: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 101] Line 3:2 no viable alternative at input 'when'</screen>
</para>
</formalpara>
<simpara>In this example, the parser encountered the keyword <literal>when</literal> but expected the rule name, so it flags <literal>when</literal> as the incorrect expected token.</simpara>
<formalpara>
<title>Example rule with incorrect syntax</title>
<para>
<screen>1: rule "simple rule"
2:   when
3:     Student( name == "Andy )  // Must be `"Andy"`
4:   then
5: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 101] Line 0:-1 no viable alternative at input '&lt;eof&gt;' in rule "simple rule" in pattern Student</screen>
</para>
</formalpara>
<note>
<simpara>A line and column value of <literal>0:-1</literal> means the parser reached the end of the source file (<literal>&lt;eof&gt;</literal>) but encountered incomplete constructs, usually due to missing quotation marks <literal>"…​"</literal>, apostrophes <literal>'…​'</literal>, or parentheses <literal>(…​)</literal>.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term>102: mismatched input</term>
<listitem>
<simpara>Indicates that the parser expected a particular symbol that is missing at the current input position.</simpara>
<formalpara>
<title>Example rule with an incomplete rule statement</title>
<para>
<screen>1: rule simple_rule
2:   when
3:     $p : Person(
        // Must be a complete rule statement</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 102] Line 0:-1 mismatched input '&lt;eof&gt;' expecting ')' in rule "simple rule" in pattern Person</screen>
</para>
</formalpara>
<note>
<simpara>A line and column value of <literal>0:-1</literal> means the parser reached the end of the source file (<literal>&lt;eof&gt;</literal>) but encountered incomplete constructs, usually due to missing quotation marks <literal>"…​"</literal>, apostrophes <literal>'…​'</literal>, or parentheses <literal>(…​)</literal>.</simpara>
</note>
<formalpara>
<title>Example rule with incorrect syntax</title>
<para>
<screen>1: package org.drools.examples;
2:
3: rule "Wrong syntax"
4:   when
5:     not( Car( ( type == "tesla", price == 10000 ) || ( type == "kia", price == 1000 ) ) from $carList )
       // Must use `&amp;&amp;` operators instead of commas `,`
6:   then
7:     System.out.println("OK");
8: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error messages</title>
<para>
<screen>[ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule "Wrong syntax" in pattern Car
[ERR 101] Line 5:57 no viable alternative at input 'type' in rule "Wrong syntax"
[ERR 102] Line 5:106 mismatched input ')' expecting 'then' in rule "Wrong syntax"</screen>
</para>
</formalpara>
<simpara>In this example, the syntactic problem results in multiple error messages related to each other. The single solution of replacing the commas <literal>,</literal> with <literal>&amp;&amp;</literal> operators resolves all errors. If you encounter multiple errors, resolve one at a time in case errors are consequences of previous errors.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>103: failed predicate</term>
<listitem>
<simpara>Indicates that a validating semantic predicate evaluated to <literal>false</literal>. These semantic predicates are typically used to identify component keywords in DRL files, such as <literal>declare</literal>, <literal>rule</literal>, <literal>exists</literal>, <literal>not</literal>, and others.</simpara>
<formalpara>
<title>Example rule with an invalid keyword</title>
<para>
<screen> 1: package nesting;
 2:
 3: import org.drools.compiler.Person
 4: import org.drools.compiler.Address
 5:
 6: Some text  // Must be a valid DRL keyword
 7:
 8: rule "test something"
 9:   when
10:     $p: Person( name=="Michael" )
11:   then
12:     $p.name = "other";
13:     System.out.println(p.name);
14: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 103] Line 6:0 rule 'rule_key' failed predicate: {(validateIdentifierKey(DroolsSoftKeywords.RULE))}? in rule</screen>
</para>
</formalpara>
<simpara>The <literal>Some text</literal> line is invalid because it does not begin with or is not a part of a DRL keyword construct, so the parser fails to validate the rest of the DRL file.</simpara>
<note>
<simpara>This error is similar to <literal>102: mismatched input</literal>, but usually involves DRL keywords.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term>104: trailing semi-colon not allowed</term>
<listitem>
<simpara>Indicates that an <literal>eval()</literal> clause in a rule condition uses a semicolon <literal>;</literal> but must not use one.</simpara>
<formalpara>
<title>Example rule with <literal>eval()</literal> and trailing semicolon</title>
<para>
<screen>1: rule "simple rule"
2:   when
3:     eval( abc(); )  // Must not use semicolon `;`
4:   then
5: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 104] Line 3:4 trailing semi-colon not allowed in rule "simple rule"</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>105: did not match anything</term>
<listitem>
<simpara>Indicates that the parser reached a sub-rule in the grammar that must match an alternative at least once, but the sub-rule did not match anything. The parser has entered a branch with no way out.</simpara>
<formalpara>
<title>Example rule with invalid text in an empty condition</title>
<para>
<screen>1: rule "empty condition"
2:   when
3:     None  // Must remove `None` if condition is empty
4:   then
5:      insert( new Person() );
6: end</screen>
</para>
</formalpara>
<formalpara>
<title>Error message</title>
<para>
<screen>[ERR 105] Line 2:2 required (...)+ loop did not match anything at input 'WHEN' in rule "empty condition"</screen>
</para>
</formalpara>
<simpara>In this example, the condition is intended to be empty but the word <literal>None</literal> is used. This error is resolved by removing <literal>None</literal>, which is not a valid DRL keyword, data type, or pattern construct.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>If you encounter other DRL error messages that you cannot resolve, contact your Red Hat Technical Account Manager.</simpara>
</note>
</section>
<section xml:id="drl-rule-units-con_drl-rules">
<title>Rule units in DRL rule sets</title>
<simpara>Rule units are groups of data sources, global variables, and DRL rules that function together for a specific purpose. You can use rule units to partition a rule set into smaller units, bind different data sources to those units, and then execute the individual unit. Rule units are an enhanced alternative to rule-grouping DRL attributes such as rule agenda groups or activation groups for execution control.</simpara>
<simpara>Rule units are helpful when you want to coordinate rule execution so that the complete execution of one rule unit triggers the start of another rule unit and so on. For example, assume that you have a set of rules for data enrichment, another set of rules that processes that data, and another set of rules that extract the output from the processed data. If you add these rule sets into three distinct rule units, you can coordinate those rule units so that complete execution of the first unit triggers the start of the second unit and the complete execution of the second unit triggers the start of third unit.</simpara>
<simpara>To define a rule unit, implement the <literal>RuleUnit</literal> interface as shown in the following example:</simpara>
<formalpara>
<title>Example rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.mypackage.myunit;

public static class AdultUnit implements RuleUnit {
    private int adultAge;
    private DataSource&lt;Person&gt; persons;

    public AdultUnit( ) { }

    public AdultUnit( DataSource&lt;Person&gt; persons, int age ) {
        this.persons = persons;
        this.age = age;
    }

    // A data source of `Persons` in this rule unit:
    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    // A global variable in this rule unit:
    public int getAdultAge() {
        return adultAge;
    }

    // Life-cycle methods:
    @Override
    public void onStart() {
        System.out.println("AdultUnit started.");
    }

    @Override
    public void onEnd() {
        System.out.println("AdultUnit ended.");
    }
}</programlisting>
</para>
</formalpara>
<simpara>In this example, <literal>persons</literal> is a source of facts of type <literal>Person</literal>. A rule unit data source is a source of the data processed by a given rule unit and represents the entry point that the decision engine uses to evaluate the rule unit. The <literal>adultAge</literal> global variable is accessible from all the rules belonging to this rule unit. The last two methods are part of the rule unit life cycle and are invoked by the decision engine.</simpara>
<simpara>The decision engine supports the following optional life-cycle methods for rule units:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Rule unit life-cycle methods</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Method</entry>
<entry align="left" valign="top">Invoked when</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>onStart()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution starts</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onEnd()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution ends</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onSuspend()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution is suspended (used only with <literal>runUntilHalt()</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onResume()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution is resumed (used only with <literal>runUntilHalt()</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onYield(RuleUnit other)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The consequence of a rule in the rule unit triggers the execution of a different rule unit</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can add one or more rules to a rule unit. By default, all the rules in a DRL file are automatically associated with a rule unit that follows the naming convention of the DRL file name. If the DRL file is in the same package and has the same name as a class that implements the <literal>RuleUnit</literal> interface, then all of the rules in that DRL file implicitly belong to that rule unit. For example, all the rules in the <literal>AdultUnit.drl</literal> file in the <literal>org.mypackage.myunit</literal> package are automatically part of the rule unit <literal>org.mypackage.myunit.AdultUnit</literal>.</simpara>
<simpara>To override this naming convention and explicitly declare the rule unit that the rules in a DRL file belong to, use the <literal>unit</literal> keyword in the DRL file. The <literal>unit</literal> declaration must immediately follow the package declaration and contain the name of the class in that package that the rules in the DRL file are part of.</simpara>
<formalpara>
<title>Example rule unit declaration in a DRL file</title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    $p : Person(age &gt;= adultAge) from persons
  then
    System.out.println($p.getName() + " is adult and greater than " + adultAge);
end</screen>
</para>
</formalpara>
<warning>
<simpara>Do not mix rules with and without a rule unit in the same KIE base. Mixing two rule paradigms in a KIE base results in a compilation error.</simpara>
</warning>
<simpara>You can also rewrite the same pattern in a more convenient way using OOPath notation, as shown in the following example:</simpara>
<formalpara>
<title>Example rule unit declaration in a DRL file that uses OOPath notation</title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    $p : /persons[age &gt;= adultAge]
  then
    System.out.println($p.getName() + " is adult and greater than " + adultAge);
end</screen>
</para>
</formalpara>
<note>
<simpara>OOPath is an object-oriented syntax extension of XPath that is designed for browsing graphs of objects in DRL rule condition constraints. OOPath uses the compact notation from XPath for navigating through related elements while handling collections and filtering constraints, and is specifically useful for graphs of objects.</simpara>
</note>
<simpara>In this example, any matching facts in the rule conditions are retrieved from the <literal>persons</literal> data source defined in the <literal>DataSource</literal> definition in the rule unit class. The rule condition and action use the <literal>adultAge</literal> variable in the same way that a global variable is defined at the DRL file level.</simpara>
<simpara>To execute one or more rule units defined in a KIE base, create a new <literal>RuleUnitExecutor</literal> class bound to the KIE base, create the rule unit from the relevant data source, and run the rule unit executer:</simpara>
<formalpara>
<title>Example rule unit execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Create a `RuleUnitExecutor` class and bind it to the KIE base:
KieBase kbase = kieContainer.getKieBase();
RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );

// Create the `AdultUnit` rule unit using the `persons` data source and run the executor:
RuleUnit adultUnit = new AdultUnit(persons, 18);
executor.run( adultUnit );</programlisting>
</para>
</formalpara>
<simpara>Rules are executed by the <literal>RuleUnitExecutor</literal> class. The <literal>RuleUnitExecutor</literal> class creates KIE sessions and adds the required <literal>DataSource</literal> objects to those sessions, and then executes the rules based on the <literal>RuleUnit</literal> that is passed as a parameter to the <literal>run()</literal> method.</simpara>
<simpara>The example execution code produces the following output when the relevant <literal>Person</literal> facts are inserted in the <literal>persons</literal> data source:</simpara>
<formalpara>
<title>Example rule unit execution output</title>
<para>
<screen>org.mypackage.myunit.AdultUnit started.
Jane is adult and greater than 18
John is adult and greater than 18
org.mypackage.myunit.AdultUnit ended.</screen>
</para>
</formalpara>
<simpara>Instead of explicitly creating the rule unit instance, you can register the rule unit variables in the executor and pass to the executor the rule unit class that you want to run, and then the executor creates an instance of the rule unit. You can then set the <literal>DataSource</literal> definition and other variables as needed before running the rule unit.</simpara>
<formalpara>
<title>Alternate rule unit execution option with registered variables</title>
<para>
<programlisting language="java" linenumbering="unnumbered">executor.bindVariable( "persons", persons );
        .bindVariable( "adultAge", 18 );
executor.run( AdultUnit.class );</programlisting>
</para>
</formalpara>
<simpara>The name that you pass to the <literal>RuleUnitExecutor.bindVariable()</literal> method is used at run time to bind the variable to the field of the rule unit class with the same name. In the previous example, the <literal>RuleUnitExecutor</literal> inserts into the new rule unit the data source bound to the <literal>"persons"</literal> name and inserts the value <literal>18</literal> bound to the String <literal>"adultAge"</literal> into the fields with the corresponding names inside the <literal>AdultUnit</literal> class.</simpara>
<simpara>To override this default variable-binding behavior, use the <literal>@UnitVar</literal> annotation to explicitly define a logical binding name for each field of the rule unit class. For example, the field bindings in the following class are redefined with alternative names:</simpara>
<formalpara>
<title>Example code to modify variable binding names with <literal>@UnitVar</literal></title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.mypackage.myunit;

public static class AdultUnit implements RuleUnit {
    @UnitVar("minAge")
    private int adultAge = 18;

    @UnitVar("data")
    private DataSource&lt;Person&gt; persons;
}</programlisting>
</para>
</formalpara>
<simpara>You can then bind the variables to the executor using those alternative names and run the rule unit:</simpara>
<formalpara>
<title>Example rule unit execution with modified variable names</title>
<para>
<programlisting language="java" linenumbering="unnumbered">executor.bindVariable( "data", persons );
        .bindVariable( "minAge", 18 );
executor.run( AdultUnit.class );</programlisting>
</para>
</formalpara>
<simpara>You can execute a rule unit in <emphasis>passive mode</emphasis> by using the <literal>run()</literal> method (equivalent to invoking <literal>fireAllRules()</literal> on a KIE session)
or in <emphasis>active mode</emphasis> using the <literal>runUntilHalt()</literal> method (equivalent to invoking <literal>fireUntilHalt()</literal> on a KIE session). By default, the decision engine runs in <emphasis>passive mode</emphasis> and evaluates rule units only when a user or an application explicitly calls <literal>run()</literal> (or <literal>fireAllRules()</literal> for standard rules). If a user or application calls <literal>runUntilHalt()</literal> for rule units (or <literal>fireUntilHalt()</literal> for standard rules), the decision engine starts in <emphasis>active mode</emphasis> and evaluates rule units continually until the user or application explicitly calls <literal>halt()</literal>.</simpara>
<simpara>If you use the <literal>runUntilHalt()</literal> method, invoke the method on a separate execution thread to avoid blocking the main thread:</simpara>
<formalpara>
<title>Example rule unit execution with <literal>runUntilHalt()</literal> on a separate thread</title>
<para>
<programlisting language="java" linenumbering="unnumbered">new Thread( () -&gt; executor.runUntilHalt( adultUnit ) ).start();</programlisting>
</para>
</formalpara>
<section xml:id="data_sources_for_rule_units" remap="_data_sources_for_rule_units">
<title>Data sources for rule units</title>
<simpara>A rule unit data source is a source of the data processed by a given rule unit and represents the entry point that the decision engine uses to evaluate the rule unit. A rule unit can have zero or more data sources and each <literal>DataSource</literal> definition declared inside a rule unit can correspond to a different entry point into the rule unit executor. Multiple rule units can share a single data source, but each rule unit must use different entry points through which the same objects are inserted.</simpara>
<simpara>You can create a <literal>DataSource</literal> definition with a fixed set of data in a rule unit class, as shown in the following example:</simpara>
<formalpara>
<title>Example data source definition</title>
<para>
<programlisting language="java" linenumbering="unnumbered">DataSource&lt;Person&gt; persons = DataSource.create( new Person( "John", 42 ),
                                                new Person( "Jane", 44 ),
                                                new Person( "Sally", 4 ) );</programlisting>
</para>
</formalpara>
<simpara>Because a data source represents the entry point of the rule unit, you can insert, update, or delete facts in a rule unit:</simpara>
<formalpara>
<title>Example code to insert, modify, and delete a fact in a rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Insert a fact:
Person john = new Person( "John", 42 );
FactHandle johnFh = persons.insert( john );

// Modify the fact and optionally specify modified properties (for property reactivity):
john.setAge( 43 );
persons.update( johnFh, john, "age" );

// Delete the fact:
persons.delete( johnFh );</programlisting>
</para>
</formalpara>
</section>
<section xml:id="rule_unit_execution_control" remap="_rule_unit_execution_control">
<title>Rule unit execution control</title>
<simpara>Rule units are helpful when you want to coordinate rule execution so that the execution of one rule unit triggers the start of another rule unit and so on.</simpara>
<simpara>To facilitate rule unit execution control, the decision engine supports the following rule unit methods that you can use in DRL rule actions to coordinate the execution of rule units:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>drools.run()</literal>: Triggers the execution of a specified rule unit class. This method imperatively interrupts the execution of the rule unit and activates the other specified rule unit.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.guard()</literal>: Prevents (guards) a specified rule unit class from being executed until the associated rule condition is met. This method declaratively schedules the execution of the other specified rule unit. When the decision engine produces at least one match for the condition in the guarding rule, the guarded rule unit is considered active. A rule unit can contain multiple guarding rules.</simpara>
</listitem>
</itemizedlist>
<simpara>As an example of the <literal>drools.run()</literal> method, consider the following DRL rules that each belong to a specified rule unit. The <literal>NotAdult</literal> rule uses the <literal>drools.run( AdultUnit.class )</literal> method to trigger the execution of the <literal>AdultUnit</literal> rule unit:</simpara>
<formalpara>
<title>Example DRL rules with controlled execution using <literal>drools.run()</literal></title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    Person(age &gt;= 18, $name : name) from persons
  then
    System.out.println($name + " is adult");
end</screen>
</para>
</formalpara>
<screen>package org.mypackage.myunit
unit NotAdultUnit

rule NotAdult
  when
    $p : Person(age &lt; 18, $name : name) from persons
  then
    System.out.println($name + " is NOT adult");
    modify($p) { setAge(18); }
    drools.run( AdultUnit.class );
end</screen>
<simpara>The example also uses a <literal>RuleUnitExecutor</literal> class created from the KIE base that was built from these rules and a <literal>DataSource</literal> definition of <literal>persons</literal> bound to it:</simpara>
<formalpara>
<title>Example rule executor and data source definitions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );
DataSource&lt;Person&gt; persons = executor.newDataSource( "persons",
                                                     new Person( "John", 42 ),
                                                     new Person( "Jane", 44 ),
                                                     new Person( "Sally", 4 ) );</programlisting>
</para>
</formalpara>
<simpara>In this case, the example creates the <literal>DataSource</literal> definition directly from the <literal>RuleUnitExecutor</literal> class and binds it to the <literal>"persons"</literal> variable in a single statement.</simpara>
<simpara>The example execution code produces the following output when the relevant <literal>Person</literal> facts are inserted in the <literal>persons</literal> data source:</simpara>
<formalpara>
<title>Example rule unit execution output</title>
<para>
<screen>Sally is NOT adult
John is adult
Jane is adult
Sally is adult</screen>
</para>
</formalpara>
<simpara>The <literal>NotAdult</literal> rule detects a match when evaluating the person <literal>"Sally"</literal>, who is under 18 years old. The rule then modifies
her age to <literal>18</literal> and uses the <literal>drools.run( AdultUnit.class )</literal> method to trigger the execution of the <literal>AdultUnit</literal> rule unit. The <literal>AdultUnit</literal> rule unit contains a rule that can now be executed for all of the 3 <literal>persons</literal> in the <literal>DataSource</literal> definition.</simpara>
<simpara>As an example of the <literal>drools.guard()</literal> method, consider the following <literal>BoxOffice</literal> class and <literal>BoxOfficeUnit</literal> rule unit class:</simpara>
<formalpara>
<title>Example <literal>BoxOffice</literal> class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class BoxOffice {
    private boolean open;

    public BoxOffice( boolean open ) {
        this.open = open;
    }

    public boolean isOpen() {
        return open;
    }

    public void setOpen( boolean open ) {
        this.open = open;
    }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>BoxOfficeUnit</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class BoxOfficeUnit implements RuleUnit {
    private DataSource&lt;BoxOffice&gt; boxOffices;

    public DataSource&lt;BoxOffice&gt; getBoxOffices() {
        return boxOffices;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The example also uses the following <literal>TicketIssuerUnit</literal> rule unit class to keep selling box office tickets for the event as long as at least one box office is open. This rule unit uses <literal>DataSource</literal> definitions of <literal>persons</literal> and <literal>tickets</literal>:</simpara>
<formalpara>
<title>Example <literal>TicketIssuerUnit</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class TicketIssuerUnit implements RuleUnit {
    private DataSource&lt;Person&gt; persons;
    private DataSource&lt;AdultTicket&gt; tickets;

    private List&lt;String&gt; results;

    public TicketIssuerUnit() { }

    public TicketIssuerUnit( DataSource&lt;Person&gt; persons, DataSource&lt;AdultTicket&gt; tickets ) {
        this.persons = persons;
        this.tickets = tickets;
    }

    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    public DataSource&lt;AdultTicket&gt; getTickets() {
        return tickets;
    }

    public List&lt;String&gt; getResults() {
        return results;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>BoxOfficeUnit</literal> rule unit contains a <literal>BoxOfficeIsOpen</literal> DRL rule that uses the <literal>drools.guard( TicketIssuerUnit.class )</literal> method to guard the execution of the <literal>TicketIssuerUnit</literal> rule unit that distributes the event tickets, as shown in the following DRL rule examples:</simpara>
<formalpara>
<title>Example DRL rules with controlled execution using <literal>drools.guard()</literal></title>
<para>
<screen>package org.mypackage.myunit;
unit TicketIssuerUnit;

rule IssueAdultTicket when
    $p: /persons[ age &gt;= 18 ]
then
    tickets.insert(new AdultTicket($p));
end
rule RegisterAdultTicket when
    $t: /tickets
then
    results.add( $t.getPerson().getName() );
end</screen>
</para>
</formalpara>
<screen>package org.mypackage.myunit;
unit BoxOfficeUnit;

rule BoxOfficeIsOpen
  when
    $box: /boxOffices[ open ]
  then
    drools.guard( TicketIssuerUnit.class );
end</screen>
<simpara>In this example, so long as at least one box office is <literal>open</literal>, the guarded <literal>TicketIssuerUnit</literal> rule unit is active and distributes event tickets. When no more box offices are in <literal>open</literal> state, the guarded <literal>TicketIssuerUnit</literal> rule unit is prevented from being executed.</simpara>
<simpara>The following example class illustrates a more complete box office scenario:</simpara>
<formalpara>
<title>Example class for the box office scenario</title>
<para>
<programlisting language="java" linenumbering="unnumbered">DataSource&lt;Person&gt; persons = executor.newDataSource( "persons" );
DataSource&lt;BoxOffice&gt; boxOffices = executor.newDataSource( "boxOffices" );
DataSource&lt;AdultTicket&gt; tickets = executor.newDataSource( "tickets" );

List&lt;String&gt; list = new ArrayList&lt;&gt;();
executor.bindVariable( "results", list );

// Two box offices are open:
BoxOffice office1 = new BoxOffice(true);
FactHandle officeFH1 = boxOffices.insert( office1 );
BoxOffice office2 = new BoxOffice(true);
FactHandle officeFH2 = boxOffices.insert( office2 );

persons.insert(new Person("John", 40));

// Execute `BoxOfficeIsOpen` rule, run `TicketIssuerUnit` rule unit, and execute `RegisterAdultTicket` rule:
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "John", list.get(0) );
list.clear();

persons.insert(new Person("Matteo", 30));

// Execute `RegisterAdultTicket` rule:
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "Matteo", list.get(0) );
list.clear();

// One box office is closed, the other is open:
office1.setOpen(false);
boxOffices.update(officeFH1, office1);
persons.insert(new Person("Mark", 35));
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "Mark", list.get(0) );
list.clear();

// All box offices are closed:
office2.setOpen(false);
boxOffices.update(officeFH2, office2); // Guarding rule is no longer true.
persons.insert(new Person("Edson", 35));
executor.run(BoxOfficeUnit.class); // No execution

assertEquals( 0, list.size() );</programlisting>
</para>
</formalpara>
</section>
<section xml:id="rule_unit_identity_conflicts" remap="_rule_unit_identity_conflicts">
<title>Rule unit identity conflicts</title>
<simpara>In rule unit execution scenarios with guarded rule units, a rule can guard multiple rule units and at the same time a rule unit can be guarded and then activated by multiple rules. For these two-way guarding scenarios, rule units must have a clearly defined identity to avoid identity conflicts.</simpara>
<simpara>By default, the identity of a rule unit is the rule unit class name and is treated as a singleton class by the <literal>RuleUnitExecutor</literal>. This identification behavior is encoded in the <literal>getUnitIdentity()</literal> default method of the <literal>RuleUnit</literal> interface:</simpara>
<formalpara>
<title>Default identity method in the <literal>RuleUnit</literal> interface</title>
<para>
<programlisting language="java" linenumbering="unnumbered">default Identity getUnitIdentity() {
    return new Identity( getClass() );
}</programlisting>
</para>
</formalpara>
<simpara>In some cases, you may need to override this default identification behavior to avoid conflicting identities between rule units.</simpara>
<simpara>For example, the following <literal>RuleUnit</literal> class contains a <literal>DataSource</literal> definition that accepts any kind of object:</simpara>
<formalpara>
<title>Example <literal>Unit0</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Unit0 implements RuleUnit {
    private DataSource&lt;Object&gt; input;

    public DataSource&lt;Object&gt; getInput() {
        return input;
    }
}</programlisting>
</para>
</formalpara>
<simpara>This rule unit contains the following DRL rule that guards another rule unit based on two conditions (in OOPath notation):</simpara>
<formalpara>
<title>Example <literal>GuardAgeCheck</literal> DRL rule in the rule unit</title>
<para>
<screen>package org.mypackage.myunit
unit Unit0

rule GuardAgeCheck
  when
    $i: /input#Integer
    $s: /input#String
  then
    drools.guard( new AgeCheckUnit($i) );
    drools.guard( new AgeCheckUnit($s.length()) );
end</screen>
</para>
</formalpara>
<simpara>The guarded <literal>AgeCheckUnit</literal> rule unit verifies the age of a set of <literal>persons</literal>. The <literal>AgeCheckUnit</literal> contains a <literal>DataSource</literal> definition of the <literal>persons</literal> to check, a <literal>minAge</literal> variable that it verifies against, and a <literal>List</literal> for gathering the results:</simpara>
<formalpara>
<title>Example <literal>AgeCheckUnit</literal> rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class AgeCheckUnit implements RuleUnit {
    private final int minAge;
    private DataSource&lt;Person&gt; persons;
    private List&lt;String&gt; results;

    public AgeCheckUnit( int minAge ) {
        this.minAge = minAge;
    }

    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    public int getMinAge() {
        return minAge;
    }

    public List&lt;String&gt; getResults() {
        return results;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>AgeCheckUnit</literal> rule unit contains the following DRL rule that performs the verification of the <literal>persons</literal> in the data source:</simpara>
<formalpara>
<title>Example <literal>CheckAge</literal> DRL rule in the rule unit</title>
<para>
<screen>package org.mypackage.myunit
unit AgeCheckUnit

rule CheckAge
  when
    $p : /persons{ age &gt; minAge }
  then
    results.add($p.getName() + "&gt;" + minAge);
end</screen>
</para>
</formalpara>
<simpara>This example creates a <literal>RuleUnitExecutor</literal> class, binds the class to the KIE base that contains these two rule units, and creates
the two <literal>DataSource</literal> definitions for the same rule units:</simpara>
<formalpara>
<title>Example executor and data source definitions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );

DataSource&lt;Object&gt; input = executor.newDataSource( "input" );
DataSource&lt;Person&gt; persons = executor.newDataSource( "persons",
                                                     new Person( "John", 42 ),
                                                     new Person( "Sally", 4 ) );

List&lt;String&gt; results = new ArrayList&lt;&gt;();
executor.bindVariable( "results", results );</programlisting>
</para>
</formalpara>
<simpara>You can now insert some objects into the input data source and execute the <literal>Unit0</literal> rule unit:</simpara>
<formalpara>
<title>Example rule unit execution with inserted objects</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ds.insert("test");
ds.insert(3);
ds.insert(4);
executor.run(Unit0.class);</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example results list from the execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">[Sally&gt;3, John&gt;3]</programlisting>
</para>
</formalpara>
<simpara>In this example, the rule unit named <literal>AgeCheckUnit</literal> is considered a singleton class and then executed only once, with the <literal>minAge</literal>
variable set to <literal>3</literal>. Both the String <literal>"test"</literal> and the Integer <literal>4</literal> inserted into the input data source can also trigger a second execution with the <literal>minAge</literal> variable set to <literal>4</literal>. However, the second execution does not occur because another rule unit with the same identity has already been evaluated.</simpara>
<simpara>To resolve this rule unit identity conflict, override the <literal>getUnitIdentity()</literal> method in the <literal>AgeCheckUnit</literal> class to include also the <literal>minAge</literal> variable in the rule unit identity:</simpara>
<formalpara>
<title>Modified <literal>AgeCheckUnit</literal> rule unit to override the <literal>getUnitIdentity()</literal> method</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class AgeCheckUnit implements RuleUnit {

    ...

    @Override
    public Identity getUnitIdentity() {
        return new Identity(getClass(), minAge);
    }
}</programlisting>
</para>
</formalpara>
<simpara>With this override in place, the previous example rule unit execution produces the following output:</simpara>
<formalpara>
<title>Example results list from executing the modified rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">[John&gt;4, Sally&gt;3, John&gt;3]</programlisting>
</para>
</formalpara>
<simpara>The rule units with <literal>minAge</literal> set to <literal>3</literal> and <literal>4</literal> are now considered two different rule units and both are executed.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="data-objects-con_drl-rules">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_drl-rules">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="drl-rules-central-create-proc">
<title>Creating DRL rules in Business Central</title>
<simpara>You can create and manage DRL rules for your project in Business Central. In each DRL rule file, you define rule conditions, actions, and other components related to the rule, based on the data objects you create or import in the package.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">DRL file</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">DRL file</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects have been assigned or will be assigned.</simpara>
<simpara>You can also select <emphasis role="strong">Show declared DSL sentences</emphasis> if any domain specific language (DSL) assets have been defined in your project. These DSL assets will then become usable objects for conditions and actions that you define in the DRL designer.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the rule asset.</simpara>
<simpara>The new DRL file is now listed in the <emphasis role="strong">DRL</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>, or in the <emphasis role="strong">DSLR</emphasis> panel if you selected the <emphasis role="strong">Show declared DSL sentences</emphasis> option. The package to which you assigned this DRL file is listed at the top of the file.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Fact types</emphasis> list in the left panel of the DRL designer, confirm that all data objects and data object fields (expand each) required for your rules are listed. If not, you can either import relevant data objects from other packages by using <literal>import</literal> statements in the DRL file, or
<link linkend="data-objects-create-proc_drl-rules">create data objects</link>
within your package.</simpara>
</listitem>
<listitem>
<simpara>After all data objects are in place, return to the <emphasis role="strong">Model</emphasis> tab of the DRL designer and define the DRL file with any of the following components:</simpara>
<formalpara>
<title>Components in a DRL file</title>
<para>
<screen>package

import

function  // Optional

query  // Optional

declare   // Optional

global   // Optional

rule "rule name"
    // Attributes
    when
        // Conditions
    then
        // Actions
end

rule "rule2 name"

...</screen>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>package</literal>: (automatic) This was defined for you when you created the DRL file and selected the package.</simpara>
</listitem>
<listitem>
<simpara><literal>import</literal>: Use this to identify the data objects from either this package or another package that you want to use in the DRL file. Specify the package and data object in the format <literal>packageName.objectName</literal>, with multiple imports on separate lines.</simpara>
<formalpara>
<title>Importing data objects</title>
<para>
<screen>import org.mortgages.LoanApplication;</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>function</literal>: (optional) Use this to include a function to be used by rules in the DRL file. Functions in DRL files put semantic code in your rule source file instead of in Java classes. Functions are especially useful if an action (<literal>then</literal>) part of a rule is used repeatedly and only the parameters differ for each rule. Above the rules in the DRL file, you can declare the function or import a static method from a helper class as a function, and then use the function by name in an action (<literal>then</literal>) part of the rule.</simpara>
<formalpara>
<title>Declaring and using a function with a rule (option 1)</title>
<para>
<screen>function String hello(String applicantName) {
    return "Hello " + applicantName + "!";
}

rule "Using a function"
  when
    // Empty
  then
    System.out.println( hello( "James" ) );
end</screen>
</para>
</formalpara>
<formalpara>
<title>Importing and using the function with a rule (option 2)</title>
<para>
<screen>import function my.package.applicant.hello;

rule "Using a function"
  when
    // Empty
  then
    System.out.println( hello( "James" ) );
end</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>query</literal>: (optional) Use this to search the decision engine for facts related to the rules in the DRL file. You add the query definitions in DRL files and then obtain the matching results in your application code. Queries search for a set of defined conditions and do not require <literal>when</literal> or <literal>then</literal> specifications. Query names are global to the KIE base and therefore must be unique among all other rule queries in the project. To return the results of a query, construct a traditional <literal>QueryResults</literal> definition using <literal>ksession.getQueryResults("name")</literal>, where <literal>"name"</literal> is the query name. This returns a list of query results, which enable you to retrieve the objects that matched the query. Define the query and query results parameters above the rules in the DRL file.</simpara>
<formalpara>
<title>Example query definition in a DRL file</title>
<para>
<screen>query "people under the age of 21"
    $person : Person( age &lt; 21 )
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example application code to obtain query results</title>
<para>
<programlisting language="java" linenumbering="unnumbered">QueryResults results = ksession.getQueryResults( "people under the age of 21" );
System.out.println( "we have " + results.size() + " people under the age  of 21" );</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>declare</literal>: (optional) Use this to declare a new fact type to be used by rules in the DRL file. The default fact type in the <literal>java.lang</literal> package of Red Hat Decision Manager is <literal>Object</literal>, but you can declare other types in DRL files as needed. Declaring fact types in DRL files enables you to define a new fact model directly in the decision engine, without creating models in a lower-level language like Java.</simpara>
<formalpara>
<title>Declaring and using a new fact type</title>
<para>
<screen>declare Person
  name : String
  dateOfBirth : java.util.Date
  address : Address
end

rule "Using a declared type"
  when
    $p : Person( name == "James" )
  then   // Insert Mark, who is a customer of James.
    Person mark = new Person();
    mark.setName( "Mark" );
    insert( mark );
end</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>global</literal>: (optional) Use this to include a global variable to be used by rules in the DRL file. Global variables typically provide data or services for the rules, such as application services used in rule consequences, and return data from rules, such as logs or values added in rule consequences. Set the global value in the working memory of the decision engine through a KIE session configuration or REST operation, declare the global variable above the rules in the DRL file, and then use it in an action (<literal>then</literal>) part of the rule. For multiple global variables, use separate lines in the DRL file.</simpara>
<formalpara>
<title>Setting the global list configuration for the decision engine</title>
<para>
<screen>List&lt;String&gt; list = new ArrayList&lt;&gt;();
KieSession kieSession = kiebase.newKieSession();
kieSession.setGlobal( "myGlobalList", list );</screen>
</para>
</formalpara>
<formalpara>
<title>Defining the global list in a rule</title>
<para>
<screen>global java.util.List myGlobalList;

rule "Using a global"
  when
    // Empty
  then
    myGlobalList.add( "My global list" );
end</screen>
</para>
</formalpara>
<warning>
<simpara>Do not use global variables to establish conditions in rules unless a global variable has a constant immutable value. Global variables are not inserted into the working memory of the decision engine, so the decision engine cannot track value changes of variables.</simpara>
<simpara>Do not use global variables to share data between rules. Rules always reason and react to the working memory state, so if you want to pass data from rule to rule, assert the data as facts into the working memory of the decision engine.</simpara>
</warning>
</listitem>
<listitem>
<simpara><literal>rule</literal>: Use this to define each rule in the DRL file. Rules consist of a rule name in the format <literal>rule "name"</literal>, followed by optional attributes that define rule behavior (such as <literal>salience</literal> or <literal>no-loop</literal>), followed by <literal>when</literal> and <literal>then</literal> definitions. Each rule must have a unique name within the rule package. The <literal>when</literal> part of the rule contains the conditions that must be met to execute an action. For example, if a bank requires loan applicants to have over 21 years of age, then the <literal>when</literal> condition for an <literal>"Underage"</literal> rule would be <literal>Applicant( age &lt; 21 )</literal>. The <literal>then</literal> part of the rule contains the actions to be performed when the conditional part of the rule has been met. For example, when the loan applicant is under 21 years old, the <literal>then</literal> action would be <literal>setApproved( false )</literal>, declining the loan because the applicant is under age.</simpara>
<formalpara>
<title>Rule for loan application age limit</title>
<para>
<screen>rule "Underage"
  salience 15
  when
    $application : LoanApplication()
    Applicant( age &lt; 21 )
  then
    $application.setApproved( false );
    $application.setExplanation( "Underage" );
end</screen>
</para>
</formalpara>
<simpara>At a minimum, each DRL file must specify the <literal>package</literal>, <literal>import</literal>, and <literal>rule</literal> components. All other components are optional.</simpara>
<simpara>The following is an example DRL file in a loan application decision service:</simpara>
<formalpara>
<title>Example DRL file for a loan application</title>
<para>
<screen>package org.mortgages;

import org.mortgages.LoanApplication;
import org.mortgages.Bankruptcy;
import org.mortgages.Applicant;

rule "Bankruptcy history"
	salience 10
	when
		$a : LoanApplication()
		exists (Bankruptcy( yearOfOccurrence &gt; 1990 || amountOwed &gt; 10000 ))
	then
		$a.setApproved( false );
		$a.setExplanation( "has been bankrupt" );
		delete( $a );
end

rule "Underage"
	salience 15
	when
		$application : LoanApplication()
		Applicant( age &lt; 21 )
	then
		$application.setApproved( false );
		$application.setExplanation( "Underage" );
		delete( $application );
end</screen>
</para>
</formalpara>
<figure>
<title>Example DRL file for a loan application in Business Central</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/drl-rules-sample.png"/>
</imageobject>
<textobject><phrase>Example DRL file with required components</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After you define all components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the DRL designer to validate the DRL file. If the file validation fails, address any problems described in the error message, review all syntax and components in the DRL file, and try again to validate the file until the file passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the DRL designer to save your work.</simpara>
</listitem>
</orderedlist>
<section xml:id="drl-rules-WHEN-proc">
<title>Adding WHEN conditions in DRL rules</title>
<simpara>The <literal>when</literal> part of the rule contains the conditions that must be met to execute an action. For example, if a bank requires loan applicants to have over 21 years of age, then the <literal>when</literal> condition of an <literal>"Underage"</literal> rule would be <literal>Applicant( age &lt; 21 )</literal>. Conditions consist of a series of stated patterns and constraints, with optional bindings and other supported DRL elements, based on the available data objects in the package.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The <literal>package</literal> is defined at the top of the DRL file. This should have been done for you when you created the file.</simpara>
</listitem>
<listitem>
<simpara>The <literal>import</literal> list of data objects used in the rule is defined below the <literal>package</literal> line of the DRL file. Data objects can be from this package or from another package in Business Central.</simpara>
</listitem>
<listitem>
<simpara>The <literal>rule</literal> name is defined in the format <literal>rule "name"</literal> below the <literal>package</literal>, <literal>import</literal>, and other lines that apply to the entire DRL file. The same rule name cannot be used more than once in the same package. Optional rule attributes (such as <literal>salience</literal> or <literal>no-loop</literal>) that define rule behavior are below the rule name, before the <literal>when</literal> section.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the DRL designer, enter <literal>when</literal> within the rule to begin adding condition statements. The <literal>when</literal> section consists of zero or more fact patterns that define conditions for the rule.</simpara>
<simpara>If the <literal>when</literal> section is empty, then the conditions are considered to be true and the actions in the <literal>then</literal> section are executed the first time a <literal>fireAllRules()</literal> call is made in the decision engine. This is useful if you want to use rules to set up the decision engine state.</simpara>
<formalpara>
<title>Example rule without conditions</title>
<para>
<screen>rule "Always insert applicant"
  when
    // Empty
  then   // Actions to be executed once
    insert( new Applicant() );
end

// The rule is internally rewritten in the following way:

rule "Always insert applicant"
  when
    eval( true )
  then
    insert( new Applicant() );
end</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Enter a pattern for the first condition to be met, with optional constraints, bindings, and other supported DRL elements. A basic pattern format is <literal>&lt;patternBinding&gt; : &lt;patternType&gt; ( &lt;constraints&gt; )</literal>. Patterns are based on the available data objects in the package and define the conditions to be met in order to trigger actions in the <literal>then</literal> section.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Simple pattern:</emphasis> A simple pattern with no constraints matches against a fact of the given type. For example, the following condition is only that the applicant exists.</simpara>
<screen>when
  Applicant()</screen>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pattern with constraints:</emphasis> A pattern with constraints matches against a fact of the given type and the additional restrictions in parentheses that are true or false. For example, the following condition is that the applicant is under the age of 21.</simpara>
<screen>when
  Applicant( age &lt; 21 )</screen>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pattern with binding:</emphasis> A binding on a pattern is a shorthand reference that other components of the rule can use to refer back to the defined pattern. For example, the following binding <literal>a</literal> on <literal>LoanApplication</literal> is used in a related action for underage applicants.</simpara>
<screen>when
  $a : LoanApplication()
  Applicant( age &lt; 21 )
then
  $a.setApproved( false );
  $a.setExplanation( "Underage" )</screen>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Continue defining all condition patterns that apply to this rule. The following are some of the keyword options for defining DRL conditions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>and</literal>: Use this to group conditional components into a logical conjunction. Infix and prefix <literal>and</literal> are supported. By default, all listed patterns are combined with <literal>and</literal> when no conjunction is specified.</simpara>
<screen>// All of the following examples are interpreted the same way:
$a : LoanApplication() and Applicant( age &lt; 21 )

$a : LoanApplication()
and Applicant( age &lt; 21 )

$a : LoanApplication()
Applicant( age &lt; 21 )

(and $a : LoanApplication() Applicant( age &lt; 21 ))</screen>
</listitem>
<listitem>
<simpara><literal>or</literal>: Use this to group conditional components into a logical disjunction. Infix and prefix <literal>or</literal> are supported.</simpara>
<screen>// All of the following examples are interpreted the same way:
Bankruptcy( amountOwed == 100000 ) or IncomeSource( amount == 20000 )

Bankruptcy( amountOwed == 100000 )
or IncomeSource( amount == 20000 )

(or Bankruptcy( amountOwed == 100000 ) IncomeSource( amount == 20000 ))</screen>
</listitem>
<listitem>
<simpara><literal>exists</literal>: Use this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches. If you use this element with multiple patterns, enclose the patterns with parentheses <literal>()</literal>.</simpara>
<screen>exists ( Bankruptcy( yearOfOccurrence &gt; 1990 || amountOwed &gt; 10000 ) )</screen>
</listitem>
<listitem>
<simpara><literal>not</literal>: Use this to specify facts and constraints that must not exist.</simpara>
<screen>not ( Applicant( age &lt; 21 ) )</screen>
</listitem>
<listitem>
<simpara><literal>forall</literal>: Use this to verify whether all facts that match the first pattern match all the remaining patterns. When a <literal>forall</literal> construct is satisfied, the rule evaluates to <literal>true</literal>.</simpara>
<screen>forall( $app : Applicant( age &lt; 21 )
              Applicant( this == $app, status = 'underage' ) )</screen>
</listitem>
<listitem>
<simpara><literal>from</literal>: Use this to specify a data source for a pattern.</simpara>
<screen>Applicant( ApplicantAddress : address )
Address( zipcode == "23920W" ) from ApplicantAddress</screen>
</listitem>
<listitem>
<simpara><literal>entry-point</literal>: Use this to define an <literal>Entry Point</literal> corresponding to a data source for the pattern. Typically used with <literal>from</literal>.</simpara>
<screen>Applicant() from entry-point "LoanApplication"</screen>
</listitem>
<listitem>
<simpara><literal>collect</literal>: Use this to define a collection of objects that the rule can use as part of the condition. In the example, all pending applications in the decision engine for each given mortgage are grouped in a <literal>List</literal>. If three or more pending applications are found, the rule is executed.</simpara>
<screen>$m : Mortgage()
$a : List( size &gt;= 3 )
    from collect( LoanApplication( Mortgage == $m, status == 'pending' ) )</screen>
</listitem>
<listitem>
<simpara><literal>accumulate</literal>: Use this to iterate over a collection of objects, execute custom actions for each of the elements, and return one or more result objects (if the constraints evaluate to <literal>true</literal>). This option is a more flexible and powerful form of <literal>collect</literal>. Use the format <literal>accumulate( &lt;source pattern&gt;; &lt;functions&gt; [;&lt;constraints&gt;] )</literal>. In the example, <literal>min</literal>, <literal>max</literal>, and <literal>average</literal> are accumulate functions that calculate the minimum, maximum, and average temperature values over all the readings for each sensor. Other supported functions include <literal>count</literal>, <literal>sum</literal>, <literal>variance</literal>, <literal>standardDeviation</literal>, <literal>collectList</literal>, and <literal>collectSet</literal>.</simpara>
<screen>$s : Sensor()
accumulate( Reading( sensor == $s, $temp : temperature );
            $min : min( $temp ),
            $max : max( $temp ),
            $avg : average( $temp );
            $min &lt; 20, $avg &gt; 70 )</screen>
</listitem>
</itemizedlist>
<note>
<simpara>For more information about DRL rule conditions, see <xref linkend="drl-rules-WHEN-con_drl-rules"/>.</simpara>
</note>
</listitem>
<listitem>
<simpara>After you define all condition components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the DRL designer to validate the DRL file. If the file validation fails, address any problems described in the error message, review all syntax and components in the DRL file, and try again to validate the file until the file passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the DRL designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="drl-rules-THEN-proc">
<title>Adding THEN actions in DRL rules</title>
<simpara>The <literal>then</literal> part of the rule contains the actions to be performed when the conditional part of the rule has been met. For example, when a loan applicant is under 21 years old, the <literal>then</literal> action of an <literal>"Underage"</literal> rule would be <literal>setApproved( false )</literal>, declining the loan because the applicant is under age. Actions consist of one or more methods that execute consequences based on the rule conditions and on available data objects in the package. The main purpose of rule actions is to to insert, delete, or modify data in the working memory of the decision engine.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The <literal>package</literal> is defined at the top of the DRL file. This should have been done for you when you created the file.</simpara>
</listitem>
<listitem>
<simpara>The <literal>import</literal> list of data objects used in the rule is defined below the <literal>package</literal> line of the DRL file. Data objects can be from this package or from another package in Business Central.</simpara>
</listitem>
<listitem>
<simpara>The <literal>rule</literal> name is defined in the format <literal>rule "name"</literal> below the <literal>package</literal>, <literal>import</literal>, and other lines that apply to the entire DRL file. The same rule name cannot be used more than once in the same package. Optional rule attributes (such as <literal>salience</literal> or <literal>no-loop</literal>) that define rule behavior are below the rule name, before the <literal>when</literal> section.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the DRL designer, enter <literal>then</literal> after the <literal>when</literal> section of the rule to begin adding action statements.</simpara>
</listitem>
<listitem>
<simpara>Enter one or more actions to be executed on fact patterns based on the conditions for the rule.</simpara>
<simpara>The following are some of the keyword options for defining DRL actions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>set</literal>: Use this to set the value of a field.</simpara>
<screen>$application.setApproved ( false );
$application.setExplanation( "has been bankrupt" );</screen>
</listitem>
<listitem>
<simpara><literal>modify</literal>: Use this to specify fields to be modified for a fact and to notify the decision engine of the change. This method provides a structured approach to fact updates. It combines the <literal>update</literal> operation with setter calls to change object fields.</simpara>
<screen>modify( LoanApplication ) {
        setAmount( 100 ),
        setApproved ( true )
}</screen>
</listitem>
<listitem>
<simpara><literal>update</literal>: Use this to specify fields and the entire related fact to be updated and to notify the decision engine of the change. After a fact has changed, you must call <literal>update</literal> before changing another fact that might be affected by the updated values. To avoid this added step, use the <literal>modify</literal> method instead.</simpara>
<screen>LoanApplication.setAmount( 100 );
update( LoanApplication );</screen>
</listitem>
<listitem>
<simpara><literal>insert</literal>: Use this to insert a <literal>new</literal> fact into the decision engine.</simpara>
<screen>insert( new Applicant() );</screen>
</listitem>
<listitem>
<simpara><literal>insertLogical</literal>: Use this to insert a <literal>new</literal> fact logically into the decision engine. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts must be retracted explicitly. After logical insertions, the facts that were inserted are automatically retracted when the conditions in the rules that inserted the facts are no longer true.</simpara>
<screen>insertLogical( new Applicant() );</screen>
</listitem>
<listitem>
<simpara><literal>delete</literal>: Use this to remove an object from the decision engine. The keyword <literal>retract</literal> is also supported in DRL and executes the same action, but <literal>delete</literal> is typically preferred in DRL code for consistency with the keyword <literal>insert</literal>.</simpara>
<screen>delete( Applicant );</screen>
</listitem>
</itemizedlist>
<note>
<simpara>For more information about DRL rule actions, see <xref linkend="drl-rules-THEN-con_drl-rules"/>.</simpara>
</note>
</listitem>
<listitem>
<simpara>After you define all action components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the DRL designer to validate the DRL file. If the file validation fails, address any problems described in the error message, review all syntax and components in the DRL file, and try again to validate the file until the file passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the DRL designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="assets-executing-proc_drl-rules">
<title>Executing rules</title>
<simpara>After you identify example rules or create your own rules in Business Central, you can build and deploy the associated project and execute rules locally or on KIE Server to test the rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Business Central and KIE Server are installed and running. For installation options, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right corner of the project <emphasis role="strong">Assets</emphasis> page, click <emphasis role="strong">Deploy</emphasis> to build the project and deploy it to KIE Server. If the build fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the screen.</simpara>
<simpara>For more information about project deployment options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>If the rule assets in your project are not built from an executable rule model by default, verify that the following dependency is in the <literal>pom.xml</literal> file of your project and rebuild the project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-model-compiler&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>This dependency is required for rule assets in Red Hat Decision Manager to be built from executable rule models by default. This dependency is included as part of the Red Hat Decision Manager core packaging, but depending on your Red Hat Decision Manager upgrade history, you may need to manually add this dependency to enable the executable rule model behavior.</simpara>
<simpara>For more information about executable rule models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a Maven or Java project outside of Business Central, if not created already, that you can use for executing rules locally or that you can use as a client application for executing rules on KIE Server. The project must contain a <literal>pom.xml</literal> file and any other required components for executing the project resources.</simpara>
<simpara>For example test projects, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#drl-rules-other-con">"Other methods for creating and executing DRL rules"</link>.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>pom.xml</literal> file of your test project or client application and add the following dependencies, if not added already:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-ci</literal>: Enables your client application to load Business Central project data locally using <literal>ReleaseId</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kie-server-client</literal>: Enables your client application to interact remotely with assets on KIE Server</simpara>
</listitem>
<listitem>
<simpara><literal>slf4j</literal>: (Optional) Enables your client application to use Simple Logging Facade for Java (SLF4J) to return debug logging information after you interact with KIE Server</simpara>
</listitem>
</itemizedlist>
<simpara>Example dependencies for Red Hat Decision Manager 7.10 in a client application <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For local execution --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For remote execution on KIE Server --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For debug logging (optional) --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For available versions of these artifacts, search the group ID and artifact ID in the <link xlink:href="https://repository.jboss.org/nexus/index.html#welcome">Nexus Repository Manager</link> online.</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between Red Hat Decision Manager and the Maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the dependencies for artifacts containing model classes are defined in the client application <literal>pom.xml</literal> file exactly as they appear in the <literal>pom.xml</literal> file of the deployed project. If dependencies for model classes differ between the client application and your projects, execution errors can occur.</simpara>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>For example, the following <literal>Person</literal> class dependency appears in both the client and deployed project <literal>pom.xml</literal> files:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.sample&lt;/groupId&gt;
  &lt;artifactId&gt;Person&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you added the <literal>slf4j</literal> dependency to the client application <literal>pom.xml</literal> file for debug logging, create a <literal>simplelogger.properties</literal> file on the relevant classpath (for example, in <literal>src/main/resources/META-INF</literal> in Maven) with the following content:</simpara>
<programlisting language="java" linenumbering="unnumbered">org.slf4j.simpleLogger.defaultLogLevel=debug</programlisting>
</listitem>
<listitem>
<simpara>In your client application, create a <literal>.java</literal> main class containing the necessary imports and a <literal>main()</literal> method to load the KIE base, insert facts, and execute the rules.</simpara>
<simpara>For example, a <literal>Person</literal> object in a project contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person. The following <literal>Wage</literal> rule in a project calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
<simpara>To test this rule locally outside of KIE Server (if needed), configure the <literal>.java</literal> class to import KIE services, a KIE container, and a KIE session, and then use the <literal>main()</literal> method to fire all rules against a defined fact model:</simpara>
<formalpara>
<title>Executing rules locally</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.builder.ReleaseId;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.drools.compiler.kproject.ReleaseIdImpl;

public class RulesTest {

  public static final void main(String[] args) {
    try {
      // Identify the project in the local repository:
      ReleaseId rid = new ReleaseIdImpl("com.myspace", "MyProject", "1.0.0");

      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.newKieContainer(rid);
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
<simpara>To test this rule on KIE Server, configure the <literal>.java</literal> class with the imports and rule execution information similarly to the local example, and additionally specify KIE services configuration and KIE services client details:</simpara>
<formalpara>
<title>Executing rules on KIE Server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.kie.api.command.BatchExecutionCommand;
import org.kie.api.command.Command;
import org.kie.api.KieServices;
import org.kie.api.runtime.ExecutionResults;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.RuleServicesClient;

import com.sample.Person;

public class RulesTest {

  private static final String containerName = "testProject";
  private static final String sessionName = "myStatelessSession";

  public static final void main(String[] args) {
    try {
      // Define KIE services configuration and client:
      Set&lt;Class&lt;?&gt;&gt; allClasses = new HashSet&lt;Class&lt;?&gt;&gt;();
      allClasses.add(Person.class);
      String serverUrl = "http://$HOST:$PORT/kie-server/services/rest/server";
      String username = "$USERNAME";
      String password = "$PASSWORD";
      KieServicesConfiguration config =
        KieServicesFactory.newRestConfiguration(serverUrl,
                                                username,
                                                password);
      config.setMarshallingFormat(MarshallingFormat.JAXB);
      config.addExtraClasses(allClasses);
      KieServicesClient kieServicesClient =
        KieServicesFactory.newKieServicesClient(config);

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert Person into the session:
      KieCommands kieCommands = KieServices.Factory.get().getCommands();
      List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();
      commandList.add(kieCommands.newInsert(p, "personReturnId"));

      // Fire all rules:
      commandList.add(kieCommands.newFireAllRules("numberOfFiredRules"));
      BatchExecutionCommand batch = kieCommands.newBatchExecution(commandList, sessionName);

      // Use rule services client to send request:
      RuleServicesClient ruleClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
      ServiceResponse&lt;ExecutionResults&gt; executeResponse = ruleClient.executeCommandsWithResults(containerName, batch);
      System.out.println("number of fired rules:" + executeResponse.getResult().getValue("numberOfFiredRules"));
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the configured <literal>.java</literal> class from your project directory. You can run the file in your development platform
(such as Red Hat CodeReady Studio)
or in the command line.</simpara>
<simpara>Example Maven execution (within project directory):</simpara>
<screen>mvn clean install exec:java -Dexec.mainClass="com.sample.app.RulesTest"</screen>
<simpara>Example Java execution (within project directory)</simpara>
<screen>javac -classpath "./$DEPENDENCIES/*:." RulesTest.java
java -classpath "./$DEPENDENCIES/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rule execution status in the command line and in the server log. If any rules do not execute as expected, review the configured rules in the project and the main class configuration to validate the data provided.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="drl-rules-other-con">
<title>Other methods for creating and executing DRL rules</title>
<simpara>As an alternative to creating and managing DRL rules within the Business Central interface, you can create DRL rule files externally as part of a Maven or Java project using Red Hat CodeReady Studio or another integrated development environment (IDE). These standalone projects can then be integrated as knowledge JAR (KJAR) dependencies in existing Red Hat Decision Manager projects in Business Central. The DRL files in your standalone project must contain at a minimum the required <literal>package</literal> specification, <literal>import</literal> lists, and <literal>rule</literal> definitions. Any other DRL components, such as global variables and functions, are optional. All data objects related to a DRL rule must be included with your standalone DRL project or deployment.</simpara>
<simpara>You can also use executable rule models in your Maven or Java projects to provide a Java-based representation of a rule set for execution at build time. The executable model is a more efficient alternative to the standard asset packaging in Red Hat Decision Manager and enables KIE containers and KIE bases to be created more quickly, especially when you have large lists of DRL (Drools Rule Language) files and other Red Hat Decision Manager assets.</simpara>
<section xml:id="drl-rules-codeready-studio-create-proc_drl-rules">
<title>Creating and executing DRL rules in Red Hat CodeReady Studio</title>
<simpara>You can use Red Hat CodeReady Studio to create DRL files with rules and integrate the files with your Red Hat Decision Manager decision service. This method of creating DRL rules is helpful if you already use Red Hat CodeReady Studio for your decision service and want to continue with the same workflow. If you do not already use this method, then the Business Central interface of Red Hat Decision Manager is recommended for creating DRL files and other rule assets.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat CodeReady Studio has been installed from the <link xlink:href="https://access.redhat.com/downloads/">Red Hat Customer Portal</link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the Red Hat CodeReady Studio, click <emphasis role="strong">File</emphasis> → <emphasis role="strong">New</emphasis> → <emphasis role="strong">Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">New Project</emphasis> window that opens, select <emphasis role="strong">Drools</emphasis> → <emphasis role="strong">Drools Project</emphasis> and click <emphasis role="strong">Next</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the second icon to <emphasis role="strong">Create a project and populate it with some example files to help you get started quickly</emphasis>. Click <emphasis role="strong">Next</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a <emphasis role="strong">Project name</emphasis> and select the <emphasis role="strong">Maven</emphasis> radio button as the project building option. The GAV values are generated automatically. You can update these values as needed for your project:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Group ID:</emphasis> <literal>com.sample</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Artifact ID:</emphasis> <literal>my-project</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Version:</emphasis> <literal>1.0.0-SNAPSHOT</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Finish</emphasis> to create the project.</simpara>
<simpara>This configuration sets up a basic project structure, class path, and sample rules. The following is an overview of the project structure:</simpara>
<screen>my-project
 `-- src/main/java
    | `-- com.sample
    |    `-- DecisionTableTest.java
    |    `-- DroolsTest.java
    |    `-- ProcessTest.java
    |
 `-- src/main/resources
    | `-- dtables
    |    `-- Sample.xls
    | `-- process
    |    `-- sample.bpmn
    | `-- rules
    |    `-- Sample.drl
    | `-- META-INF
    |
 `-- JRE System Library
    |
 `-- Maven Dependencies
    |
 `-- Drools Library
    |
 `-- src
    |
 `-- target
    |
 `-- pom.xml</screen>
<simpara>Notice the following elements:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>Sample.drl</literal> rule file in the <literal>src/main/resources</literal> directory, containing an example <literal>Hello World</literal> and <literal>GoodBye</literal> rules.</simpara>
</listitem>
<listitem>
<simpara>A <literal>DroolsTest.java</literal> file under the <literal>src/main/java</literal> directory in the <literal>com.sample</literal> package. The <literal>DroolsTest</literal> class can be used to execute the <literal>Sample.drl</literal> rule.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Drools Library</literal> directory, which acts as a custom class path containing JAR files necessary for execution.</simpara>
</listitem>
</itemizedlist>
<simpara>You can edit the existing <literal>Sample.drl</literal> file and <literal>DroolsTest.java</literal> files with new configurations as needed, or create new rule and object files. In this procedure, you are creating a new rule and new Java objects.</simpara>
</listitem>
<listitem>
<simpara>Create a Java object on which the rule or rules will operate.</simpara>
<simpara>In this example, a <literal>Person.java</literal> file is created in <literal>my-project/src/main/java/com.sample</literal>. The <literal>Person</literal> class contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person:</simpara>
<programlisting language="java" linenumbering="unnumbered">  public class Person {
    private String firstName;
    private String lastName;
    private Integer hourlyRate;
    private Integer wage;

    public String getFirstName() {
      return firstName;
    }

    public void setFirstName(String firstName) {
      this.firstName = firstName;
    }

    public String getLastName() {
      return lastName;
    }

    public void setLastName(String lastName) {
      this.lastName = lastName;
    }

    public Integer getHourlyRate() {
      return hourlyRate;
    }

    public void setHourlyRate(Integer hourlyRate) {
      this.hourlyRate = hourlyRate;
    }

    public Integer getWage(){
      return wage;
    }

    public void setWage(Integer wage){
      this.wage = wage;
    }
  }</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Save</emphasis> to save the file.</simpara>
</listitem>
<listitem>
<simpara>Create a rule file in <literal>.drl</literal> format in <literal>my-project/src/main/resources/rules</literal>. The DRL file must contain at a minimum a package specification, an import list of data objects to be used by the rule or rules, and one or more rules with <literal>when</literal> conditions and <literal>then</literal> actions.</simpara>
<simpara>The following <literal>Wage.drl</literal> file contains a <literal>Wage</literal> rule that imports the <literal>Person</literal> class, calculates the wage and hourly rate values, and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Save</emphasis> to save the file.</simpara>
</listitem>
<listitem>
<simpara>Create a main class and save it to the same directory as the Java object that you created. The main class will load the KIE base and execute rules.</simpara>
<note>
<simpara>You can also add the <literal>main()</literal> method and <literal>Person</literal> class within a single Java object file, similar to the <literal>DroolsTest.java</literal> sample file.</simpara>
</note>
</listitem>
<listitem>
<simpara>In the main class, add the required <literal>import</literal> statements to import KIE services, a KIE container, and a KIE session. Then load the KIE base, insert facts, and execute the rule from the <literal>main()</literal> method that passes the fact model to the rule.</simpara>
<simpara>In this example, a <literal>RulesTest.java</literal> file is created in <literal>my-project/src/main/java/com.sample</literal> with the required imports and <literal>main()</literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import org.kie.api.KieServices;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

public class RulesTest {
  public static final void main(String[] args) {
    try {
      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.getKieClasspathContainer();
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Save</emphasis> to save the file.</simpara>
</listitem>
<listitem>
<simpara>After you create and save all DRL assets in your project, right-click your project folder and select <emphasis role="strong">Run As</emphasis> → <emphasis role="strong">Java Application</emphasis> to build the project. If the project build fails, address any problems described in the <emphasis role="strong">Problems</emphasis> tab of the lower window in CodeReady Studio, and try again to validate the project until the project builds.</simpara>
</listitem>
</orderedlist>
<note>
<title>If the <emphasis role="strong">Run As</emphasis> → <emphasis role="strong">Java Application</emphasis> option is not available</title>
<simpara>If <emphasis role="strong">Java Application</emphasis> is not an option when you right-click your project and select <emphasis role="strong">Run As</emphasis>, then go to <emphasis role="strong">Run As</emphasis> → <emphasis role="strong">Run Configurations</emphasis>, right-click <emphasis role="strong">Java Application</emphasis>, and click <emphasis role="strong">New</emphasis>. Then in the <emphasis role="strong">Main</emphasis> tab, browse for and select your <emphasis role="strong">Project</emphasis> and the associated <emphasis role="strong">Main class</emphasis>. Click <emphasis role="strong">Apply</emphasis> and then click <emphasis role="strong">Run</emphasis> to test the project. The next time you right-click your project folder, the <emphasis role="strong">Java Application</emphasis> option will appear.</simpara>
</note>
<simpara>To integrate the new rule assets with an existing project in Red Hat Decision Manager, you can compile the new project as a knowledge JAR (KJAR) and add it as a dependency in the <literal>pom.xml</literal> file of the project in Business Central. To access the project <literal>pom.xml</literal> file in Business Central, you can select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
</section>
<section xml:id="drl-rules-java-create-proc_drl-rules">
<title>Creating and executing DRL rules using Java</title>
<simpara>You can use Java objects to create DRL files with rules and integrate the objects with your Red Hat Decision Manager decision service. This method of creating DRL rules is helpful if you already use external Java objects for your decision service and want to continue with the same workflow. If you do not already use this method, then the Business Central interface of Red Hat Decision Manager is recommended for creating DRL files and other rule assets.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a Java object on which the rule or rules will operate.</simpara>
<simpara>In this example, a <literal>Person.java</literal> file is created in a directory <literal>my-project</literal>. The <literal>Person</literal> class contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person:</simpara>
<programlisting language="java" linenumbering="unnumbered">  public class Person {
    private String firstName;
    private String lastName;
    private Integer hourlyRate;
    private Integer wage;

    public String getFirstName() {
      return firstName;
    }

    public void setFirstName(String firstName) {
      this.firstName = firstName;
    }

    public String getLastName() {
      return lastName;
    }

    public void setLastName(String lastName) {
      this.lastName = lastName;
    }

    public Integer getHourlyRate() {
      return hourlyRate;
    }

    public void setHourlyRate(Integer hourlyRate) {
      this.hourlyRate = hourlyRate;
    }

    public Integer getWage(){
      return wage;
    }

    public void setWage(Integer wage){
      this.wage = wage;
    }
  }</programlisting>
</listitem>
<listitem>
<simpara>Create a rule file in <literal>.drl</literal> format under the <literal>my-project</literal> directory. The DRL file must contain at a minimum a package specification (if applicable), an import list of data objects to be used by the rule or rules, and one or more rules with <literal>when</literal> conditions and <literal>then</literal> actions.</simpara>
<simpara>The following <literal>Wage.drl</literal> file contains a <literal>Wage</literal> rule that calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
</listitem>
<listitem>
<simpara>Create a main class and save it to the same directory as the Java object that you created. The main class will load the KIE base and execute rules.</simpara>
</listitem>
<listitem>
<simpara>In the main class, add the required <literal>import</literal> statements to import KIE services, a KIE container, and a KIE session. Then load the KIE base, insert facts, and execute the rule from the <literal>main()</literal> method that passes the fact model to the rule.</simpara>
<simpara>In this example, a <literal>RulesTest.java</literal> file is created in <literal>my-project</literal> with the required imports and <literal>main()</literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

public class RulesTest {
  public static final void main(String[] args) {
    try {
      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.getKieClasspathContainer();
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</listitem>
<listitem>
<simpara>Download the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> ZIP file from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> and extract it under
<literal>my-project/dm-engine-jars/</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the <literal>my-project/META-INF</literal> directory, create a <literal>kmodule.xml</literal> metadata file with the following content:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>This <literal>kmodule.xml</literal> file is a KIE module descriptor that selects resources to KIE bases and configures sessions. This file enables you to define and configure one or more KIE bases, and to include DRL files from specific <literal>packages</literal> in a specific KIE base. You can also create one or more KIE sessions from each KIE base.</simpara>
<simpara>The following example shows a more advanced <literal>kmodule.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;kbase name="KBase1" default="true" eventProcessingMode="cloud" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg1"&gt;
    &lt;ksession name="KSession1_1" type="stateful" default="true" /&gt;
    &lt;ksession name="KSession1_2" type="stateful" default="true" beliefSystem="jtms" /&gt;
  &lt;/kbase&gt;
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    &lt;ksession name="KSession2_1" type="stateless" default="true" clockType="realtime"&gt;
      &lt;fileLogger file="debugInfo" threaded="true" interval="10" /&gt;
      &lt;workItemHandlers&gt;
        &lt;workItemHandler name="name" type="new org.domain.WorkItemHandler()" /&gt;
      &lt;/workItemHandlers&gt;
      &lt;listeners&gt;
        &lt;ruleRuntimeEventListener type="org.domain.RuleRuntimeListener" /&gt;
        &lt;agendaEventListener type="org.domain.FirstAgendaListener" /&gt;
        &lt;agendaEventListener type="org.domain.SecondAgendaListener" /&gt;
        &lt;processEventListener type="org.domain.ProcessListener" /&gt;
      &lt;/listeners&gt;
    &lt;/ksession&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>This example defines two KIE bases. Two KIE sessions are instantiated from the <literal>KBase1</literal> KIE base, and one KIE session from <literal>KBase2</literal>. The KIE session from <literal>KBase2</literal> is a <literal>stateless</literal> KIE session, which means that data from a previous invocation of the KIE session (the previous session state) is discarded between session invocations. Specific <literal>packages</literal> of rule assets are included with both KIE bases. When you specify packages in this way, you must organize your DRL files in a folder structure that reflects the specified packages.</simpara>
</listitem>
<listitem>
<simpara>After you create and save all DRL assets in your Java object, navigate to the <literal>my-project</literal> directory in the command line and run the following command to build your Java files. Replace <literal>RulesTest.java</literal> with the name of your Java main class.</simpara>
<screen>javac -classpath "./dm-engine-jars/*:." RulesTest.java</screen>
<simpara>If the build fails, address any problems described in the command line error messages and try again to validate the Java object until the object passes.</simpara>
</listitem>
<listitem>
<simpara>After your Java files build successfully, run the following command to execute the rules locally. Replace <literal>RulesTest</literal> with the prefix of your Java main class.</simpara>
<screen>java -classpath "./dm-engine-jars/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rules to ensure that they executed properly, and address any needed changes in the Java files.</simpara>
</listitem>
</orderedlist>
<simpara>To integrate the new rule assets with an existing project in Red Hat Decision Manager, you can compile the new Java project as a knowledge JAR (KJAR) and add it as a dependency in the <literal>pom.xml</literal> file of the project in Business Central. To access the project <literal>pom.xml</literal> file in Business Central, you can select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
</section>
<section xml:id="drl-rules-maven-create-proc_drl-rules">
<title>Creating and executing DRL rules using Maven</title>
<simpara>You can use Maven archetypes to create DRL files with rules and integrate the archetypes with your Red Hat Decision Manager decision service. This method of creating DRL rules is helpful if you already use external Maven archetypes for your decision service and want to continue with the same workflow. If you do not already use this method, then the Business Central interface of Red Hat Decision Manager is recommended for creating DRL files and other rule assets.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to a directory where you want to create a Maven archetype and run the following command:</simpara>
<screen>mvn archetype:generate -DgroupId=com.sample.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</screen>
<simpara>This creates a directory <literal>my-app</literal> with the following structure:</simpara>
<screen>my-app
|-- pom.xml
`-- src
    |-- main
    |   `-- java
    |       `-- com
    |           `-- sample
    |               `-- app
    |                   `-- App.java
    `-- test
        `-- java
            `-- com
                `-- sample
                    `-- app
                        `-- AppTest.java</screen>
<simpara>The <literal>my-app</literal> directory contains the following key components:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>src/main</literal> directory for storing the application sources</simpara>
</listitem>
<listitem>
<simpara>A <literal>src/test</literal> directory for storing the test sources</simpara>
</listitem>
<listitem>
<simpara>A <literal>pom.xml</literal> file with the project configuration</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create a Java object on which the rule or rules will operate within the Maven archetype.</simpara>
<simpara>In this example, a <literal>Person.java</literal> file is created in the directory <literal>my-app/src/main/java/com/sample/app</literal>. The <literal>Person</literal> class contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample.app;

  public class Person {

    private String firstName;
    private String lastName;
    private Integer hourlyRate;
    private Integer wage;

    public String getFirstName() {
      return firstName;
    }

    public void setFirstName(String firstName) {
      this.firstName = firstName;
    }

    public String getLastName() {
      return lastName;
    }

    public void setLastName(String lastName) {
      this.lastName = lastName;
    }

    public Integer getHourlyRate() {
      return hourlyRate;
    }

    public void setHourlyRate(Integer hourlyRate) {
      this.hourlyRate = hourlyRate;
    }

    public Integer getWage(){
      return wage;
    }

    public void setWage(Integer wage){
      this.wage = wage;
    }
  }</programlisting>
</listitem>
<listitem>
<simpara>Create a rule file in <literal>.drl</literal> format in <literal>my-app/src/main/resources/rules</literal>. The DRL file must contain at a minimum a package specification, an import list of data objects to be used by the rule or rules, and one or more rules with <literal>when</literal> conditions and <literal>then</literal> actions.</simpara>
<simpara>The following <literal>Wage.drl</literal> file contains a <literal>Wage</literal> rule that imports the <literal>Person</literal> class, calculates the wage and hourly rate values, and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample.app;

import com.sample.app.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
</listitem>
<listitem>
<simpara>In the <literal>my-app/src/main/resources/META-INF</literal> directory, create a <literal>kmodule.xml</literal> metadata file with the following content:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>This <literal>kmodule.xml</literal> file is a KIE module descriptor that selects resources to KIE bases and configures sessions. This file enables you to define and configure one or more KIE bases, and to include DRL files from specific <literal>packages</literal> in a specific KIE base. You can also create one or more KIE sessions from each KIE base.</simpara>
<simpara>The following example shows a more advanced <literal>kmodule.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;kmodule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;kbase name="KBase1" default="true" eventProcessingMode="cloud" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg1"&gt;
    &lt;ksession name="KSession1_1" type="stateful" default="true" /&gt;
    &lt;ksession name="KSession1_2" type="stateful" default="true" beliefSystem="jtms" /&gt;
  &lt;/kbase&gt;
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    &lt;ksession name="KSession2_1" type="stateless" default="true" clockType="realtime"&gt;
      &lt;fileLogger file="debugInfo" threaded="true" interval="10" /&gt;
      &lt;workItemHandlers&gt;
        &lt;workItemHandler name="name" type="new org.domain.WorkItemHandler()" /&gt;
      &lt;/workItemHandlers&gt;
      &lt;listeners&gt;
        &lt;ruleRuntimeEventListener type="org.domain.RuleRuntimeListener" /&gt;
        &lt;agendaEventListener type="org.domain.FirstAgendaListener" /&gt;
        &lt;agendaEventListener type="org.domain.SecondAgendaListener" /&gt;
        &lt;processEventListener type="org.domain.ProcessListener" /&gt;
      &lt;/listeners&gt;
    &lt;/ksession&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>This example defines two KIE bases. Two KIE sessions are instantiated from the <literal>KBase1</literal> KIE base, and one KIE session from <literal>KBase2</literal>. The KIE session from <literal>KBase2</literal> is a <literal>stateless</literal> KIE session, which means that data from a previous invocation of the KIE session (the previous session state) is discarded between session invocations. Specific <literal>packages</literal> of rule assets are included with both KIE bases. When you specify packages in this way, you must organize your DRL files in a folder structure that reflects the specified packages.</simpara>
</listitem>
<listitem>
<simpara>In the <literal>my-app/pom.xml</literal> configuration file, specify the libraries that your application requires. Provide the Red Hat Decision Manager dependencies as well as the <literal>group ID</literal>, <literal>artifact ID</literal>, and <literal>version</literal> (GAV) of your application.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
&lt;groupId&gt;com.sample.app&lt;/groupId&gt;
&lt;artifactId&gt;my-app&lt;/artifactId&gt;
&lt;version&gt;1.0.0&lt;/version&gt;
&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;jboss-ga-repository&lt;/id&gt;
    &lt;url&gt;http://maven.repository.redhat.com/ga/&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.drools&lt;/groupId&gt;
    &lt;artifactId&gt;drools-compiler&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.kie&lt;/groupId&gt;
    &lt;artifactId&gt;kie-api&lt;/artifactId&gt;
    &lt;version&gt;VERSION&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.11&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
<simpara>For information about Maven dependencies and the BOM (Bill of Materials) in Red Hat Decision Manager, see <link xlink:href="https://access.redhat.com/solutions/3405361">What is the mapping between Red Hat Decision Manager and Maven library version?</link>.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>testApp</literal> method in <literal>my-app/src/test/java/com/sample/app/AppTest.java</literal> to test the rule. The <literal>AppTest.java</literal> file is created by Maven by default.</simpara>
</listitem>
<listitem>
<simpara>In the <literal>AppTest.java</literal> file, add the required <literal>import</literal> statements to import KIE services, a KIE container, and a KIE session. Then load the KIE base, insert facts, and execute the rule from the <literal>testApp()</literal> method that passes the fact model to the rule.</simpara>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

public void testApp() {

  // Load the KIE base:
  KieServices ks = KieServices.Factory.get();
  KieContainer kContainer = ks.getKieClasspathContainer();
  KieSession kSession = kContainer.newKieSession();

  // Set up the fact model:
  Person p = new Person();
  p.setWage(12);
  p.setFirstName("Tom");
  p.setLastName("Summers");
  p.setHourlyRate(10);

  // Insert the person into the session:
  kSession.insert(p);

  // Fire all rules:
  kSession.fireAllRules();
  kSession.dispose();
}</programlisting>
</listitem>
<listitem>
<simpara>After you create and save all DRL assets in your Maven archetype, navigate to the <literal>my-app</literal> directory in the command line and run the following command to build your files:</simpara>
<screen>mvn clean install</screen>
<simpara>If the build fails, address any problems described in the command line error messages and try again to validate the files until the build is successful.</simpara>
</listitem>
<listitem>
<simpara>After your files build successfully, run the following command to execute the rules locally. Replace <literal>com.sample.app</literal> with your package name.</simpara>
<screen>mvn exec:java -Dexec.mainClass="com.sample.app"</screen>
</listitem>
<listitem>
<simpara>Review the rules to ensure that they executed properly, and address any needed changes in the files.</simpara>
</listitem>
</orderedlist>
<simpara>To integrate the new rule assets with an existing project in Red Hat Decision Manager, you can compile the new Maven project as a knowledge JAR (KJAR) and add it as a dependency in the <literal>pom.xml</literal> file of the project in Business Central. To access the project <literal>pom.xml</literal> file in Business Central, you can select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
</section>
</chapter>
<chapter xml:id="decision-examples-IDE-con_drl-rules">
<title>Example decisions in Red Hat Decision Manager for an IDE</title>
<simpara>Red Hat Decision Manager provides example decisions distributed as Java classes that you can import into your integrated development environment (IDE). You can use these examples to better understand decision engine capabilities or use them as a reference for the decisions that you define in your own Red Hat Decision Manager projects.</simpara>
<simpara>The following example decision sets are some of the examples available in Red Hat Decision Manager:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Hello World example</emphasis>: Demonstrates basic rule execution and use of debug output</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">State example</emphasis>: Demonstrates forward chaining and conflict resolution through rule salience and agenda groups</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fibonacci example</emphasis>: Demonstrates recursion and conflict resolution through rule salience</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Banking example</emphasis>: Demonstrates pattern matching, basic sorting, and calculation</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pet Store example</emphasis>: Demonstrates rule agenda groups, global variables, callbacks, and GUI integration</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Sudoku example</emphasis>: Demonstrates complex pattern matching, problem solving, callbacks, and GUI integration</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">House of Doom example</emphasis>: Demonstrates backward chaining and recursion</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For optimization examples provided with Red Hat Business Optimizer, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#examples-con"><emphasis>Getting started with Red Hat Business Optimizer</emphasis></link>.</simpara>
</note>
<section xml:id="decision-examples-IDE-proc_drl-rules">
<title>Importing and executing Red Hat Decision Manager example decisions in an IDE</title>
<simpara>You can import Red Hat Decision Manager example decisions into your integrated development environment (IDE) and execute them to explore how the rules and code function. You can use these examples to better understand decision engine capabilities or use them as a reference for the decisions that you define in your own Red Hat Decision Manager projects.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Java 8 or later is installed.</simpara>
</listitem>
<listitem>
<simpara>Maven 3.5.x or later is installed.</simpara>
</listitem>
<listitem>
<simpara>An IDE is installed, such as
Red Hat CodeReady Studio.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Download and unzip the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> to a temporary directory, such as <literal>/rhdm-7.10.0-sources</literal>.</simpara>
</listitem>
<listitem>
<simpara>Open your IDE and select <emphasis role="strong">File</emphasis> → <emphasis role="strong">Import</emphasis> → <emphasis role="strong">Maven</emphasis> → <emphasis role="strong">Existing Maven Projects</emphasis>, or the equivalent option for importing a Maven project.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Browse</emphasis>, navigate to
<literal>~/rhdm-7.10.0-sources/src/drools-$VERSION/drools-examples</literal> (or, for the Conway’s Game of Life example, <literal>~/rhdm-7.10.0-sources/src/droolsjbpm-integration-$VERSION/droolsjbpm-integration-examples</literal>),
and import the project.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the example package that you want to run and find the Java class with the <literal>main</literal> method.</simpara>
</listitem>
<listitem>
<simpara>Right-click the Java class and select <emphasis role="strong">Run As</emphasis> → <emphasis role="strong">Java Application</emphasis> to run the example.</simpara>
<simpara>To run all examples through a basic user interface, run the <literal>DroolsExamplesApp.java</literal> class (or, for Conway’s Game of Life, the <literal>DroolsJbpmIntegrationExamplesApp.java</literal> class) in the <literal>org.drools.examples</literal> main class.</simpara>
<figure>
<title>Interface for all examples in drools-examples (DroolsExamplesApp.java)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/All/drools-examples-run-all.png" align="center"/>
</imageobject>
<textobject><phrase>drools examples run all</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Interface for all examples in droolsjbpm-integration-examples (DroolsJbpmIntegrationExamplesApp.java)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/All/droolsjbpm-examples-run-all.png" align="center"/>
</imageobject>
<textobject><phrase>droolsjbpm examples run all</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
</section>
<section xml:id="decision-examples-helloworld-ref_drl-rules">
<title>Hello World example decisions (basic rules and debugging)</title>
<simpara>The Hello World example decision set demonstrates how to insert objects into the decision engine working memory, how to match the objects using rules, and how to configure logging to trace the internal activity of the decision engine.</simpara>
<simpara>The following is an overview of the Hello World example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>helloworld</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.helloworld.HelloWorldExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.helloworld.HelloWorld.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates basic rule execution and use of debug output</simpara>
</listitem>
</itemizedlist>
<simpara>In the Hello World example, a KIE session is generated to enable rule execution. All rules require a KIE session for execution.</simpara>
<formalpara>
<title>KIE session for rule execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get(); <co xml:id="CO9-1"/>
KieContainer kc = ks.getKieClasspathContainer(); <co xml:id="CO9-2"/>
KieSession ksession = kc.newKieSession("HelloWorldKS"); <co xml:id="CO9-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>Obtains the <literal>KieServices</literal> factory. This is the main interface that applications use to interact with the decision engine.</para>
</callout>
<callout arearefs="CO9-2">
<para>Creates a <literal>KieContainer</literal> from the project class path. This detects a <emphasis role="strong">/META-INF/kmodule.xml</emphasis> file from which it configures and instantiates a <literal>KieContainer</literal> with a <literal>KieModule</literal>.</para>
</callout>
<callout arearefs="CO9-3">
<para>Creates a <literal>KieSession</literal> based on the <literal>"HelloWorldKS"</literal> KIE session configuration defined in the <emphasis role="strong">/META-INF/kmodule.xml</emphasis> file.</para>
</callout>
</calloutlist>
<note>
<simpara>For more information about Red Hat Decision Manager project packaging, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
<simpara>Red Hat Decision Manager has an event model that exposes internal engine activity. Two default debug listeners, <literal>DebugAgendaEventListener</literal> and <literal>DebugRuleRuntimeEventListener</literal>, print debug event information to the <literal>System.err</literal> output. The <literal>KieRuntimeLogger</literal> provides execution auditing, the result of which you can view in a graphical viewer.</simpara>
<formalpara>
<title>Debug listeners and audit loggers</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Set up listeners.
ksession.addEventListener( new DebugAgendaEventListener() );
ksession.addEventListener( new DebugRuleRuntimeEventListener() );

// Set up a file-based audit logger.
KieRuntimeLogger logger = KieServices.get().getLoggers().newFileLogger( ksession, "./target/helloworld" );

// Set up a ThreadedFileLogger so that the audit view reflects events while debugging.
KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, "./target/helloworld", 1000 );</programlisting>
</para>
</formalpara>
<simpara>The logger is a specialized implementation built on the <literal>Agenda</literal> and <literal>RuleRuntime</literal> listeners. When the decision engine has finished executing, <literal>logger.close()</literal> is called.</simpara>
<simpara>The example creates a single <literal>Message</literal> object with the message <literal>"Hello World"</literal>, inserts the status <literal>HELLO</literal> into the <literal>KieSession</literal>, executes rules with <literal>fireAllRules()</literal>.</simpara>
<formalpara>
<title>Data insertion and execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Insert facts into the KIE session.
final Message message = new Message();
message.setMessage( "Hello World" );
message.setStatus( Message.HELLO );
ksession.insert( message );

// Fire the rules.
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>Rule execution uses a data model to pass data as inputs and outputs to the <literal>KieSession</literal>. The data model in this example has two fields: the <literal>message</literal>, which is a <literal>String</literal>, and the <literal>status</literal>, which can be <literal>HELLO</literal> or <literal>GOODBYE</literal>.</simpara>
<formalpara>
<title>Data model class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status;
    ...
}</programlisting>
</para>
</formalpara>
<simpara>The two rules are located in the file <literal>src/main/resources/org/drools/examples/helloworld/HelloWorld.drl</literal>.</simpara>
<simpara>The <literal>when</literal> condition of the <literal>"Hello World"</literal> rule states that the rule is activated for each <literal>Message</literal> object inserted into the KIE session that has the status <literal>Message.HELLO</literal>. Additionally, two variable bindings are created: the variable <literal>message</literal> is bound to the <literal>message</literal> attribute and the variable <literal>m</literal> is bound to the matched <literal>Message</literal> object itself.</simpara>
<simpara>The <literal>then</literal> action of the rule specifies to print the content of the bound variable <literal>message</literal> to <literal>System.out</literal>, and then changes the values of the <literal>message</literal> and <literal>status</literal> attributes of the <literal>Message</literal> object bound to <literal>m</literal>. The rule uses the <literal>modify</literal> statement to apply a block of assignments in one statement and to notify the decision engine of the changes at the end of the block.</simpara>
<formalpara>
<title>"Hello World" rule</title>
<para>
<screen>rule "Hello World"
  when
    m : Message( status == Message.HELLO, message : message )
  then
    System.out.println( message );
    modify ( m ) { message = "Goodbye cruel world",
                   status = Message.GOODBYE };
end</screen>
</para>
</formalpara>
<simpara>The <literal>"Good Bye"</literal> rule is similar to the <literal>"Hello World"</literal> rule except that it matches <literal>Message</literal> objects that have the status <literal>Message.GOODBYE</literal>.</simpara>
<formalpara>
<title>"Good Bye" rule</title>
<para>
<screen>rule "Good Bye"
  when
    Message( status == Message.GOODBYE, message : message )
  then
    System.out.println( message );
end</screen>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.helloworld.HelloWorldExample</literal> class as a Java application in your IDE. The rule writes to <literal>System.out</literal>, the debug listener writes to <literal>System.err</literal>, and the audit logger creates a log file in <literal>target/helloworld.log</literal>.</simpara>
<formalpara>
<title>System.out output in the IDE console</title>
<para>
<screen>Hello World
Goodbye cruel world</screen>
</para>
</formalpara>
<formalpara>
<title>System.err output in the IDE console</title>
<para>
<screen>==&gt;[ActivationCreated(0): rule=Hello World;
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                 object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World;
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye;
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                old_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96;
                new_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye;
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]</screen>
</para>
</formalpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/helloworld.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit view</emphasis> shows that the object is inserted, which creates an activation for the <literal>"Hello World"</literal> rule. The activation is then executed, which updates the <literal>Message</literal> object and causes the <literal>"Good Bye"</literal> rule to activate. Finally, the <literal>"Good Bye"</literal> rule is executed. When you select an event in the <emphasis role="strong">Audit View</emphasis>, the origin event, which is the <literal>"Activation created"</literal> event in this example, is highlighted in green.</simpara>
<figure>
<title>Hello World example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/HelloWorldExample/helloworld_auditview1.png" align="center"/>
</imageobject>
<textobject><phrase>helloworld auditview1</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="decision-examples-state-ref_drl-rules">
<title>State example decisions (forward chaining and conflict resolution)</title>
<simpara>The State example decision set demonstrates how the decision engine uses forward chaining and any changes to facts in the working memory to resolve execution conflicts for rules in a sequence. The example focuses on resolving conflicts through salience values or through agenda groups that you can define in rules.</simpara>
<simpara>The following is an overview of the State example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>state</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main classes</emphasis>: <literal>org.drools.examples.state.StateExampleUsingSalience</literal>, <literal>org.drools.examples.state.StateExampleUsingAgendaGroup</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.state.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates forward chaining and conflict resolution through rule salience and agenda groups</simpara>
</listitem>
</itemizedlist>
<simpara>A forward-chaining rule system is a data-driven system that starts with a fact in the working memory of the decision engine and reacts to changes to that fact. When objects are inserted into working memory, any rule conditions that become true as a result of the change are scheduled for execution by the agenda.</simpara>
<simpara>In contrast, a backward-chaining rule system is a goal-driven system that starts with a conclusion that the decision engine attempts to satisfy, often using recursion. If the system cannot reach the conclusion or goal, it searches for subgoals, which are conclusions that complete part of the current goal. The system continues this process until either the initial conclusion is satisfied or all subgoals are satisfied.</simpara>
<simpara>The decision engine in Red Hat Decision Manager uses both forward and backward chaining to evaluate rules.</simpara>
<simpara>The following diagram illustrates how the decision engine evaluates rules using forward chaining overall with a backward-chaining segment in the logic flow:</simpara>
<figure>
<title>Rule evaluation logic using forward and backward chaining</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/RuleEvaluation_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>RuleEvaluation Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the State example, each <literal>State</literal> class has fields for its name and its current state (see the class <literal>org.drools.examples.state.State</literal>). The following states are the two possible states for each object:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NOTRUN</literal></simpara>
</listitem>
<listitem>
<simpara><literal>FINISHED</literal></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>State class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</programlisting>
</para>
</formalpara>
<simpara>The State example contains two versions of the same example to resolve rule execution conflicts:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>StateExampleUsingSalience</literal> version that resolves conflicts by using rule salience</simpara>
</listitem>
<listitem>
<simpara>A <literal>StateExampleUsingAgendaGroups</literal> version that resolves conflicts by using rule agenda groups</simpara>
</listitem>
</itemizedlist>
<simpara>Both versions of the state example involve four <literal>State</literal> objects: <literal>A</literal>, <literal>B</literal>, <literal>C</literal>, and <literal>D</literal>. Initially, their states are set to <literal>NOTRUN</literal>, which is the default value for the constructor that the example uses.</simpara>
<bridgehead xml:id="state_example_using_salience" renderas="sect3" remap="_state_example_using_salience">State example using salience</bridgehead>
<simpara>The <literal>StateExampleUsingSalience</literal> version of the State example uses salience values in rules to resolve rule execution conflicts. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara>
<simpara>The example inserts each <literal>State</literal> instance into the KIE session and then calls <literal>fireAllRules()</literal>.</simpara>
<formalpara>
<title>Salience State example execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">final State a = new State( "A" );
final State b = new State( "B" );
final State c = new State( "C" );
final State d = new State( "D" );

ksession.insert( a );
ksession.insert( b );
ksession.insert( c );
ksession.insert( d );

ksession.fireAllRules();

// Dispose KIE session if stateful (not required if stateless).
ksession.dispose();</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.state.StateExampleUsingSalience</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Salience State example output in the IDE console</title>
<para>
<screen>A finished
B finished
C finished
D finished</screen>
</para>
</formalpara>
<simpara>Four rules are present.</simpara>
<simpara>First, the <literal>"Bootstrap"</literal> rule fires, setting <literal>A</literal> to state <literal>FINISHED</literal>, which then causes <literal>B</literal> to change its state to <literal>FINISHED</literal>. Objects <literal>C</literal> and <literal>D</literal> are both dependent on <literal>B</literal>, causing a conflict that is resolved by the salience values.</simpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/state.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows that the assertion of the object <literal>A</literal> in the state <literal>NOTRUN</literal> activates the <literal>"Bootstrap"</literal> rule, while the assertions of the other objects have no immediate effect.</simpara>
<figure>
<title>Salience State example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/StateExample/state_example_audit1.png" align="center"/>
</imageobject>
<textobject><phrase>state example audit1</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Rule "Bootstrap" in salience State example</title>
<para>
<screen>rule "Bootstrap"
  when
    a : State(name == "A", state == State.NOTRUN )
  then
    System.out.println(a.getName() + " finished" );
    a.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>The execution of the <literal>"Bootstrap"</literal> rule changes the state of <literal>A</literal> to <literal>FINISHED</literal>, which activates rule <literal>"A to B"</literal>.</simpara>
<formalpara>
<title>Rule "A to B" in salience State example</title>
<para>
<screen>rule "A to B"
  when
    State(name == "A", state == State.FINISHED )
    b : State(name == "B", state == State.NOTRUN )
  then
    System.out.println(b.getName() + " finished" );
    b.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>The execution of rule <literal>"A to B"</literal> changes the state of <literal>B</literal> to <literal>FINISHED</literal>, which activates both rules <literal>"B to C"</literal> and <literal>"B to D"</literal>, placing their activations onto the decision engine agenda.</simpara>
<formalpara>
<title>Rules "B to C" and "B to D" in salience State example</title>
<para>
<screen>rule "B to C"
    salience 10
  when
    State(name == "B", state == State.FINISHED )
    c : State(name == "C", state == State.NOTRUN )
  then
    System.out.println(c.getName() + " finished" );
    c.setState( State.FINISHED );
end

rule "B to D"
  when
    State(name == "B", state == State.FINISHED )
    d : State(name == "D", state == State.NOTRUN )
  then
    System.out.println(d.getName() + " finished" );
    d.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>From this point on, both rules may fire and, therefore, the rules are in conflict. The conflict resolution strategy enables the decision engine agenda to decide which rule to fire. Rule <literal>"B to C"</literal> has the higher salience value (<literal>10</literal> versus the default salience value of <literal>0</literal>), so it fires first, modifying object <literal>C</literal> to state <literal>FINISHED</literal>.</simpara>
<simpara>The <emphasis role="strong">Audit View</emphasis> in your IDE shows the modification of the <literal>State</literal> object in the rule <literal>"A to B"</literal>, which results in two activations being in conflict.</simpara>
<simpara>You can also use the <emphasis role="strong">Agenda View</emphasis> in your IDE to investigate the state of the decision engine agenda. In this example, the <emphasis role="strong">Agenda View</emphasis> shows the breakpoint in the rule <literal>"A to B"</literal> and the state of the agenda with the two conflicting rules. Rule <literal>"B to D"</literal> fires last, modifying object <literal>D</literal> to state <literal>FINISHED</literal>.</simpara>
<figure>
<title>Salience State example Agenda View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/StateExample/state_example_agenda1.png" align="center"/>
</imageobject>
<textobject><phrase>state example agenda1</phrase></textobject>
</mediaobject>
</figure>
<bridgehead xml:id="state_example_using_agenda_groups" renderas="sect3" remap="_state_example_using_agenda_groups">State example using agenda groups</bridgehead>
<simpara>The <literal>StateExampleUsingAgendaGroups</literal> version of the State example uses agenda groups in rules to resolve rule execution conflicts. Agenda groups enable you to partition the decision engine agenda to provide more execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>Initially, a working memory has its focus on the agenda group <literal>MAIN</literal>. Rules in an agenda group only fire when the group receives the focus. You can set the focus either by using the method <literal>setFocus()</literal> or the rule attribute <literal>auto-focus</literal>. The <literal>auto-focus</literal> attribute enables the rule to be given a focus automatically for its agenda group when the rule is matched and activated.</simpara>
<simpara>In this example, the <literal>auto-focus</literal> attribute enables rule <literal>"B to C"</literal> to fire before <literal>"B to D"</literal>.</simpara>
<formalpara>
<title>Rule "B to C" in agenda group State example</title>
<para>
<screen>rule "B to C"
    agenda-group "B to C"
    auto-focus true
  when
    State(name == "B", state == State.FINISHED )
    c : State(name == "C", state == State.NOTRUN )
  then
    System.out.println(c.getName() + " finished" );
    c.setState( State.FINISHED );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"B to C"</literal> calls <literal>setFocus()</literal> on the agenda group <literal>"B to D"</literal>, enabling its active rules to fire, which then enables the rule <literal>"B to D"</literal> to fire.</simpara>
<formalpara>
<title>Rule "B to D" in agenda group State example</title>
<para>
<screen>rule "B to D"
    agenda-group "B to D"
  when
    State(name == "B", state == State.FINISHED )
    d : State(name == "D", state == State.NOTRUN )
  then
    System.out.println(d.getName() + " finished" );
    d.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.state.StateExampleUsingAgendaGroups</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window (same as the salience version of the State example):</simpara>
<formalpara>
<title>Agenda group State example output in the IDE console</title>
<para>
<screen>A finished
B finished
C finished
D finished</screen>
</para>
</formalpara>
<bridgehead xml:id="dynamic_facts_in_the_state_example" renderas="sect3" remap="_dynamic_facts_in_the_state_example">Dynamic facts in the State example</bridgehead>
<simpara>Another notable concept in this State example is the use of <emphasis>dynamic facts</emphasis>, based on objects that implement a <literal>PropertyChangeListener</literal> object. In order for the decision engine to see and react to changes of fact properties, the application must notify the decision engine that changes occurred. You can configure this communication explicitly in the rules by using the <literal>modify</literal> statement, or implicitly by specifying that the facts implement the <literal>PropertyChangeSupport</literal> interface as defined by the JavaBeans specification.</simpara>
<simpara>This example demonstrates how to use the <literal>PropertyChangeSupport</literal> interface to avoid the need for explicit <literal>modify</literal> statements in the rules. To make use of this interface, ensure that your facts implement <literal>PropertyChangeSupport</literal> in the same way that the class <literal>org.drools.example.State</literal> implements it, and then use the following code in the DRL rule file to configure the decision engine to listen for property changes on those facts:</simpara>
<formalpara>
<title>Declaring a dynamic fact</title>
<para>
<screen>declare type State
  @propertyChangeSupport
end</screen>
</para>
</formalpara>
<simpara>When you use <literal>PropertyChangeListener</literal> objects, each setter must implement additional code for the notification. For example, the following setter for <literal>state</literal> is in the class <literal>org.drools.examples</literal>:</simpara>
<formalpara>
<title>Setter example with PropertyChangeSupport</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-fibonacci-ref_drl-rules">
<title>Fibonacci example decisions (recursion and conflict resolution)</title>
<simpara>The Fibonacci example decision set demonstrates how the decision engine uses recursion to resolve execution conflicts for rules in a sequence. The example focuses on resolving conflicts through salience values that you can define in rules.</simpara>
<simpara>The following is an overview of the Fibonacci example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>fibonacci</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.fibonacci.FibonacciExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.fibonacci.Fibonacci.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates recursion and conflict resolution through rule salience</simpara>
</listitem>
</itemizedlist>
<simpara>The Fibonacci Numbers form a sequence starting with 0 and 1. The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, and so on.</simpara>
<simpara>The Fibonacci example uses the single fact class <literal>Fibonacci</literal> with the following two fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>sequence</literal></simpara>
</listitem>
<listitem>
<simpara><literal>value</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>sequence</literal> field indicates the position of the object in the Fibonacci number sequence. The <literal>value</literal> field shows the value of that Fibonacci object for that sequence position, where <literal>-1</literal> indicates a value that still needs to be computed.</simpara>
<formalpara>
<title>Fibonacci class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static class Fibonacci {
    private int  sequence;
    private long value;

    public Fibonacci( final int sequence ) {
        this.sequence = sequence;
        this.value = -1;
    }

    ... setters and getters go here...
}</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.fibonacci.FibonacciExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Fibonacci example output in the IDE console</title>
<para>
<screen>recurse for 50
recurse for 49
recurse for 48
recurse for 47
...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025</screen>
</para>
</formalpara>
<simpara>To achieve this behavior in Java, the example inserts a single <literal>Fibonacci</literal> object with a sequence field of <literal>50</literal>. The example then uses a recursive rule to insert the other 49 <literal>Fibonacci</literal> objects.</simpara>
<simpara>Instead of implementing the <literal>PropertyChangeSupport</literal> interface to use dynamic facts, this example uses the MVEL dialect <literal>modify</literal> keyword to enable a block setter action and notify the decision engine of changes.</simpara>
<formalpara>
<title>Fibonacci example execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.insert( new Fibonacci( 50 ) );
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>This example uses the following three rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Recurse"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Bootstrap"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Calculate"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The rule <literal>"Recurse"</literal> matches each asserted <literal>Fibonacci</literal> object with a value of <literal>-1</literal>, creating and asserting a new <literal>Fibonacci</literal> object with a sequence of one less than the currently matched object. Each time a Fibonacci object is added while the one with a sequence field equal to <literal>1</literal> does not exist, the rule re-matches and fires again. The <literal>not</literal> conditional element is used to stop the rule matching once you have all 50 Fibonacci objects in memory. The rule also has a <literal>salience</literal> value because you need to have all 50 <literal>Fibonacci</literal> objects asserted before you execute the <literal>"Bootstrap"</literal> rule.</simpara>
<formalpara>
<title>Rule "Recurse"</title>
<para>
<screen>rule "Recurse"
    salience 10
  when
    f : Fibonacci ( value == -1 )
    not ( Fibonacci ( sequence == 1 ) )
  then
    insert( new Fibonacci( f.sequence - 1 ) );
    System.out.println( "recurse for " + f.sequence );
end</screen>
</para>
</formalpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/fibonacci.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows the original assertion of the <literal>Fibonacci</literal> object with a <literal>sequence</literal> field of <literal>50</literal>, done from Java code. From there on, the <emphasis role="strong">Audit View</emphasis> shows the continual recursion of the rule, where each asserted <literal>Fibonacci</literal> object causes the <literal>"Recurse"</literal> rule to become activated and to fire again.</simpara>
<figure>
<title>Rule "Recurse" in Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci1.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When a <literal>Fibonacci</literal> object with a <literal>sequence</literal> field of <literal>2</literal> is asserted, the <literal>"Bootstrap"</literal> rule is matched and activated along with the <literal>"Recurse"</literal> rule. Notice the multiple restrictions on field <literal>sequence</literal> that test for equality with <literal>1</literal> or <literal>2</literal>:</simpara>
<formalpara>
<title>Rule "Bootstrap"</title>
<para>
<screen>rule "Bootstrap"
  when
    f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction
  then
    modify ( f ){ value = 1 };
    System.out.println( f.sequence + " == " + f.value );
end</screen>
</para>
</formalpara>
<simpara>You can also use the <emphasis role="strong">Agenda View</emphasis> in your IDE to investigate the state of the decision engine agenda. The <literal>"Bootstrap"</literal> rule does not fire yet because the <literal>"Recurse"</literal> rule has a higher salience value.</simpara>
<figure>
<title>Rules "Recurse" and "Bootstrap" in Agenda View 1</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci_agenda1.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci agenda1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When a <literal>Fibonacci</literal> object with a <literal>sequence</literal> of <literal>1</literal> is asserted, the <literal>"Bootstrap"</literal> rule is matched again, causing two activations for this rule. The <literal>"Recurse"</literal> rule does not match and activate because the <literal>not</literal> conditional element stops the rule matching as soon as a <literal>Fibonacci</literal> object with a <literal>sequence</literal> of <literal>1</literal> exists.</simpara>
<figure>
<title>Rules "Recurse" and "Bootstrap" in Agenda View 2</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci_agenda2.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci agenda2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>"Bootstrap"</literal> rule sets the objects with a <literal>sequence</literal> of <literal>1</literal> and <literal>2</literal> to a value of <literal>1</literal>. Now that you have two <literal>Fibonacci</literal> objects with values not equal to <literal>-1</literal>, the <literal>"Calculate"</literal> rule is able to match.</simpara>
<simpara>At this point in the example, nearly 50 <literal>Fibonacci</literal> objects exist in the working memory. You need to select a suitable triple to calculate each of their values in turn. If you use three Fibonacci patterns in a rule without field constraints to confine the possible cross products, the result would be 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect.</simpara>
<simpara>The <literal>"Calculate"</literal> rule uses field constraints to evaluate the three Fibonacci patterns in the correct order. This technique is called <emphasis>cross-product matching</emphasis>.</simpara>
<simpara>The first pattern finds any <literal>Fibonacci</literal> object with a value <literal>!= -1</literal> and binds both the pattern and the field. The second <literal>Fibonacci</literal> object does the same thing, but adds an additional field constraint to ensure that its sequence is greater by one than the <literal>Fibonacci</literal> object bound to <literal>f1</literal>. When this rule fires for the first time, you know that only sequences <literal>1</literal> and <literal>2</literal> have values of <literal>1</literal>, and the two constraints ensure that <literal>f1</literal> references sequence <literal>1</literal> and that <literal>f2</literal> references sequence <literal>2</literal>.</simpara>
<simpara>The final pattern finds the <literal>Fibonacci</literal> object with a value equal to <literal>-1</literal> and with a sequence one greater than <literal>f2</literal>.</simpara>
<simpara>At this point in the example, three <literal>Fibonacci</literal> objects are correctly selected from the available cross products, and you can calculate the value for the third <literal>Fibonacci</literal> object that is bound to <literal>f3</literal>.</simpara>
<formalpara>
<title>Rule "Calculate"</title>
<para>
<screen>rule "Calculate"
  when
    // Bind f1 and s1.
    f1 : Fibonacci( s1 : sequence, value != -1 )
    // Bind f2 and v2, refer to bound variable s1.
    f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 )
    // Bind f3 and s3, alternative reference of f2.sequence.
    f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )
  then
    // Note the various referencing techniques.
    modify ( f3 ) { value = f1.value + v2 };
    System.out.println( s3 + " == " + f3.value );
end</screen>
</para>
</formalpara>
<simpara>The <literal>modify</literal> statement updates the value of the <literal>Fibonacci</literal> object bound to <literal>f3</literal>. This means that you now have another new <literal>Fibonacci</literal> object with a value not equal to <literal>-1</literal>, which allows the <literal>"Calculate"</literal> rule to re-match and calculate the next Fibonacci number.</simpara>
<simpara>The debug view or <emphasis role="strong">Audit View</emphasis> of your IDE shows how the firing of the last <literal>"Bootstrap"</literal> rule modifies the <literal>Fibonacci</literal> object, enabling the <literal>"Calculate"</literal> rule to match, which then modifies another <literal>Fibonacci</literal> object that enables the <literal>"Calculate"</literal> rule to match again. This process continues until the value is set for all <literal>Fibonacci</literal> objects.</simpara>
<figure>
<title>Rules in Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci4.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci4</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="decision-examples-pricing-ref_drl-rules">
<title>Pricing example decisions (decision tables)</title>
<simpara>The Pricing example decision set demonstrates how to use a spreadsheet decision table for calculating the retail cost of an insurance policy in tabular format instead of directly in a DRL file.</simpara>
<simpara>The following is an overview of the Pricing example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>decisiontable</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.decisiontable.PricingRuleDTExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.decisiontable.ExamplePolicyPricing.xls</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates use of spreadsheet decision tables to define rules</simpara>
</listitem>
</itemizedlist>
<simpara>Spreadsheet decision tables are XLS or XLSX spreadsheets that contain business rules defined in a tabular format. You can include spreadsheet decision tables with standalone Red Hat Decision Manager projects or upload them to projects in Business Central. Each row in a decision table is a rule, and each column is a condition, an action, or another rule attribute. After you create and upload your decision tables into your Red Hat Decision Manager project, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>The purpose of the Pricing example is to provide a set of business rules to calculate the base price and a discount for a car driver applying for a specific type of insurance policy. The driver’s age and history and the policy type all contribute to calculate the basic premium, and additional rules calculate potential discounts for which the driver might be eligible.</simpara>
<simpara>To execute the example, run the <literal>org.drools.examples.decisiontable.PricingRuleDTExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<screen>Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20</screen>
<simpara>The code to execute the example follows the typical execution pattern: the rules are loaded, the facts are inserted, and a stateless KIE session is created. The difference in this example is that the rules are defined in an <literal>ExamplePolicyPricing.xls</literal> file instead of a DRL file or other source. The spreadsheet file is loaded into the decision engine using templates and DRL rules.</simpara>
<bridgehead xml:id="spreadsheet_decision_table_setup" renderas="sect3" remap="_spreadsheet_decision_table_setup">Spreadsheet decision table setup</bridgehead>
<simpara>The <literal>ExamplePolicyPricing.xls</literal> spreadsheet contains two decision tables in the first tab:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Base pricing rules</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Promotional discount rules</literal></simpara>
</listitem>
</itemizedlist>
<simpara>As the example spreadsheet demonstrates, you can use only the first tab of a spreadsheet to create decision tables, but multiple tables can be within a single tab. Decision tables do not necessarily follow top-down logic, but are more of a means to capture data resulting in rules. The evaluation of the rules is not necessarily in the given order, because all of the normal mechanics of the decision engine still apply. This is why you can have multiple decision tables in the same tab of a spreadsheet.</simpara>
<simpara>The decision tables are executed through the corresponding rule template files <literal>BasePricing.drt</literal> and <literal>PromotionalPricing.drt</literal>. These template files reference the decision tables through their template parameter and directly reference the various headers for the conditions and actions in the decision tables.</simpara>
<formalpara>
<title>BasePricing.drt rule template file</title>
<para>
<screen>template header
age[]
profile
priorClaims
policyType
base
reason

package org.drools.examples.decisiontable;

template "Pricing bracket"
age
policyType
base

rule "Pricing bracket_@{row.rowNumber}"
  when
    Driver(age &gt;= @{age0}, age &lt;= @{age1}
        , priorClaims == "@{priorClaims}"
        , locationRiskProfile == "@{profile}"
    )
    policy: Policy(type == "@{policyType}")
  then
    policy.setBasePrice(@{base});
    System.out.println("@{reason}");
end
end template</screen>
</para>
</formalpara>
<formalpara>
<title>PromotionalPricing.drt rule template file</title>
<para>
<screen>template header
age[]
priorClaims
policyType
discount

package org.drools.examples.decisiontable;

template "discounts"
age
priorClaims
policyType
discount

rule "Discounts_@{row.rowNumber}"
  when
    Driver(age &gt;= @{age0}, age &lt;= @{age1}, priorClaims == "@{priorClaims}")
    policy: Policy(type == "@{policyType}")
  then
    policy.applyDiscount(@{discount});
end
end template</screen>
</para>
</formalpara>
<simpara>The rules are executed through the <literal>kmodule.xml</literal> reference of the KIE Session <literal>DTableWithTemplateKB</literal>, which specifically mentions the <literal>ExamplePolicyPricing.xls</literal> spreadsheet and is required for successful execution of the rules. This execution method enables you to execute the rules as a standalone unit (as in this example) or to include the rules in a packaged knowledge JAR (KJAR) file, so that the spreadsheet is packaged along with the rules for execution.</simpara>
<simpara>The following section of the <literal>kmodule.xml</literal> file is required for the execution of the rules and spreadsheet to work successfully:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;kbase name="DecisionTableKB" packages="org.drools.examples.decisiontable"&gt;
        &lt;ksession name="DecisionTableKS" type="stateless"/&gt;
    &lt;/kbase&gt;

    &lt;kbase name="DTableWithTemplateKB" packages="org.drools.examples.decisiontable-template"&gt;
        &lt;ruleTemplate dtable="org/drools/examples/decisiontable-template/ExamplePolicyPricingTemplateData.xls"
                      template="org/drools/examples/decisiontable-template/BasePricing.drt"
                      row="3" col="3"/&gt;
        &lt;ruleTemplate dtable="org/drools/examples/decisiontable-template/ExamplePolicyPricingTemplateData.xls"
                      template="org/drools/examples/decisiontable-template/PromotionalPricing.drt"
                      row="18" col="3"/&gt;
        &lt;ksession name="DTableWithTemplateKS"/&gt;
    &lt;/kbase&gt;</programlisting>
<simpara>As an alternative to executing the decision tables using rule template files, you can use the <literal>DecisionTableConfiguration</literal> object and specify an input spreadsheet as the input type, such as <literal>DecisionTableInputType.xls</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">DecisionTableConfiguration dtableconfiguration =
    KnowledgeBuilderFactory.newDecisionTableConfiguration();
        dtableconfiguration.setInputType( DecisionTableInputType.XLS );

        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        Resource xlsRes = ResourceFactory.newClassPathResource( "ExamplePolicyPricing.xls",
                                                                getClass() );
        kbuilder.add( xlsRes,
                      ResourceType.DTABLE,
                      dtableconfiguration );</programlisting>
<simpara>The Pricing example uses two fact types:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Driver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Policy</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The example sets the default values for both facts in their respective Java classes <literal>Driver.java</literal> and <literal>Policy.java</literal>. The <literal>Driver</literal> is 30 years old, has had no prior claims, and currently has a risk profile of <literal>LOW</literal>. The <literal>Policy</literal> that the driver is applying for is <literal>COMPREHENSIVE</literal>.</simpara>
<simpara>In any decision table, each row is considered a different rule and each column is a condition or an action. Each row is evaluated in a decision table unless the agenda is cleared upon execution.</simpara>
<simpara>Decision table spreadsheets (XLS or XLSX) require two key areas that define rule data:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>RuleSet</literal> area</simpara>
</listitem>
<listitem>
<simpara>A <literal>RuleTable</literal> area</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>RuleSet</literal> area of the spreadsheet defines elements that you want to apply globally to all rules in the same package (not only the spreadsheet), such as a rule set name or universal rule attributes. The <literal>RuleTable</literal> area defines the actual rules (rows) and the conditions, actions, and other rule attributes (columns) that constitute that rule table within the specified rule set. A decision table spreadsheet can contain multiple <literal>RuleTable</literal> areas, but only one <literal>RuleSet</literal> area.</simpara>
<figure>
<title>Decision table configuration</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Config.png" align="center"/>
</imageobject>
<textobject><phrase>DT Config</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>RuleTable</literal> area also defines the objects to which the rule attributes apply, in this case <literal>Driver</literal> and <literal>Policy</literal>, followed by constraints on the objects. For example, the <literal>Driver</literal> object constraint that defines the <literal>Age Bracket</literal> column is <literal>age &gt;= $1, age &lt;= $2</literal>, where the comma-separated range is defined in the table column values, such as <literal>18,24</literal>.</simpara>
<bridgehead xml:id="base_pricing_rules" renderas="sect3" remap="_base_pricing_rules">Base pricing rules</bridgehead>
<simpara>The <literal>Base pricing rules</literal> decision table in the Pricing example evaluates the age, risk profile, number of claims, and policy type of the driver and produces the base price of the policy based on these conditions.</simpara>
<figure>
<title>Base price calculation</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Table1.png" align="center"/>
</imageobject>
<textobject><phrase>DT Table1</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>Driver</literal> attributes are defined in the following table columns:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Age Bracket</literal>: The age bracket has a definition for the condition <literal>age &gt;=$1, age &lt;=$2</literal>, which defines the condition boundaries for the driver’s age. This condition column highlights the use of <literal>$1 and $2</literal>, which is comma delimited in the spreadsheet. You can write these values as <literal>18,24</literal> or <literal>18, 24</literal> and both formats work in the execution of the business rules.</simpara>
</listitem>
<listitem>
<simpara><literal>Location risk profile</literal>: The risk profile is a string that the example program passes always as <literal>LOW</literal> but can be changed to reflect <literal>MED</literal> or <literal>HIGH</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Number of prior claims</literal>: The number of claims is defined as an integer that the condition column must exactly equal to trigger the action. The value is not a range, only exact matches.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>Policy</literal> of the decision table is used in both the conditions and the actions of the rule and has attributes defined in the following table columns:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Policy type applying for</literal>: The policy type is a condition that is passed as a string that defines the type of coverage: <literal>COMPREHENSIVE</literal>, <literal>FIRE_THEFT</literal>, or <literal>THIRD_PARTY</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Base $ AUD</literal>: The <literal>basePrice</literal> is defined as an <literal>ACTION</literal> that sets the price through the constraint <literal>policy.setBasePrice($param);</literal> based on the spreadsheet cells corresponding to this value. When you execute the corresponding DRL rule for this decision table, the <literal>then</literal> portion of the rule executes this action statement on the true conditions matching the facts and sets the base price to the corresponding value.</simpara>
</listitem>
<listitem>
<simpara><literal>Record Reason</literal>: When the rule successfully executes, this action generates an output message to the <literal>System.out</literal> console reflecting which rule fired. This is later captured in the application and printed.</simpara>
</listitem>
</itemizedlist>
<simpara>The example also uses the first column on the left to categorize rules. This column is for annotation only and has no affect on rule execution.</simpara>
<bridgehead xml:id="promotional_discount_rules" renderas="sect3" remap="_promotional_discount_rules">Promotional discount rules</bridgehead>
<simpara>The <literal>Promotional discount rules</literal> decision table in the Pricing example evaluates the age, number of prior claims, and policy type of the driver to generate a potential discount on the price of the insurance policy.</simpara>
<figure>
<title>Discount calculation</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Table2.png" align="center"/>
</imageobject>
<textobject><phrase>DT Table2</phrase></textobject>
</mediaobject>
</figure>
<simpara>This decision table contains the conditions for the discount for which the driver might be eligible. Similar to the base price calculation, this table evaluates the <literal>Age</literal>, <literal>Number of prior claims</literal> of the driver, and the <literal>Policy type applying for</literal> to determine a <literal>Discount %</literal> rate to be applied. For example, if the driver is 30 years old, has no prior claims, and is applying for a <literal>COMPREHENSIVE</literal> policy, the driver is given a discount of <literal>20</literal> percent.</simpara>
</section>
<section xml:id="decision-examples-petstore-ref_drl-rules">
<title>Pet Store example decisions (agenda groups, global variables, callbacks, and GUI integration)</title>
<simpara>The Pet Store example decision set demonstrates how to use agenda groups and global variables in rules and how to integrate Red Hat Decision Manager rules with a graphical user interface (GUI), in this case a Swing-based desktop application. The example also demonstrates how to use callbacks to interact with a running decision engine to update the GUI based on changes in the working memory at run time.</simpara>
<simpara>The following is an overview of the Pet Store example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>petstore</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.petstore.PetStoreExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.petstore.PetStore.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates rule agenda groups, global variables, callbacks, and GUI integration</simpara>
</listitem>
</itemizedlist>
<simpara>In the Pet Store example, the sample <literal>PetStoreExample.java</literal> class defines the following principal classes (in addition to several classes to handle Swing events):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Petstore</literal> contains the <literal>main()</literal> method.</simpara>
</listitem>
<listitem>
<simpara><literal>PetStoreUI</literal> is responsible for creating and displaying the Swing-based GUI. This class contains several smaller classes, mainly for responding to various GUI events, such as user mouse clicks.</simpara>
</listitem>
<listitem>
<simpara><literal>TableModel</literal> holds the table data. This class is essentially a JavaBean that extends the Swing class <literal>AbstractTableModel</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>CheckoutCallback</literal> enables the GUI to interact with the rules.</simpara>
</listitem>
<listitem>
<simpara><literal>Ordershow</literal> keeps the items that you want to buy.</simpara>
</listitem>
<listitem>
<simpara><literal>Purchase</literal> stores details of the order and the products that you are buying.</simpara>
</listitem>
<listitem>
<simpara><literal>Product</literal> is a JavaBean containing details of the product available for purchase and its price.</simpara>
</listitem>
</itemizedlist>
<simpara>Much of the Java code in this example is either plain JavaBean or Swing based. For more information about Swing components, see the Java tutorial on <link xlink:href="https://docs.oracle.com/javase/tutorial/uiswing/">Creating a GUI with JFC/Swing</link>.</simpara>
<bridgehead xml:id="rule_execution_behavior_in_the_pet_store_example" renderas="sect3" remap="_rule_execution_behavior_in_the_pet_store_example">Rule execution behavior in the Pet Store example</bridgehead>
<simpara>Unlike other example decision sets where the facts are asserted and fired immediately, the Pet Store example does not execute the rules until more facts are gathered based on user interaction. The example executes rules through a <literal>PetStoreUI</literal> object, created by a constructor, that accepts the <literal>Vector</literal> object <literal>stock</literal> for collecting the products. The example then uses an instance of the <literal>CheckoutCallback</literal> class containing the rule base that was previously loaded.</simpara>
<formalpara>
<title>Pet Store KIE container and fact execution setup</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// KieServices is the factory for all KIE services.
KieServices ks = KieServices.Factory.get();

// Create a KIE container on the class path.
KieContainer kc = ks.getKieClasspathContainer();

// Create the stock.
Vector&lt;Product&gt; stock = new Vector&lt;Product&gt;();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the working memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kc ) );
ui.createAndShowGUI();</programlisting>
</para>
</formalpara>
<simpara>The Java code that fires the rules is in the <literal>CheckoutCallBack.checkout()</literal> method. This method is triggered when the user clicks <emphasis role="strong">Checkout</emphasis> in the UI.</simpara>
<formalpara>
<title>Rule execution from CheckoutCallBack.checkout()</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public String checkout(JFrame frame, List&lt;Product&gt; items) {
    Order order = new Order();

    // Iterate through list and add to cart.
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction.

    // From the KIE container, a KIE session is created based on
    // its definition and configuration in the META-INF/kmodule.xml file.
    KieSession ksession = kcontainer.newKieSession("PetStoreKS");

    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );

    // Execute rules.
    ksession.fireAllRules();

    // Return the state of the cart
    return order.toString();
}</programlisting>
</para>
</formalpara>
<simpara>The example code passes two elements into the <literal>CheckoutCallBack.checkout()</literal> method. One element is the handle for the <literal>JFrame</literal> Swing component surrounding the output text frame, found at the bottom of the GUI. The second element is a list of order items, which comes from the <literal>TableModel</literal> that stores the information from the <literal>Table</literal> area at the upper-right section of the GUI.</simpara>
<simpara>The <literal>for</literal> loop transforms the list of order items coming from the GUI into the <literal>Order</literal> JavaBean, also contained in the file <literal>PetStoreExample.java</literal>.</simpara>
<simpara>In this case, the rule is firing in a stateless KIE session because all of the data is stored in Swing components and is not executed until the user clicks <emphasis role="strong">Checkout</emphasis> in the UI. Each time the user clicks <emphasis role="strong">Checkout</emphasis>, the content of the list is moved from the Swing <literal>TableModel</literal> into the KIE session working memory and is then executed with the <literal>ksession.fireAllRules()</literal> method.</simpara>
<simpara>Within this code, there are nine calls to <literal>KieSession</literal>. The first of these creates a new <literal>KieSession</literal> from the <literal>KieContainer</literal> (the example passed in this <literal>KieContainer</literal> from the <literal>CheckoutCallBack</literal> class in the <literal>main()</literal> method). The next two calls pass in the two objects that hold the global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the <literal>KieSession</literal>, as well as the order list. The final call is the standard <literal>fireAllRules()</literal>.</simpara>
<bridgehead xml:id="pet_store_rule_file_imports_global_variables_and_java_functions" renderas="sect3" remap="_pet_store_rule_file_imports_global_variables_and_java_functions">Pet Store rule file imports, global variables, and Java functions</bridgehead>
<simpara>The <literal>PetStore.drl</literal> file contains the standard package and import statements to make various Java classes available to the rules. The rule file also includes <emphasis>global variables</emphasis> to be used within the rules, defined as  <literal>frame</literal> and <literal>textArea</literal>. The global variables hold references to the Swing components <literal>JFrame</literal> and <literal>JTextArea</literal> components that were previously passed on by the Java code that called the <literal>setGlobal()</literal> method. Unlike standard variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the KIE session. This means the contents of these global variables are available for evaluation on all subsequent rules.</simpara>
<formalpara>
<title>PetStore.drl package, imports, and global variables</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.drools.examples;

import org.kie.api.runtime.KieRuntime;
import org.drools.examples.petstore.PetStoreExample.Order;
import org.drools.examples.petstore.PetStoreExample.Purchase;
import org.drools.examples.petstore.PetStoreExample.Product;
import java.util.ArrayList;
import javax.swing.JOptionPane;

import javax.swing.JFrame;

global JFrame frame
global javax.swing.JTextArea textArea</programlisting>
</para>
</formalpara>
<simpara>The <literal>PetStore.drl</literal> file also contains two functions that the rules in the file use:</simpara>
<formalpara>
<title>PetStore.drl Java functions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">function void doCheckout(JFrame frame, KieRuntime krt) {
        Object[] options = {"Yes",
                            "No"};

        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to checkout?",
                                             "",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       if (n == 0) {
            krt.getAgenda().getAgendaGroup( "checkout" ).setFocus();
       }
}

function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) {
        Object[] options = {"Yes",
                            "No"};

        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to buy a tank for your " + total + " fish?",
                                             "Purchase Suggestion",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                           + total + " fish? - " );

       if (n == 0) {
             Purchase purchase = new Purchase( order, fishTank );
             krt.insert( purchase );
             order.addItem( purchase );
             System.out.println( "Yes" );
       } else {
            System.out.println( "No" );
       }
       return true;
}</programlisting>
</para>
</formalpara>
<simpara>The two functions perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>doCheckout()</literal> displays a dialog that asks the user if she or he wants to check out. If the user does, the focus is set to the <literal>checkout</literal> agenda group, enabling rules in that group to (potentially) fire.</simpara>
</listitem>
<listitem>
<simpara><literal>requireTank()</literal> displays a dialog that asks the user if she or he wants to buy a fish tank. If the user does, a new fish tank <literal>Product</literal> is added to the order list in the working memory.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For this example, all rules and functions are within the same rule file for efficiency. In a production environment, you typically separate the rules and functions in different files or build a static Java method and import the files using the import function, such as <literal>import function my.package.name.hello</literal>.</simpara>
</note>
<bridgehead xml:id="pet_store_rules_with_agenda_groups" renderas="sect3" remap="_pet_store_rules_with_agenda_groups">Pet Store rules with agenda groups</bridgehead>
<simpara>Most of the rules in the Pet Store example use agenda groups to control rule execution. Agenda groups allow you to partition the decision engine agenda to provide more execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>Initially, a working memory has its focus on the agenda group <literal>MAIN</literal>. Rules in an agenda group only fire when the group receives the focus. You can set the focus either by using the method <literal>setFocus()</literal> or the rule attribute <literal>auto-focus</literal>. The <literal>auto-focus</literal> attribute enables the rule to be given a focus automatically for its agenda group when the rule is matched and activated.</simpara>
<simpara>The Pet Store example uses the following agenda groups for rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"init"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"evaluate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"show items"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"checkout"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>For example, the sample rule <literal>"Explode Cart"</literal> uses the <literal>"init"</literal> agenda group to ensure that it has the option to fire and insert shopping cart items into the KIE session working memory:</simpara>
<formalpara>
<title>Rule "Explode Cart"</title>
<para>
<screen>// Insert each item in the shopping cart into the working memory.
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
  when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
  then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end</screen>
</para>
</formalpara>
<simpara>This rule matches against all orders that do not yet have their <literal>grossTotal</literal> calculated. The execution loops for each purchase item in that order.</simpara>
<simpara>The rule uses the following features related to its agenda group:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>agenda-group "init"</literal> defines the name of the agenda group. In this case, only one rule is in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the <literal>auto-focus</literal> attribute for its chance to fire.</simpara>
</listitem>
<listitem>
<simpara><literal>auto-focus true</literal> ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when <literal>fireAllRules()</literal> is called from the Java code.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext…​.setFocus()</literal> sets the focus to the <literal>"show items"</literal> and <literal>"evaluate"</literal> agenda groups, enabling their rules to fire. In practice, you loop through all items in the order, insert them into memory, and then fire the other rules after each insertion.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>"show items"</literal> agenda group contains only one rule, <literal>"Show Items"</literal>. For each purchase in the order currently in the KIE session working memory, the rule logs details to the text area at the bottom of the GUI, based on the <literal>textArea</literal> variable defined in the rule file.</simpara>
<formalpara>
<title>Rule "Show Items"</title>
<para>
<screen>rule "Show Items"
    agenda-group "show items"
  when
    $order : Order()
    $p : Purchase( order == $order )
  then
   textArea.append( $p.product + "\n");
end</screen>
</para>
</formalpara>
<simpara>The <literal>"evaluate"</literal> agenda group also gains focus from the <literal>"Explode Cart"</literal> rule. This agenda group contains two rules, <literal>"Free Fish Food Sample"</literal> and <literal>"Suggest Tank"</literal>, which are executed in that order.</simpara>
<formalpara>
<title>Rule "Free Fish Food Sample"</title>
<para>
<screen>// Free fish food sample when users buy a goldfish if they did not already buy
// fish food and do not already have a fish food sample.
rule "Free Fish Food Sample"
    agenda-group "evaluate" <co xml:id="CO10-1"/>
  when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO10-2"/>
    not ( $p : Product( name == "Fish Food Sample") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO10-3"/>
    exists ( $p : Product( name == "Gold Fish") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO10-4"/>
    $fishFoodSample : Product( name == "Fish Food Sample" );
  then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase );
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"Free Fish Food Sample"</literal> fires only if all of the following conditions are true:</simpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>The agenda group <literal>"evaluate"</literal> is being evaluated in the rules execution.</para>
</callout>
<callout arearefs="CO10-2">
<para>User does not already have fish food.</para>
</callout>
<callout arearefs="CO10-3">
<para>User does not already have a free fish food sample.</para>
</callout>
<callout arearefs="CO10-4">
<para>User has a goldfish in the order.</para>
</callout>
</calloutlist>
<simpara>If the order facts meet all of these requirements, then a new product is created (Fish Food Sample) and is added to the order in working memory.</simpara>
<formalpara>
<title>Rule "Suggest Tank"</title>
<para>
<screen>// Suggest a fish tank if users buy more than five goldfish and
// do not already have a tank.
rule "Suggest Tank"
    agenda-group "evaluate"
  when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO11-1"/>
    ArrayList( $total : size &gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) ) <co xml:id="CO11-2"/>
    $fishTank : Product( name == "Fish Tank" )
  then
    requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total);
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"Suggest Tank"</literal> fires only if the following conditions are true:</simpara>
<calloutlist>
<callout arearefs="CO11-1">
<para>User does not have a fish tank in the order.</para>
</callout>
<callout arearefs="CO11-2">
<para>User has more than five fish in the order.</para>
</callout>
</calloutlist>
<simpara>When the rule fires, it calls the <literal>requireTank()</literal> function defined in the rule file. This function displays a dialog that asks the user if she or he wants to buy a fish tank. If the user does, a new fish tank <literal>Product</literal> is added to the order list in the working memory. When the rule calls the <literal>requireTank()</literal> function, the rule passes the <literal>frame</literal> global variable so that the function has a handle for the Swing GUI.</simpara>
<simpara>The <literal>"do checkout"</literal> rule in the Pet Store example has no agenda group and no <literal>when</literal> conditions, so the rule is always executed and considered part of the default <literal>MAIN</literal> agenda group.</simpara>
<formalpara>
<title>Rule "do checkout"</title>
<para>
<screen>rule "do checkout"
  when
  then
    doCheckout(frame, kcontext.getKieRuntime());
end</screen>
</para>
</formalpara>
<simpara>When the rule fires, it calls the <literal>doCheckout()</literal> function defined in the rule file. This function displays a dialog that asks the user if she or he wants to check out. If the user does, the focus is set to the <literal>checkout</literal> agenda group, enabling rules in that group to (potentially) fire. When the rule calls the <literal>doCheckout()</literal> function, the rule passes the <literal>frame</literal> global variable so that the function has a handle for the Swing GUI.</simpara>
<note>
<simpara>This example also demonstrates a troubleshooting technique if results are not executing as you expect: You can remove the conditions from the <literal>when</literal> statement of a rule and test the action in the <literal>then</literal> statement to verify that the action is performed correctly.</simpara>
</note>
<simpara>The <literal>"checkout"</literal> agenda group contains three rules for processing the order checkout and applying any discounts: <literal>"Gross Total"</literal>, <literal>"Apply 5% Discount"</literal>, and <literal>"Apply 10% Discount"</literal>.</simpara>
<formalpara>
<title>Rules "Gross Total", "Apply 5% Discount", and "Apply 10% Discount"</title>
<para>
<screen>rule "Gross Total"
    agenda-group "checkout"
  when
    $order : Order( grossTotal == -1)
    Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ),
                                                              sum( $price ) )
  then
    modify( $order ) { grossTotal = total }
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
  when
    $order : Order( grossTotal &gt;= 10 &amp;&amp; &lt; 20 )
  then
    $order.discountedTotal = $order.grossTotal * 0.95;
    textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end

rule "Apply 10% Discount"
    agenda-group "checkout"
  when
    $order : Order( grossTotal &gt;= 20 )
  then
    $order.discountedTotal = $order.grossTotal * 0.90;
    textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end</screen>
</para>
</formalpara>
<simpara>If the user has not already calculated the gross total, the <literal>Gross Total</literal> accumulates the product prices into a total, puts this total into the KIE session, and displays it through the Swing <literal>JTextArea</literal> using the <literal>textArea</literal> global variable.</simpara>
<simpara>If the gross total is between <literal>10</literal> and <literal>20</literal> (currency units), the <literal>"Apply 5% Discount"</literal> rule calculates the discounted total, adds it to the KIE session, and displays it in the text area.</simpara>
<simpara>If the gross total is not less than <literal>20</literal>, the <literal>"Apply 10% Discount"</literal> rule calculates the discounted total, adds it to the KIE session, and displays it in the text area.</simpara>
<bridgehead xml:id="pet_store_example_execution" renderas="sect3" remap="_pet_store_example_execution">Pet Store example execution</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Pet Store example by running the <literal>org.drools.examples.petstore.PetStoreExample</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Pet Store example, the <literal>Pet Store Demo</literal> GUI window appears. This window displays a list of available products (upper left), an empty list of selected products (upper right), <emphasis role="strong">Checkout</emphasis> and <emphasis role="strong">Reset</emphasis> buttons (middle), and an empty system messages area (bottom).</simpara>
<figure>
<title>Pet Store example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/1-PetStore-Start-Screen.png" align="center"/>
</imageobject>
<textobject><phrase>1 PetStore Start Screen</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following events occurred in this example to establish this execution behavior:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>main()</literal> method has run and loaded the rule base but has not yet fired the rules. So far, this is the only code in connection with rules that has been run.</simpara>
</listitem>
<listitem>
<simpara>A new <literal>PetStoreUI</literal> object has been created and given a handle for the rule base, for later use.</simpara>
</listitem>
<listitem>
<simpara>Various Swing components have performed their functions, and the initial UI screen is displayed and waits for user input.</simpara>
</listitem>
</orderedlist>
<simpara>You can click various products from the list to explore the UI setup:</simpara>
<figure>
<title>Explore the Pet Store example GUI</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/2-stock-added-to-order-list.png" align="center"/>
</imageobject>
<textobject><phrase>2 stock added to order list</phrase></textobject>
</mediaobject>
</figure>
<simpara>No rules code has been fired yet. The UI uses Swing code to detect user mouse clicks and add selected products to the <literal>TableModel</literal> object for display in the upper-right corner of the UI. This example illustrates the Model-View-Controller design pattern.</simpara>
<simpara>When you click <emphasis role="strong">Checkout</emphasis>, the rules are then fired in the following way:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Method <literal>CheckOutCallBack.checkout()</literal> is called (eventually) by the Swing class waiting for a user to click <emphasis role="strong">Checkout</emphasis>. This inserts the data from the <literal>TableModel</literal> object (upper-right corner of the UI) into the KIE session working memory. The method then fires the rules.</simpara>
</listitem>
<listitem>
<simpara>The <literal>"Explode Cart"</literal> rule is the first to fire, with the <literal>auto-focus</literal> attribute set to <literal>true</literal>. The rule loops through all of the products in the cart, ensures that the products are in the working memory, and then gives the <literal>"show Items"</literal> and <literal>"evaluate"</literal> agenda groups the option to fire. The rules in these groups add the contents of the cart to the text area (bottom of the UI), evaluate if you are eligible for free fish food, and determine whether to ask if you want to buy a fish tank.</simpara>
<figure>
<title>Fish tank qualification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/3-purchase-suggestion.png" align="center"/>
</imageobject>
<textobject><phrase>3 purchase suggestion</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>The <literal>"do checkout"</literal> rule is the next to fire because no other agenda group currently has focus and because it is part of the default <literal>MAIN</literal> agenda group. This rule always calls the <literal>doCheckout()</literal> function, which asks you if you want to check out.</simpara>
</listitem>
<listitem>
<simpara>The <literal>doCheckout()</literal> function sets the focus to the <literal>"checkout"</literal> agenda group, giving the rules in that group the option to fire.</simpara>
</listitem>
<listitem>
<simpara>The rules in the <literal>"checkout"</literal> agenda group display the contents of the cart and apply the appropriate discount.</simpara>
</listitem>
<listitem>
<simpara>Swing then waits for user input to either select more products (and cause the rules to fire again) or to close the UI.</simpara>
<figure>
<title>Pet Store example GUI after all rules have fired</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/4-Petstore-final-screen.png" align="center"/>
</imageobject>
<textobject><phrase>4 Petstore final screen</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<simpara>You can add more <literal>System.out</literal> calls to demonstrate this flow of events in your IDE console:</simpara>
<formalpara>
<title>System.out output in the IDE console</title>
<para>
<screen>Adding free Fish Food Sample to cart
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</screen>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-politician-ref_drl-rules">
<title>Honest Politician example decisions (truth maintenance and salience)</title>
<simpara>The Honest Politician example decision set demonstrates the concept of truth maintenance with logical insertions and the use of salience in rules.</simpara>
<simpara>The following is an overview of the Honest Politician example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>honestpolitician</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.honestpolitician.HonestPoliticianExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.honestpolitician.HonestPolitician.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates the concept of truth maintenance based on the logical insertion of facts and the use of salience in rules</simpara>
</listitem>
</itemizedlist>
<simpara>The basic premise of the Honest Politician example is that an object can only exist while a statement is true. A rule consequence can logically insert an object with the <literal>insertLogical()</literal> method. This means the object remains in the KIE session working memory as long as the rule that logically inserted it remains true. When the rule is no longer true, the object is automatically retracted.</simpara>
<simpara>In this example, rule execution causes a group of politicians to change from being honest to being dishonest as a result of a corrupt corporation. As each politician is evaluated, they start out with their honesty attribute being set to <literal>true</literal>, but a rule fires that makes the politicians no longer honest. As they switch their state from being honest to dishonest, they are then removed from the working memory. The rule salience notifies the decision engine how to prioritize any rules that have a salience defined for them, otherwise utilizing the default salience value of <literal>0</literal>. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara>
<bridgehead xml:id="politician_and_hope_classes" renderas="sect3" remap="_politician_and_hope_classes">Politician and Hope classes</bridgehead>
<simpara>The sample class <literal>Politician</literal> in the example is configured for an honest politician. The <literal>Politician</literal> class is made up of a String item <literal>name</literal> and a Boolean item <literal>honest</literal>:</simpara>
<formalpara>
<title>Politician class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Politician {
    private String name;
    private boolean honest;
    ...
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>Hope</literal> class determines if a <literal>Hope</literal> object exists. This class has no meaningful members, but is present in the working memory as long as society has hope.</simpara>
<formalpara>
<title>Hope class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Hope {

    public Hope() {

    }
  }</programlisting>
</para>
</formalpara>
<bridgehead xml:id="rule_definitions_for_politician_honesty" renderas="sect3" remap="_rule_definitions_for_politician_honesty">Rule definitions for politician honesty</bridgehead>
<simpara>In the Honest Politician example, when at least one honest politician exists in the working memory, the <literal>"We have an honest Politician"</literal> rule logically inserts a new <literal>Hope</literal> object. As soon as all politicians become dishonest, the <literal>Hope</literal> object is automatically retracted. This rule has a <literal>salience</literal> attribute with a value of <literal>10</literal> to ensure that it fires before any other rule, because at that stage the <literal>"Hope is Dead"</literal> rule is true.</simpara>
<formalpara>
<title>Rule "We have an honest politician"</title>
<para>
<screen>rule "We have an honest Politician"
    salience 10
  when
    exists( Politician( honest == true ) )
  then
    insertLogical( new Hope() );
end</screen>
</para>
</formalpara>
<simpara>As soon as a <literal>Hope</literal> object exists, the <literal>"Hope Lives"</literal> rule matches and fires. This rule also has a <literal>salience</literal> value of <literal>10</literal> so that it takes priority over the <literal>"Corrupt the Honest"</literal> rule.</simpara>
<formalpara>
<title>Rule "Hope Lives"</title>
<para>
<screen>rule "Hope Lives"
    salience 10
  when
    exists( Hope() )
  then
    System.out.println("Hurrah!!! Democracy Lives");
end</screen>
</para>
</formalpara>
<simpara>Initially, four honest politicians exist so this rule has four activations, all in conflict. Each rule fires in turn, corrupting each politician so that they are no longer honest. When all four politicians have been corrupted, no politicians have the property <literal>honest == true</literal>. The rule <literal>"We have an honest Politician"</literal> is no longer true and the object it logically inserted (due to the last execution of <literal>new Hope()</literal>) is automatically retracted.</simpara>
<formalpara>
<title>Rule "Corrupt the Honest"</title>
<para>
<screen>rule "Corrupt the Honest"
  when
    politician : Politician( honest == true )
    exists( Hope() )
  then
    System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
    modify ( politician ) { honest = false };
end</screen>
</para>
</formalpara>
<simpara>With the <literal>Hope</literal> object automatically retracted through the truth maintenance system, the conditional element <literal>not</literal> applied to <literal>Hope</literal> is no longer true so that the <literal>"Hope is Dead"</literal> rule matches and fires.</simpara>
<formalpara>
<title>Rule "Hope is Dead"</title>
<para>
<screen>rule "Hope is Dead"
  when
    not( Hope() )
  then
    System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</screen>
</para>
</formalpara>
<bridgehead xml:id="example_execution_and_audit_trail" renderas="sect3" remap="_example_execution_and_audit_trail">Example execution and audit trail</bridgehead>
<simpara>In the <literal>HonestPoliticianExample.java</literal> class, the four politicians with the honest state set to <literal>true</literal> are inserted for evaluation against the defined business rules:</simpara>
<formalpara>
<title>HonestPoliticianExample.java class execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static void execute( KieContainer kc ) {
        KieSession ksession = kc.newKieSession("HonestPoliticianKS");

        final Politician p1 = new Politician( "President of Umpa Lumpa", true );
        final Politician p2 = new Politician( "Prime Minster of Cheeseland", true );
        final Politician p3 = new Politician( "Tsar of Pringapopaloo", true );
        final Politician p4 = new Politician( "Omnipotence Om", true );

        ksession.insert( p1 );
        ksession.insert( p2 );
        ksession.insert( p3 );
        ksession.insert( p4 );

        ksession.fireAllRules();

        ksession.dispose();
    }</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.honestpolitician.HonestPoliticianExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Execution output in the IDE console</title>
<para>
<screen>Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted President of Umpa Lumpa
I'm an evil corporation and I have corrupted Prime Minster of Cheeseland
I'm an evil corporation and I have corrupted Tsar of Pringapopaloo
I'm an evil corporation and I have corrupted Omnipotence Om
We are all Doomed!!! Democracy is Dead</screen>
</para>
</formalpara>
<simpara>The output shows that, while there is at least one honest politician, democracy lives. However, as each politician is corrupted by some corporation, all politicians become dishonest, and democracy is dead.</simpara>
<simpara>To better understand the execution flow of this example, you can modify the <literal>HonestPoliticianExample.java</literal> class to include a <literal>DebugRuleRuntimeEventListener</literal> listener and an audit logger to view execution details:</simpara>
<formalpara>
<title>HonestPoliticianExample.java class with an audit logger</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.drools.examples.honestpolitician;

import org.kie.api.KieServices;
import org.kie.api.event.rule.DebugAgendaEventListener; <co xml:id="CO12-1"/>
import org.kie.api.event.rule.DebugRuleRuntimeEventListener;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

public class HonestPoliticianExample {

    /**
     * @param args
     */
    public static void main(final String[] args) {
    	KieServices ks = KieServices.Factory.get(); <co xml:id="CO12-2"/>
    	//ks = KieServices.Factory.get();
        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();
        System.out.println(kc.verify().getMessages().toString());
        //execute( kc );
        execute( ks, kc); <co xml:id="CO12-3"/>
    }

    public static void execute( KieServices ks, KieContainer kc ) { <co xml:id="CO12-4"/>
        KieSession ksession = kc.newKieSession("HonestPoliticianKS");

        final Politician p1 = new Politician( "President of Umpa Lumpa", true );
        final Politician p2 = new Politician( "Prime Minster of Cheeseland", true );
        final Politician p3 = new Politician( "Tsar of Pringapopaloo", true );
        final Politician p4 = new Politician( "Omnipotence Om", true );

        ksession.insert( p1 );
        ksession.insert( p2 );
        ksession.insert( p3 );
        ksession.insert( p4 );

        // The application can also setup listeners <co xml:id="CO12-5"/>
        ksession.addEventListener( new DebugAgendaEventListener() );
        ksession.addEventListener( new DebugRuleRuntimeEventListener() );

        // Set up a file-based audit logger.
        ks.getLoggers().newFileLogger( ksession, "./target/honestpolitician" ); <co xml:id="CO12-6"/>

        ksession.fireAllRules();

        ksession.dispose();
    }

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>Adds to your imports the packages that handle the <literal>DebugAgendaEventListener</literal> and <literal>DebugRuleRuntimeEventListener</literal></para>
</callout>
<callout arearefs="CO12-2">
<para>Creates a <literal>KieServices Factory</literal> and a <literal>ks</literal> element to produce the logs because this audit log is not available at the <literal>KieContainer</literal> level</para>
</callout>
<callout arearefs="CO12-3">
<para>Modifies the <literal>execute</literal> method to use both <literal>KieServices</literal> and <literal>KieContainer</literal></para>
</callout>
<callout arearefs="CO12-4">
<para>Modifies the <literal>execute</literal> method to pass in <literal>KieServices</literal> in addition to the <literal>KieContainer</literal></para>
</callout>
<callout arearefs="CO12-5">
<para>Creates the listeners</para>
</callout>
<callout arearefs="CO12-6">
<para>Builds the log that can be passed into the debug view or <emphasis role="strong">Audit View</emphasis> or your IDE after executing of the rules</para>
</callout>
</calloutlist>
<simpara>When you run the Honest Politician with this modified logging capability, you can load the audit log file from <literal>target/honestpolitician.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows the flow of executions, insertions, and retractions as defined in the example classes and rules:</simpara>
<figure>
<title>Honest Politician example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/HonestPoliticianExample/honest_politician_audit.png" align="center"/>
</imageobject>
<textobject><phrase>honest politician audit</phrase></textobject>
</mediaobject>
</figure>
<simpara>When the first politician is inserted, two activations occur. The rule <literal>"We have an honest Politician"</literal> is activated only one time for the first inserted politician because it uses an <literal>exists</literal> conditional element, which matches when at least one politician is inserted. The rule <literal>"Hope is Dead"</literal> is also activated at this stage because the <literal>Hope</literal> object is not yet inserted. The rule <literal>"We have an honest Politician"</literal> fires first because it has a higher <literal>salience</literal> value than the rule <literal>"Hope is Dead"</literal>, and inserts the <literal>Hope</literal> object (highlighted in green). The insertion of the <literal>Hope</literal> object activates the rule <literal>"Hope Lives"</literal> and deactivates the rule <literal>"Hope is Dead"</literal>. The insertion also activates the rule <literal>"Corrupt the Honest"</literal> for each inserted honest politician. The rule <literal>"Hope Lives"</literal> is executed and prints <literal>"Hurrah!!! Democracy Lives"</literal>.</simpara>
<simpara>Next, for each politician, the rule <literal>"Corrupt the Honest"</literal> fires, printing <literal>"I’m an evil corporation and I have corrupted X"</literal>, where <literal>X</literal> is the name of the politician, and modifies the politician honesty value to <literal>false</literal>. When the last honest politician is corrupted, <literal>Hope</literal> is automatically retracted by the truth maintenance system (highlighted in blue). The green highlighted area shows the origin of the currently selected blue highlighted area. After the <literal>Hope</literal> fact is retracted, the rule <literal>"Hope is dead"</literal> fires, printing <literal>"We are all Doomed!!! Democracy is Dead"</literal>.</simpara>
</section>
<section xml:id="decision-examples-sudoku-ref_drl-rules">
<title>Sudoku example decisions (complex pattern matching, callbacks, and GUI integration)</title>
<simpara>The Sudoku example decision set, based on the popular number puzzle Sudoku, demonstrates how to use rules in Red Hat Decision Manager to find a solution in a large potential solution space based on various constraints. This example also shows how to integrate Red Hat Decision Manager rules into a graphical user interface (GUI), in this case a Swing-based desktop application, and how to use callbacks to interact with a running decision engine to update the GUI based on changes in the working memory at run time.</simpara>
<simpara>The following is an overview of the Sudoku example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>sudoku</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.sudoku.SudokuExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.sudoku.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates complex pattern matching, problem solving, callbacks, and GUI integration</simpara>
</listitem>
</itemizedlist>
<simpara>Sudoku is a logic-based number placement puzzle. The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9 only one time. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints.</simpara>
<simpara>The general strategy to solve the problem is to ensure that when you insert a new number, it must be unique in its particular 3x3 zone, row, and column. This Sudoku example decision set uses Red Hat Decision Manager rules to solve Sudoku puzzles from a range of difficulty levels, and to attempt to resolve flawed puzzles that contain invalid entries.</simpara>
<bridgehead xml:id="sudoku_example_execution_and_interaction" renderas="sect3" remap="_sudoku_example_execution_and_interaction">Sudoku example execution and interaction</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Sudoku example by running the <literal>org.drools.examples.sudoku.SudokuExample</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Sudoku example, the <literal>Drools Sudoku Example</literal> GUI window appears. This window contains an empty grid, but the program comes with various grids stored internally that you can load and solve.</simpara>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Samples</emphasis> → <emphasis role="strong">Simple</emphasis> to load one of the examples. Notice that all buttons are disabled until a grid is loaded.</simpara>
<figure>
<title>Sudoku example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku1.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When you load the <emphasis role="strong">Simple</emphasis> example, the grid is filled according to the puzzle’s initial state.</simpara>
<figure>
<title>Sudoku example GUI after loading Simple sample</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku2.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku2</phrase></textobject>
</mediaobject>
</figure>
<simpara>Choose from the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Click <emphasis role="strong">Solve</emphasis> to fire the rules defined in the Sudoku example that fill out the remaining values and that make the buttons inactive again.</simpara>
<figure>
<title>Simple sample solved</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku3.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku3</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Step</emphasis> to see the next digit found by the rule set. The console window in your IDE displays detailed information about the rules that are executing to solve the step.</simpara>
<formalpara>
<title>Step execution output in the IDE console</title>
<para>
<screen>single 8 at [0,1]
column elimination due to [1,2]: remove 9 from [4,2]
hidden single 9 at [1,2]
row elimination due to [2,8]: remove 7 from [2,4]
remove 6 from [3,8] due to naked pair at [3,2] and [3,7]
hidden pair in row at [4,6] and [4,4]</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Dump</emphasis> to see the state of the grid, with cells showing either the established value or the remaining possibilities.</simpara>
<formalpara>
<title>Dump execution output in the IDE console</title>
<para>
<screen>        Col: 0     Col: 1     Col: 2     Col: 3     Col: 4     Col: 5     Col: 6     Col: 7     Col: 8
Row 0:  123456789  --- 5 ---  --- 6 ---  --- 8 ---  123456789  --- 1 ---  --- 9 ---  --- 4 ---  123456789
Row 1:  --- 9 ---  123456789  123456789  --- 6 ---  123456789  --- 5 ---  123456789  123456789  --- 3 ---
Row 2:  --- 7 ---  123456789  123456789  --- 4 ---  --- 9 ---  --- 3 ---  123456789  123456789  --- 8 ---
Row 3:  --- 8 ---  --- 9 ---  --- 7 ---  123456789  --- 4 ---  123456789  --- 6 ---  --- 3 ---  --- 5 ---
Row 4:  123456789  123456789  --- 3 ---  --- 9 ---  123456789  --- 6 ---  --- 8 ---  123456789  123456789
Row 5:  --- 4 ---  --- 6 ---  --- 5 ---  123456789  --- 8 ---  123456789  --- 2 ---  --- 9 ---  --- 1 ---
Row 6:  --- 5 ---  123456789  123456789  --- 2 ---  --- 6 ---  --- 9 ---  123456789  123456789  --- 7 ---
Row 7:  --- 6 ---  123456789  123456789  --- 5 ---  123456789  --- 4 ---  123456789  123456789  --- 9 ---
Row 8:  123456789  --- 4 ---  --- 9 ---  --- 7 ---  123456789  --- 8 ---  --- 3 ---  --- 5 ---  123456789</screen>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>The Sudoku example includes a deliberately broken sample file that the rules defined in the example can resolve.</simpara>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Samples</emphasis> → <emphasis role="strong">!DELIBERATELY BROKEN!</emphasis> to load the broken sample. The grid starts with some issues, for example, the value <literal>5</literal> appears two times in the first row, which is not allowed.</simpara>
<figure>
<title>Broken Sudoku example initial state</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku4.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku4</phrase></textobject>
</mediaobject>
</figure>
<simpara>Click <emphasis role="strong">Solve</emphasis> to apply the solving rules to this invalid grid. The associated solving rules in the Sudoku example detect the issues in the sample and attempts to solve the puzzle as far as possible. This process does not complete and leaves some cells empty.</simpara>
<simpara>The solving rule activity is displayed in the IDE console window:</simpara>
<formalpara>
<title>Detected issues in the broken sample</title>
<para>
<screen>cell [0,8]: 5 has a duplicate in row 0
cell [0,0]: 5 has a duplicate in row 0
cell [6,0]: 8 has a duplicate in col 0
cell [4,0]: 8 has a duplicate in col 0
Validation complete.</screen>
</para>
</formalpara>
<figure>
<title>Broken sample solution attempt</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku5.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku5</phrase></textobject>
</mediaobject>
</figure>
<simpara>The sample Sudoku files labeled <emphasis role="strong">Hard</emphasis> are more complex and the solving rules might not be able to solve them. The unsuccessful solution attempt is displayed in the IDE console window:</simpara>
<formalpara>
<title>Hard sample unresolved</title>
<para>
<screen>Validation complete.
...
Sorry - can't solve this grid.</screen>
</para>
</formalpara>
<simpara>The rules that work to solve the broken sample implement standard solving techniques based on the sets of values that are still candidates for a cell. For example, if a set contains a single value, then this is the value for the cell. For a single occurrence of a value in one of the groups of nine cells, the rules insert a fact of type <literal>Setting</literal> with the solution value for some specific cell. This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to and the value is retracted.</simpara>
<simpara>Other rules in the example reduce the permissible values for some cells. The rules <literal>"naked pair"</literal>, <literal>"hidden pair in row"</literal>, <literal>"hidden pair in column"</literal>, and <literal>"hidden pair in square"</literal> eliminate possibilities but do not establish solutions. The rules <literal>"X-wings in rows"</literal>, "`X-wings in columns"`, <literal>"intersection removal row"</literal>, and <literal>"intersection removal column"</literal> perform more sophisticated eliminations.</simpara>
<bridgehead xml:id="sudoku_example_classes" renderas="sect3" remap="_sudoku_example_classes">Sudoku example classes</bridgehead>
<simpara>The package <literal>org.drools.examples.sudoku.swing</literal> contains the following core set of classes that implement a framework for Sudoku puzzles:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>SudokuGridModel</literal> class defines an interface that is implemented to store a Sudoku puzzle as a 9x9 grid of <literal>Cell</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridView</literal> class is a Swing component that can visualize any implementation of the <literal>SudokuGridModel</literal> class.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridEvent</literal> and <literal>SudokuGridListener</literal> classes communicate state changes between the model and the view. Events are fired when a cell value is resolved or changed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridSamples</literal> class provides partially filled Sudoku puzzles for demonstration purposes.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This package does not have any dependencies on Red Hat Decision Manager libraries.</simpara>
</note>
<simpara>The package <literal>org.drools.examples.sudoku</literal> contains the following core set of classes that implement the elementary <literal>Cell</literal> object and its various aggregations:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>CellFile</literal> class, with subtypes <literal>CellRow</literal>, <literal>CellCol</literal>, and <literal>CellSqr</literal>, all of which are subtypes of the <literal>CellGroup</literal> class.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Cell</literal> and <literal>CellGroup</literal> subclasses of <literal>SetOfNine</literal>, which provides a property <literal>free</literal> with the type <literal>Set&lt;Integer&gt;</literal>. For a <literal>Cell</literal> class, the set represents the individual candidate set. For a <literal>CellGroup</literal> class, the set is the union of all candidate sets of its cells (the set of digits that still need to be allocated).</simpara>
<simpara>In the Sudoku example are 81 <literal>Cell</literal> and 27 <literal>CellGroup</literal> objects and a linkage provided by the <literal>Cell</literal> properties <literal>cellRow</literal>, <literal>cellCol</literal>, and <literal>cellSqr</literal>, and by the <literal>CellGroup</literal> property <literal>cells</literal> (a list of <literal>Cell</literal> objects). With these components, you can write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Setting</literal> class is used to trigger the operations that accompany the allocation of a value. The presence of a <literal>Setting</literal> fact is used in all rules that detect a new situation in order to avoid reactions to inconsistent intermediary states.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Stepping</literal> class is used in a low priority rule to execute an emergency halt when a <literal>"Step"</literal> does not terminate regularly. This behavior indicates that the program cannot solve the puzzle.</simpara>
</listitem>
<listitem>
<simpara>The main class <literal>org.drools.examples.sudoku.SudokuExample</literal> implements a Java application combining all of these components.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="sudoku_validation_rules_validate_drl" renderas="sect3" remap="_sudoku_validation_rules_validate_drl">Sudoku validation rules (validate.drl)</bridgehead>
<simpara>The <literal>validate.drl</literal> file in the Sudoku example contains validation rules that detect duplicate numbers in cell groups. They are combined in a <literal>"validate"</literal> agenda group that enables the rules to be explicitly activated after a user loads the puzzle.</simpara>
<simpara>The <literal>when</literal> conditions of the three rules <literal>"duplicate in cell …​"</literal> all function in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>The first condition in the rule locates a cell with an allocated value.</simpara>
</listitem>
<listitem>
<simpara>The second condition in the rule pulls in any of the three cell groups to which the cell belongs.</simpara>
</listitem>
<listitem>
<simpara>The final condition finds a cell (other than the first one) with the same value as the first cell and in the same row, column, or square, depending on the rule.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Rules "duplicate in cell …​"</title>
<para>
<screen>rule "duplicate in cell row"
  when
    $c: Cell( $v: value != null )
    $cr: CellRow( cells contains $c )
    exists Cell( this != $c, value == $v, cellRow == $cr )
  then
    System.out.println( "cell " + $c.toString() + " has a duplicate in row " + $cr.getNumber() );
end

rule "duplicate in cell col"
  when
    $c: Cell( $v: value != null )
    $cc: CellCol( cells contains $c )
    exists Cell( this != $c, value == $v, cellCol == $cc )
  then
    System.out.println( "cell " + $c.toString() + " has a duplicate in col " + $cc.getNumber() );
end

rule "duplicate in cell sqr"
  when
    $c: Cell( $v: value != null )
    $cs: CellSqr( cells contains $c )
    exists Cell( this != $c, value == $v, cellSqr == $cs )
  then
    System.out.println( "cell " + $c.toString() + " has duplicate in its square of nine." );
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"terminate group"</literal> is the last to fire. This rule prints a message and stops the sequence.</simpara>
<formalpara>
<title>Rule "terminate group"</title>
<para>
<screen>rule "terminate group"
    salience -100
  when
  then
    System.out.println( "Validation complete." );
    drools.halt();
end</screen>
</para>
</formalpara>
<bridgehead xml:id="sudoku_solving_rules_sudoku_drl" renderas="sect3" remap="_sudoku_solving_rules_sudoku_drl">Sudoku solving rules (sudoku.drl)</bridgehead>
<simpara>The <literal>sudoku.drl</literal> file in the Sudoku example contains three types of rules: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets.</simpara>
<simpara>The rules  <literal>"set a value"</literal>, <literal>"eliminate a value from Cell"</literal>, and <literal>"retract setting"</literal> depend on the presence of a <literal>Setting</literal> object. The first rule handles the assignment to the cell and the operations for removing the value from the <literal>free</literal> sets of the three groups of the cell. This group also reduces a counter that, when zero, returns control to the Java application that has called <literal>fireUntilHalt()</literal>.</simpara>
<simpara>The purpose of the rule <literal>"eliminate a value from Cell"</literal> is to reduce the candidate lists of all cells that are related to the newly assigned cell. Finally, when all eliminations have been made, the rule <literal>"retract setting"</literal> retracts the triggering <literal>Setting</literal> fact.</simpara>
<formalpara>
<title>Rules "set a value", "eliminate a value from a Cell", and "retract setting"</title>
<para>
<screen>// A Setting object is inserted to define the value of a Cell.
// Rule for updating the cell and all cell groups that contain it
rule "set a value"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // A matching Cell, with no value set
    $c: Cell( rowNo == $rn, colNo == $cn, value == null,
              $cr: cellRow, $cc: cellCol, $cs: cellSqr )

    // Count down
    $ctr: Counter( $count: count )
  then
    // Modify the Cell by setting its value.
    modify( $c ){ setValue( $v ) }
    // System.out.println( "set cell " + $c.toString() );
    modify( $cr ){ blockValue( $v ) }
    modify( $cc ){ blockValue( $v ) }
    modify( $cs ){ blockValue( $v ) }
    modify( $ctr ){ setCount( $count - 1 ) }
end

// Rule for removing a value from all cells that are siblings
// in one of the three cell groups
rule "eliminate a value from Cell"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // The matching Cell, with the value already set
    Cell( rowNo == $rn, colNo == $cn, value == $v, $exCells: exCells )

    // For all Cells that are associated with the updated cell
    $c: Cell( free contains $v ) from $exCells
  then
    // System.out.println( "clear " + $v + " from cell " + $c.posAsString()  );
    // Modify a related Cell by blocking the assigned value.
    modify( $c ){ blockValue( $v ) }
end

// Rule for eliminating the Setting fact
rule "retract setting"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // The matching Cell, with the value already set
    $c: Cell( rowNo == $rn, colNo == $cn, value == $v )

    // This is the negation of the last pattern in the previous rule.
    // Now the Setting fact can be safely retracted.
    not( $x: Cell( free contains $v )
         and
         Cell( this == $c, exCells contains $x ) )
  then
    // System.out.println( "done setting cell " + $c.toString() );
    // Discard the Setter fact.
    delete( $s );
    // Sudoku.sudoku.consistencyCheck();
end</screen>
</para>
</formalpara>
<simpara>Two solving rules detect a situation where an allocation of a number to a cell is possible. The rule <literal>"single"</literal> fires for a <literal>Cell</literal> with a candidate set containing a single number. The rule <literal>"hidden single"</literal> fires when no cell exists with a single candidate, but when a cell exists containing a candidate, this candidate is absent from all other cells in one of the three groups to which the cell belongs. Both rules create and insert a <literal>Setting</literal> fact.</simpara>
<formalpara>
<title>Rules "single" and "hidden single"</title>
<para>
<screen>// Detect a set of candidate values with cardinality 1 for some Cell.
// This is the value to be set.
rule "single"
  when
    // Currently no setting underway
    not Setting()

    // One element in the "free" set
    $c: Cell( $rn: rowNo, $cn: colNo, freeCount == 1 )
  then
    Integer i = $c.getFreeValue();
    if (explain) System.out.println( "single " + i + " at " + $c.posAsString() );
    // Insert another Setter fact.
    insert( new Setting( $rn, $cn, i ) );
end

// Detect a set of candidate values with a value that is the only one
// in one of its groups. This is the value to be set.
rule "hidden single"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // Some integer
    $i: Integer()

    // The "free" set contains this number
    $c: Cell( $rn: rowNo, $cn: colNo, freeCount &gt; 1, free contains $i )

    // A cell group contains this cell $c.
    $cg: CellGroup( cells contains $c )
    // No other cell from that group contains $i.
    not ( Cell( this != $c, free contains $i ) from $cg.getCells() )
  then
    if (explain) System.out.println( "hidden single " + $i + " at " + $c.posAsString() );
    // Insert another Setter fact.
    insert( new Setting( $rn, $cn, $i ) );
end</screen>
</para>
</formalpara>
<simpara>Rules from the largest group, either individually or in groups of two or three, implement various solving techniques used for solving Sudoku puzzles manually.</simpara>
<simpara>The rule <literal>"naked pair"</literal> detects identical candidate sets of size <literal>2</literal> in two cells of a group. These two values may be removed from all other candidate sets of that group.</simpara>
<formalpara>
<title>Rule "naked pair"</title>
<para>
<screen>// A "naked pair" is two cells in some cell group with their sets of
// permissible values being equal with cardinality 2. These two values
// can be removed from all other candidate lists in the group.
rule "naked pair"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // One cell with two candidates
    $c1: Cell( freeCount == 2, $f1: free, $r1: cellRow, $rn1: rowNo, $cn1: colNo, $b1: cellSqr )

    // The containing cell group
    $cg: CellGroup( freeCount &gt; 2, cells contains $c1 )

    // Another cell with two candidates, not the one we already have
    $c2: Cell( this != $c1, free == $f1 /*** , rowNo &gt;= $rn1, colNo &gt;= $cn1 ***/ ) from $cg.cells

    // Get one of the "naked pair".
    Integer( $v: intValue ) from $c1.getFree()

    // Get some other cell with a candidate equal to one from the pair.
    $c3: Cell( this != $c1 &amp;&amp; != $c2, freeCount &gt; 1, free contains $v ) from $cg.cells
  then
    if (explain) System.out.println( "remove " + $v + " from " + $c3.posAsString() + " due to naked pair at " + $c1.posAsString() + " and " + $c2.posAsString() );
    // Remove the value.
    modify( $c3 ){ blockValue( $v ) }
end</screen>
</para>
</formalpara>
<simpara>The three rules <literal>"hidden pair in …​"</literal> functions similarly to the rule <literal>"naked pair"</literal>. These rules detect a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of the group. This means that all other candidates can be eliminated from the two cells harboring the hidden pair.</simpara>
<formalpara>
<title>Rules "hidden pair in …​"</title>
<para>
<screen>// If two cells within the same cell group contain candidate sets with more than
// two values, with two values being in both of them but in none of the other
// cells, then we have a "hidden pair". We can remove all other candidates from
// these two cells.
rule "hidden pair in row"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // Establish a pair of Integer facts.
    $i1: Integer()
    $i2: Integer( this &gt; $i1 )

    // Look for a Cell with these two among its candidates. (The upper bound on
    // the number of candidates avoids a lot of useless work during startup.)
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2, $cellRow: cellRow )

    // Get another one from the same row, with the same pair among its candidates.
    $c2: Cell( this != $c1, cellRow == $cellRow, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )

    // Ascertain that no other cell in the group has one of these two values.
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellRow.getCells() )
  then
    if( explain) System.out.println( "hidden pair in row at " + $c1.posAsString() + " and " + $c2.posAsString() );
    // Set the candidate lists of these two Cells to the "hidden pair".
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end

rule "hidden pair in column"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i1: Integer()
    $i2: Integer( this &gt; $i1 )
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2, $cellCol: cellCol )
    $c2: Cell( this != $c1, cellCol == $cellCol, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellCol.getCells() )
  then
    if (explain) System.out.println( "hidden pair in column at " + $c1.posAsString() + " and " + $c2.posAsString() );
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end

rule "hidden pair in square"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i1: Integer()
    $i2: Integer( this &gt; $i1 )
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2,
               $cellSqr: cellSqr )
    $c2: Cell( this != $c1, cellSqr == $cellSqr, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellSqr.getCells() )
  then
    if (explain) System.out.println( "hidden pair in square " + $c1.posAsString() + " and " + $c2.posAsString() );
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end</screen>
</para>
</formalpara>
<simpara>Two rules deal with <literal>"X-wings"</literal> in rows and columns. When only two possible cells for a value exist in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated. When you follow the pattern sequence in one of these rules, notice how the conditions that are conveniently expressed by words such as <literal>same</literal> or <literal>only</literal> result in patterns with suitable constraints or that are prefixed with <literal>not</literal>.</simpara>
<formalpara>
<title>Rules "X-wings in …​"</title>
<para>
<screen>rule "X-wings in rows"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    $ca1: Cell( freeCount &gt; 1, free contains $i,
                $ra: cellRow, $rano: rowNo,         $c1: cellCol,        $c1no: colNo )
    $cb1: Cell( freeCount &gt; 1, free contains $i,
                $rb: cellRow, $rbno: rowNo &gt; $rano,      cellCol == $c1 )
    not( Cell( this != $ca1 &amp;&amp; != $cb1, free contains $i ) from $c1.getCells() )

    $ca2: Cell( freeCount &gt; 1, free contains $i,
                cellRow == $ra, $c2: cellCol,       $c2no: colNo &gt; $c1no )
    $cb2: Cell( freeCount &gt; 1, free contains $i,
                cellRow == $rb,      cellCol == $c2 )
    not( Cell( this != $ca2 &amp;&amp; != $cb2, free contains $i ) from $c2.getCells() )

    $cx: Cell( rowNo == $rano || == $rbno, colNo != $c1no &amp;&amp; != $c2no,
               freeCount &gt; 1, free contains $i )
  then
    if (explain) {
        System.out.println( "X-wing with " + $i + " in rows " +
            $ca1.posAsString() + " - " + $cb1.posAsString() +
            $ca2.posAsString() + " - " + $cb2.posAsString() + ", remove from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end

rule "X-wings in columns"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    $ca1: Cell( freeCount &gt; 1, free contains $i,
                $c1: cellCol, $c1no: colNo,         $ra: cellRow,        $rano: rowNo )
    $ca2: Cell( freeCount &gt; 1, free contains $i,
                $c2: cellCol, $c2no: colNo &gt; $c1no,      cellRow == $ra )
    not( Cell( this != $ca1 &amp;&amp; != $ca2, free contains $i ) from $ra.getCells() )

    $cb1: Cell( freeCount &gt; 1, free contains $i,
                cellCol == $c1, $rb: cellRow,  $rbno: rowNo &gt; $rano )
    $cb2: Cell( freeCount &gt; 1, free contains $i,
                cellCol == $c2,      cellRow == $rb )
    not( Cell( this != $cb1 &amp;&amp; != $cb2, free contains $i ) from $rb.getCells() )

    $cx: Cell( colNo == $c1no || == $c2no, rowNo != $rano &amp;&amp; != $rbno,
               freeCount &gt; 1, free contains $i )
  then
    if (explain) {
        System.out.println( "X-wing with " + $i + " in columns " +
            $ca1.posAsString() + " - " + $ca2.posAsString() +
            $cb1.posAsString() + " - " + $cb2.posAsString() + ", remove from " + $cx.posAsString()  );
    }
    modify( $cx ){ blockValue( $i ) }
end</screen>
</para>
</formalpara>
<simpara>The two rules <literal>"intersection removal …​"</literal> are based on the restricted occurrence of some number within one square, either in a single row or in a single column. This means that this number must be in one of those two or three cells of the row or column and can be removed from the candidate sets of all other cells of the group. The pattern establishes the restricted occurrence and then fires for each cell outside of the square and within the same cell file.</simpara>
<formalpara>
<title>Rules "intersection removal …​"</title>
<para>
<screen>rule "intersection removal column"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    // Occurs in a Cell
    $c: Cell( free contains $i, $cs: cellSqr, $cc: cellCol )
    // Does not occur in another cell of the same square and a different column
    not Cell( this != $c, free contains $i, cellSqr == $cs, cellCol != $cc )

    // A cell exists in the same column and another square containing this value.
    $cx: Cell( freeCount &gt; 1, free contains $i, cellCol == $cc, cellSqr != $cs )
  then
    // Remove the value from that other cell.
    if (explain) {
        System.out.println( "column elimination due to " + $c.posAsString() +
                            ": remove " + $i + " from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end

rule "intersection removal row"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    // Occurs in a Cell
    $c: Cell( free contains $i, $cs: cellSqr, $cr: cellRow )
    // Does not occur in another cell of the same square and a different row.
    not Cell( this != $c, free contains $i, cellSqr == $cs, cellRow != $cr )

    // A cell exists in the same row and another square containing this value.
    $cx: Cell( freeCount &gt; 1, free contains $i, cellRow == $cr, cellSqr != $cs )
  then
    // Remove the value from that other cell.
    if (explain) {
        System.out.println( "row elimination due to " + $c.posAsString() +
                            ": remove " + $i + " from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end</screen>
</para>
</formalpara>
<simpara>These rules are sufficient for many but not all Sudoku puzzles. To solve very difficult grids, the rule set requires more complex rules. (Ultimately, some puzzles can be solved only by trial and error.)</simpara>
</section>
<section xml:id="decision-examples-conway-ref_drl-rules">
<title>Conway’s Game of Life example decisions (ruleflow groups and GUI integration)</title>
<simpara>The Conway’s Game of Life example decision set, based on the famous cellular automaton by John Conway, demonstrates how to use ruleflow groups in rules to control rule execution. The example also demonstrates how to integrate Red Hat Decision Manager rules with a graphical user interface (GUI), in this case a Swing-based implementation of Conway’s Game of Life.</simpara>
<simpara>The following is an overview of the Conway’s Game of Life (Conway) example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>conway</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main classes</emphasis>: <literal>org.drools.examples.conway.ConwayRuleFlowGroupRun</literal>, <literal>org.drools.examples.conway.ConwayAgendaGroupRun</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>droolsjbpm-integration-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.conway.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates ruleflow groups and GUI integration</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Conway’s Game of Life example is separate from most of the other example decision sets in Red Hat Decision Manager and is located in
<literal>~/rhdm-7.10.0-sources/src/droolsjbpm-integration-$VERSION/droolsjbpm-integration-examples</literal> of the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link>.</simpara>
</note>
<simpara>In Conway’s Game of Life, a user interacts with the game by creating an initial configuration or an advanced pattern with defined properties and then observing how the initial state evolves. The objective of the game is to show the development of a population, generation by generation. Each generation results from the preceding one, based on the simultaneous evaluation of all cells.</simpara>
<simpara>The following basic rules govern what the next generation looks like:</simpara>
<itemizedlist>
<listitem>
<simpara>If a live cell has fewer than two live neighbors, it dies of loneliness.</simpara>
</listitem>
<listitem>
<simpara>If a live cell has more than three live neighbors, it dies from overcrowding.</simpara>
</listitem>
<listitem>
<simpara>If a dead cell has exactly three live neighbors, it comes to life.</simpara>
</listitem>
</itemizedlist>
<simpara>Any cell that does not meet any of those criteria is left as is for the next generation.</simpara>
<simpara>The Conway’s Game of Life example uses Red Hat Decision Manager rules with <literal>ruleflow-group</literal> attributes to define the pattern implemented in the game. The example also contains a version of the decision set that achieves the same behavior using agenda groups. Agenda groups enable you to partition the decision engine agenda to provide execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>This overview does not explore the version of the Conway example using agenda groups. For more information about agenda groups, see the Red Hat Decision Manager example decision sets that specifically address agenda groups.</simpara>
<bridgehead xml:id="conway_example_execution_and_interaction" renderas="sect3" remap="_conway_example_execution_and_interaction">Conway example execution and interaction</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Conway ruleflow example by running the <literal>org.drools.examples.conway.ConwayRuleFlowGroupRun</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Conway example, the <literal>Conway’s Game of Life</literal> GUI window appears. This window contains an empty grid, or "arena" where the life simulation takes place. Initially the grid is empty because no live cells are in the system yet.</simpara>
<figure>
<title>Conway example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway1.png" align="center"/>
</imageobject>
<textobject><phrase>conway1</phrase></textobject>
</mediaobject>
</figure>
<simpara>Select a predefined pattern from the <emphasis role="strong">Pattern</emphasis> drop-down menu and click <emphasis role="strong">Next Generation</emphasis> to click through each population generation. Each cell is either alive or dead, where live cells contain a green ball. As the population evolves from the initial pattern, cells live or die relative to neighboring cells, according to the rules of the game.</simpara>
<figure>
<title>Generation evolution in Conway example</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway2.png" align="center"/>
</imageobject>
<textobject><phrase>conway2</phrase></textobject>
</mediaobject>
</figure>
<simpara>Neighbors include not only cells to the left, right, top, and bottom but also cells that are connected diagonally, so that each cell has a total of eight neighbors. Exceptions are the corner cells, which have only three neighbors, and the cells along the four borders, with five neighbors each.</simpara>
<simpara>You can manually intervene to create or kill cells by clicking the cell.</simpara>
<simpara>To run through an evolution automatically from the initial pattern, click <emphasis role="strong">Start</emphasis>.</simpara>
<bridgehead xml:id="conway_example_rules_with_ruleflow_groups" renderas="sect3" remap="_conway_example_rules_with_ruleflow_groups">Conway example rules with ruleflow groups</bridgehead>
<simpara>The rules in the <literal>ConwayRuleFlowGroupRun</literal> example use ruleflow groups to control rule execution. A ruleflow group is a group of rules associated by the <literal>ruleflow-group</literal> rule attribute. These rules can only fire when the group is activated. The group itself can only become active when the elaboration of the ruleflow diagram reaches the node representing the group.</simpara>
<simpara>The Conway example uses the following ruleflow groups for rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"register neighbor"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"evaluate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"calculate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"reset calculate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"birth"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"kill"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"kill all"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>All of the <literal>Cell</literal> objects are inserted into the KIE session and the <literal>"register …​"</literal> rules in the ruleflow group <literal>"register neighbor"</literal> are allowed to execute by the ruleflow process. This group of four rules creates <literal>Neighbor</literal> relations between some cell and its northeastern, northern, northwestern, and western neighbors.</simpara>
<simpara>This relation is bidirectional and handles the other four directions. Border cells do not require any special treatment. These cells are not paired with neighboring cells where there is not any.</simpara>
<simpara>By the time all activations have fired for these rules, all cells are related to all their neighboring cells.</simpara>
<formalpara>
<title>Rules "register …​"</title>
<para>
<screen>rule "register north east"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )
  then
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );
end

rule "register north"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $north : Cell( row  == ($row - 1), col == $col )
  then
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );
end

rule "register north west"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )
  then
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );
end

rule "register west"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $west : Cell( row  == $row, col == ( $col - 1 ) )
  then
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );
end</screen>
</para>
</formalpara>
<simpara>After all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to <literal>Live</literal>. Then, when the user clicks <emphasis role="strong">Start</emphasis> or <emphasis role="strong">Next Generation</emphasis>, the example executes the <literal>Generation</literal> ruleflow. This ruleflow manages all changes of cells in each generation cycle.</simpara>
<figure>
<title>Generation ruleflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway_ruleflow_generation.png" align="center"/>
</imageobject>
<textobject><phrase>conway ruleflow generation</phrase></textobject>
</mediaobject>
</figure>
<simpara>The ruleflow process enters the <literal>"evaluate"</literal> ruleflow group and any active rules in the group can fire. The rules <literal>"Kill the …​"</literal> and <literal>"Give Birth"</literal> in this group apply the game rules to birth or kill cells. The example uses the <literal>phase</literal> attribute to drive the reasoning of the <literal>Cell</literal> object by specific groups of rules. Typically, the phase is tied to a ruleflow group in the ruleflow process definition.</simpara>
<simpara>Notice that the example does not change the state of any <literal>Cell</literal> objects at this point because it must complete the full evaluation before those changes can be applied. The example sets the cell to a <literal>phase</literal> that is either <literal>Phase.KILL</literal> or <literal>Phase.BIRTH</literal>, which is used later to control actions applied to the <literal>Cell</literal> object.</simpara>
<formalpara>
<title>Rules "Kill the …​" and "Give Birth"</title>
<para>
<screen>rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
  when
    // A live cell has fewer than 2 live neighbors.
    theCell: Cell( liveNeighbors &lt; 2, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
  when
    // A live cell has more than 3 live neighbors.
    theCell: Cell( liveNeighbors &gt; 3, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
  when
    // A dead cell has 3 live neighbors.
    theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        theCell.setPhase( Phase.BIRTH );
    }
end</screen>
</para>
</formalpara>
<simpara>After all <literal>Cell</literal> objects in the grid have been evaluated, the example uses the <literal>"reset calculate"</literal> rule to clear any activations in the <literal>"calculate"</literal> ruleflow group. The example then enters a split in the ruleflow that enables the rules <literal>"kill"</literal> and <literal>"birth"</literal> to fire, if the ruleflow group is activated. These rules apply the state change.</simpara>
<formalpara>
<title>Rules "reset calculate", "kill", and "birth"</title>
<para>
<screen>rule "reset calculate"
    ruleflow-group "reset calculate"
  when
  then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
  when
    theCell: Cell( phase == Phase.KILL )
  then
    modify( theCell ){
        setCellState( CellState.DEAD ),
        setPhase( Phase.DONE );
    }
end

rule "birth"
    ruleflow-group "birth"
    no-loop
  when
    theCell: Cell( phase == Phase.BIRTH )
  then
    modify( theCell ){
        setCellState( CellState.LIVE ),
        setPhase( Phase.DONE );
    }
end</screen>
</para>
</formalpara>
<simpara>At this stage, several <literal>Cell</literal> objects have been modified with the state changed to either <literal>LIVE</literal> or <literal>DEAD</literal>. When a cell becomes live or dead, the example uses the <literal>Neighbor</literal> relation in the rules <literal>"Calculate …​"</literal> to iterate over all surrounding cells, increasing or decreasing the <literal>liveNeighbor</literal> count. Any cell that has its count changed is also set to the <literal>EVALUATE</literal> phase to make sure it is included in the reasoning during the evaluation stage of the ruleflow process.</simpara>
<simpara>After the live count has been determined and set for all cells, the ruleflow process ends. If the user initially clicked <emphasis role="strong">Start</emphasis>, the decision engine restarts the ruleflow at that point. If the user initially clicked <emphasis role="strong">Next Generation</emphasis>, the user can request another generation.</simpara>
<formalpara>
<title>Rules "Calculate …​"</title>
<para>
<screen>rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active
  when
    theCell: Cell( cellState == CellState.LIVE )
    Neighbor( cell == theCell, $neighbor : neighbor )
  then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ),
        setPhase( Phase.EVALUATE );
    }
end

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active
  when
    theCell: Cell( cellState == CellState.DEAD )
    Neighbor( cell == theCell, $neighbor : neighbor )
  then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ),
        setPhase( Phase.EVALUATE );
    }
end</screen>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-doom-ref_drl-rules">
<title>House of Doom example decisions (backward chaining and recursion)</title>
<simpara>The House of Doom example decision set demonstrates how the decision engine uses backward chaining and recursion to reach defined goals or subgoals in a hierarchical system.</simpara>
<simpara>The following is an overview of the House of Doom example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>backwardchaining</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.backwardchaining.HouseOfDoomMain</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.backwardchaining.BC-Example.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates backward chaining and recursion</simpara>
</listitem>
</itemizedlist>
<simpara>A backward-chaining rule system is a goal-driven system that starts with a conclusion that the decision engine attempts to satisfy, often using recursion. If the system cannot reach the conclusion or goal, it searches for subgoals, which are conclusions that complete part of the current goal. The system continues this process until either the initial conclusion is satisfied or all subgoals are satisfied.</simpara>
<simpara>In contrast, a forward-chaining rule system is a data-driven system that starts with a fact in the working memory of the decision engine and reacts to changes to that fact. When objects are inserted into working memory, any rule conditions that become true as a result of the change are scheduled for execution by the agenda.</simpara>
<simpara>The decision engine in Red Hat Decision Manager uses both forward and backward chaining to evaluate rules.</simpara>
<simpara>The following diagram illustrates how the decision engine evaluates rules using forward chaining overall with a backward-chaining segment in the logic flow:</simpara>
<figure>
<title>Rule evaluation logic using forward and backward chaining</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/RuleEvaluation_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>RuleEvaluation Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>The House of Doom example uses rules with various types of queries to find the location of rooms and items within the house. The sample class <literal>Location.java</literal> contains the <literal>item</literal> and <literal>location</literal> elements used in the example. The sample class <literal>HouseOfDoomMain.java</literal> inserts the items or rooms in their respective locations in the house and executes the rules.</simpara>
<formalpara>
<title>Items and locations in HouseOfDoomMain.java class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.insert( new Location("Office", "House") );
ksession.insert( new Location("Kitchen", "House") );
ksession.insert( new Location("Knife", "Kitchen") );
ksession.insert( new Location("Cheese", "Kitchen") );
ksession.insert( new Location("Desk", "Office") );
ksession.insert( new Location("Chair", "Office") );
ksession.insert( new Location("Computer", "Desk") );
ksession.insert( new Location("Drawer", "Desk") );</programlisting>
</para>
</formalpara>
<simpara>The example rules rely on backward chaining and recursion to determine the location of all items and rooms in the house structure.</simpara>
<simpara>The following diagram illustrates the structure of the House of Doom and the items and rooms within it:</simpara>
<figure>
<title>House of Doom structure</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/TransitiveReasoning_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>TransitiveReasoning Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>To execute the example, run the <literal>org.drools.examples.backwardchaining.HouseOfDoomMain</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Execution output in the IDE console</title>
<para>
<screen>go1
Office is in the House
---
go2
Drawer is in the House
---
go3
---
Key is in the Office
---
go4
Chair is in the Office
Desk is in the Office
Key is in the Office
Computer is in the Office
Drawer is in the Office
---
go5
Chair is in Office
Desk is in Office
Drawer is in Desk
Key is in Drawer
Kitchen is in House
Cheese is in Kitchen
Knife is in Kitchen
Computer is in Desk
Office is in House
Key is in Office
Drawer is in House
Computer is in House
Key is in House
Desk is in House
Chair is in House
Knife is in House
Cheese is in House
Computer is in Office
Drawer is in Office
Key is in Desk</screen>
</para>
</formalpara>
<simpara>All rules in the example have fired to detect the location of all items in the house and to print the location of each in the output.</simpara>
<bridgehead xml:id="recursive_query_and_related_rules" renderas="sect3" remap="_recursive_query_and_related_rules">Recursive query and related rules</bridgehead>
<simpara>A recursive query repeatedly searches through the hierarchy of a data structure for relationships between elements.</simpara>
<simpara>In the House of Doom example, the <literal>BC-Example.drl</literal> file contains an <literal>isContainedIn</literal> query that most of the rules in the example use to recursively evaluate the house data structure for data inserted into the decision engine:</simpara>
<formalpara>
<title>Recursive query in BC-Example.drl</title>
<para>
<screen>query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"go"</literal> prints every string inserted into the system to determine how items are implemented, and the rule <literal>"go1"</literal> calls the query <literal>isContainedIn</literal>:</simpara>
<formalpara>
<title>Rules "go" and "go1"</title>
<para>
<screen>rule "go" salience 10
  when
    $s : String()
  then
    System.out.println( $s );
end

rule "go1"
  when
    String( this == "go1" )
    isContainedIn("Office", "House"; )
  then
    System.out.println( "Office is in the House" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go1"</literal> string into the decision engine and activates the <literal>"go1"</literal> rule to detect that item <literal>Office</literal> is in the location <literal>House</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go1" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go1" output in the IDE console</title>
<para>
<screen>go1
Office is in the House</screen>
</para>
</formalpara>
<bridgehead xml:id="transitive_closure_rule" renderas="sect3" remap="_transitive_closure_rule">Transitive closure rule</bridgehead>
<simpara>Transitive closure is a relationship between an element contained in a parent element that is multiple levels higher in a hierarchical structure.</simpara>
<simpara>The rule <literal>"go2"</literal> identifies the transitive closure relationship of the <literal>Drawer</literal> and the <literal>House</literal>: The <literal>Drawer</literal> is in the <literal>Desk</literal> in the <literal>Office</literal> in the <literal>House</literal>.</simpara>
<screen>rule "go2"
  when
    String( this == "go2" )
    isContainedIn("Drawer", "House"; )
  then
    System.out.println( "Drawer is in the House" );
end</screen>
<simpara>The example inserts the <literal>"go2"</literal> string into the decision engine and activates the <literal>"go2"</literal> rule to detect that item <literal>Drawer</literal> is ultimately within the location <literal>House</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go2" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go2" output in the IDE console</title>
<para>
<screen>go2
Drawer is in the House</screen>
</para>
</formalpara>
<simpara>The decision engine determines this outcome based on the following logic:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The query recursively searches through several levels in the house to detect the transitive closure between <literal>Drawer</literal> and <literal>House</literal>.</simpara>
</listitem>
<listitem>
<simpara>Instead of using <literal>Location( x, y; )</literal>, the query uses the value of <literal>(z, y; )</literal> because <literal>Drawer</literal> is not directly in <literal>House</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>z</literal> argument is currently unbound, which means it has no value and returns everything that is in the argument.</simpara>
</listitem>
<listitem>
<simpara>The <literal>y</literal> argument is currently bound to <literal>House</literal>, so <literal>z</literal> returns <literal>Office</literal> and <literal>Kitchen</literal>.</simpara>
</listitem>
<listitem>
<simpara>The query gathers information from the <literal>Office</literal> and checks recursively if the <literal>Drawer</literal> is in the <literal>Office</literal>. The query line <literal>isContainedIn( x, z; )</literal> is called for these parameters.</simpara>
</listitem>
<listitem>
<simpara>No instance of <literal>Drawer</literal> exists directly in <literal>Office</literal>, so no match is found.</simpara>
</listitem>
<listitem>
<simpara>With <literal>z</literal> unbound, the query returns data within the <literal>Office</literal> and determines that <emphasis role="strong">z == Desk</emphasis>.</simpara>
<screen>isContainedIn(x==drawer, z==desk)</screen>
</listitem>
<listitem>
<simpara>The <literal>isContainedIn</literal> query recursively searches three times, and on the third time, the query detects an instance of <literal>Drawer</literal> in <literal>Desk</literal>.</simpara>
<screen>Location(x==drawer, y==desk)</screen>
</listitem>
<listitem>
<simpara>After this match on the first location, the query recursively searches back up the structure to determine that the <literal>Drawer</literal> is in the <literal>Desk</literal>, the <literal>Desk</literal> is in the <literal>Office</literal>, and the <literal>Office</literal> is in the <literal>House</literal>. Therefore, the <literal>Drawer</literal> is in the <literal>House</literal> and the rule is satisfied.</simpara>
</listitem>
</orderedlist>
<bridgehead xml:id="reactive_query_rule" renderas="sect3" remap="_reactive_query_rule">Reactive query rule</bridgehead>
<simpara>A reactive query searches through the hierarchy of a data structure for relationships between elements and is dynamically updated when elements in the structure are modified.</simpara>
<simpara>The rule <literal>"go3"</literal> functions as a reactive query that detects if a new item <literal>Key</literal> ever becomes present in the <literal>Office</literal> by transitive closure: A <literal>Key</literal> in the <literal>Drawer</literal> in the <literal>Office</literal>.</simpara>
<formalpara>
<title>Rule "go3"</title>
<para>
<screen>rule "go3"
  when
    String( this == "go3" )
    isContainedIn("Key", "Office"; )
  then
    System.out.println( "Key is in the Office" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go3"</literal> string into the decision engine and activates the <literal>"go3"</literal> rule. Initially, this rule is not satisfied because no item <literal>Key</literal> exists in the house structure, so the rule produces no output.</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go3" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go3" output in the IDE console (unsatisfied)</title>
<para>
<screen>go3</screen>
</para>
</formalpara>
<simpara>The example then inserts a new item <literal>Key</literal> in the location <literal>Drawer</literal>, which is in <literal>Office</literal>. This change satisfies the transitive closure in the <literal>"go3"</literal> rule and the output is populated accordingly.</simpara>
<formalpara>
<title>Insert new item location and fire rules</title>
<para>
<screen>ksession.insert( new Location("Key", "Drawer") );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go3" output in the IDE console (satisfied)</title>
<para>
<screen>Key is in the Office</screen>
</para>
</formalpara>
<simpara>This change also adds another level in the structure that the query includes in subsequent recursive searches.</simpara>
<bridgehead xml:id="queries_with_unbound_arguments_in_rules" renderas="sect3" remap="_queries_with_unbound_arguments_in_rules">Queries with unbound arguments in rules</bridgehead>
<simpara>A query with one or more unbound arguments returns all undefined (unbound) items within a defined (bound) argument of the query. If all arguments in a query are unbound, then the query returns all items within the scope of the query.</simpara>
<simpara>The rule <literal>"go4"</literal> uses an unbound argument <literal>thing</literal> to search for all items within the bound argument <literal>Office</literal>, instead of using a bound argument to search for a specific item in the <literal>Office</literal>:</simpara>
<formalpara>
<title>Rule "go4"</title>
<para>
<screen>rule "go4"
  when
    String( this == "go4" )
    isContainedIn(thing, "Office"; )
  then
    System.out.println( thing + "is in the Office" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go4"</literal> string into the decision engine and activates the <literal>"go4"</literal> rule to return all items in the <literal>Office</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go4" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go4" output in the IDE console</title>
<para>
<screen>go4
Chair is in the Office
Desk is in the Office
Key is in the Office
Computer is in the Office
Drawer is in the Office</screen>
</para>
</formalpara>
<simpara>The rule <literal>"go5"</literal> uses both unbound arguments <literal>thing</literal> and <literal>location</literal> to search for all items and their locations in the entire <literal>House</literal> data structure:</simpara>
<formalpara>
<title>Rule "go5"</title>
<para>
<screen>rule "go5"
  when
    String( this == "go5" )
    isContainedIn(thing, location; )
  then
    System.out.println(thing + " is in " + location );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go5"</literal> string into the decision engine and activates the <literal>"go5"</literal> rule to return all items and their locations in the <literal>House</literal> data structure:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go5" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go5" output in the IDE console</title>
<para>
<screen>go5
Chair is in Office
Desk is in Office
Drawer is in Desk
Key is in Drawer
Kitchen is in House
Cheese is in Kitchen
Knife is in Kitchen
Computer is in Desk
Office is in House
Key is in Office
Drawer is in House
Computer is in House
Key is in House
Desk is in House
Chair is in House
Knife is in House
Cheese is in House
Computer is in Office
Drawer is in Office
Key is in Desk</screen>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="performance-tuning-drl-ref_drl-rules">
<title>Performance tuning considerations with DRL</title>
<simpara>The following key concepts or suggested practices can help you optimize DRL rules and decision engine performance. These concepts are summarized in this section as a convenience and are explained in more detail in the cross-referenced documentation, where applicable. This section will expand or change as needed with new releases of Red Hat Decision Manager.</simpara>
<variablelist>
<varlistentry>
<term>Define the property and value of pattern constraints from left to right</term>
<listitem>
<simpara>In DRL pattern constraints, ensure that the fact property name is on the left side of the operator and that the value (constant or a variable) is on the right side. The property name must always be the key in the index and not the value. For example, write <literal>Person( firstName == "John" )</literal> instead of <literal>Person( "John" == firstName )</literal>. Defining the constraint property and value from right to left can hinder decision engine performance.</simpara>
<simpara>For more information about DRL patterns and constraints, see <xref linkend="drl-rules-WHEN-con_drl-rules"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Use equality operators more than other operator types in pattern constraints when possible</term>
<listitem>
<simpara>Although the decision engine supports many DRL operator types that you can use to define your business rule logic, the equality operator <literal>==</literal> is evaluated most efficiently by the decision engine. Whenever practical, use this operator instead of other operator types. For example, the pattern <literal>Person( firstName == "John" )</literal> is evaluated more efficiently than <literal>Person( firstName != "OtherName" )</literal>. In some cases, using only equality operators might be impractical, so consider all of your business logic needs and options as you use DRL operators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>List the most restrictive rule conditions first</term>
<listitem>
<simpara>For rules with multiple conditions, list the conditions from most to least restrictive so that the decision engine can avoid assessing the entire set of conditions if the more restrictive conditions are not met.</simpara>
<simpara>For example, the following conditions are part of a travel-booking rule that applies a discount to travelers who book both a flight and a hotel together. In this scenario, customers rarely book hotels with flights to receive this discount, so the hotel condition is rarely met and the rule is rarely executed. Therefore, the first condition ordering is more efficient because it prevents the decision engine from evaluating the flight condition frequently and unnecessarily when the hotel condition is not met.</simpara>
<formalpara>
<title>Preferred condition order: hotel and flight</title>
<para>
<screen>when
  $h:hotel() // Rarely booked
  $f:flight()</screen>
</para>
</formalpara>
<formalpara>
<title>Inefficient condition order: flight and hotel</title>
<para>
<screen>when
  $f:flight()
  $h:hotel() // Rarely booked</screen>
</para>
</formalpara>
<simpara>For more information about DRL patterns and constraints, see <xref linkend="drl-rules-WHEN-con_drl-rules"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Avoid iterating over large collections of objects with excessive <literal>from</literal> clauses</term>
<listitem>
<simpara>Avoid using the <literal>from</literal> condition element in DRL rules to iterate over large collections of objects, as shown in the following example:</simpara>
<formalpara>
<title>Example conditions with <literal>from</literal> clause</title>
<para>
<screen>when
  $c: Company()
  $e : Employee ( salary &gt; 100000.00) from $c.employees</screen>
</para>
</formalpara>
<simpara>In such cases, the decision engine iterates over the large graph every time the rule condition is evaluated and impedes  rule evaluation.</simpara>
<simpara>Alternatively, instead of adding an object with a large graph that the decision engine must iterate over frequently, add the collection directly to the KIE session and then join the collection in the condition, as shown in the following example:</simpara>
<formalpara>
<title>Example conditions without <literal>from</literal> clause</title>
<para>
<screen>when
  $c: Company();
  Employee (salary &gt; 100000.00, company == $c)</screen>
</para>
</formalpara>
<simpara>In this example, the decision engine iterates over the list only one time and can evaluate rules more efficiently.</simpara>
<simpara>For more information about the <literal>from</literal> element or other DRL condition elements, see <xref linkend="drl-rules-WHEN-elements-ref_drl-rules"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Use decision engine event listeners instead of <literal>System.out.println</literal> statements in rules for debug logging</term>
<listitem>
<simpara>You can use <literal>System.out.println</literal> statements in your rule actions for debug logging and console output, but doing this for many rules can impede rule evaluation. As a more efficient alternative, use the built-in decision engine event listeners when possible. If these listeners do not meet your requirements, use a system logging utility supported by the decision engine, such as Logback, Apache Commons Logging, or Apache Log4j.</simpara>
<simpara>For more information about supported decision engine event listeners and logging utilities, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#engine-event-listeners-con_decision-engine"><emphasis>Decision engine in Red Hat Decision Manager</emphasis></link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Use the <literal>drools-metric</literal> module to identify the obstruction in your rules</term>
<listitem>
<simpara>You can use the <literal>drools-metric</literal> module to identify slow rules especially when you process many rules. The <literal>drools-metric</literal> module can also assist in analyzing the decision engine performance. Note that the <literal>drools-metric</literal> module is not for production environment use. However, you can perform the analysis in your test environment.</simpara>
<simpara>To analyze the decision engine performance using <literal>drools-metric</literal>, add <literal>drools-metric</literal> to your project dependencies and enable trace logging for <literal>org.drools.metric.util.MetricLogUtils</literal> , as shown in the following example:</simpara>
<formalpara>
<title>Example project dependency for <literal>drools-metric</literal></title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-metric&lt;/artifactId&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example logback.xml configuration file</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;configuration&gt;
  &lt;logger name="org.drools.metric.util.MetricLogUtils" level="trace"/&gt;
  ...
&lt;configuration&gt;</programlisting>
</para>
</formalpara>
<simpara>Also, enable <literal>MetricLogUtils</literal> by setting the system property <literal>drools.metric.logger.enabled</literal> to <literal>true</literal>. Optionally, you can change the microseconds threshold of metric logging by setting the <literal>drools.metric.logger.threshold</literal> system property.</simpara>
<note>
<simpara>Only node executions exceeding the threshold are logged. The default value is <literal>500</literal>.</simpara>
</note>
<simpara>After you complete the configuration, rule execution produces logs as shown in the following example:</simpara>
<formalpara>
<title>Example rule execution output</title>
<para>
<screen>TRACE [JoinNode(6) - [ClassObjectType class=com.sample.Order]], evalCount:1000, elapsedMicro:5962
TRACE [JoinNode(7) - [ClassObjectType class=com.sample.Order]], evalCount:100000, elapsedMicro:95553
TRACE [ AccumulateNode(8) ], evalCount:4999500, elapsedMicro:2172836
TRACE [EvalConditionNode(9)]: cond=com.sample.Rule_Collect_expensive_orders_combination930932360Eval1Invoker@ee2a6922], evalCount:49500, elapsedMicro:18787</screen>
</para>
</formalpara>
<simpara>This example includes the following key parameters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>evalCount</literal> is the number of constraint evaluations against inserted facts during the node execution.</simpara>
</listitem>
<listitem>
<simpara><literal>elapsedMicro</literal> is the elapsed time of the node execution in microseconds.</simpara>
</listitem>
</itemizedlist>
<simpara>If you find an outstanding <literal>evalCount</literal> or <literal>elapsedMicro</literal> log, correlate the node name with <literal>ReteDumper.dumpAssociatedRulesRete()</literal> output to identify the rule associated with the node.</simpara>
<formalpara>
<title>Example ReteDumper usage</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ReteDumper.dumpAssociatedRulesRete(kbase);</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example ReteDumper output</title>
<para>
<screen>[ AccumulateNode(8) ] : [Collect expensive orders combination]
...</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</chapter>
<chapter xml:id="next_steps" remap="_next_steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-test-scenarios"><emphasis>Testing a decision service using test scenarios</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-guided-decision-tables">
<title>Designing a decision service using guided decision tables</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can use guided decision tables to define business rules in a wizard-led tabular format. These rules are compiled into Drools Rule Language (DRL) and form the core of the decision service for your project.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the guided decision tables have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_guided-decision-tables">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="guided-decision-tables-con_guided-decision-tables">
<title>Guided decision tables</title>
<simpara>Guided decision tables are a wizard-led alternative to spreadsheet decision tables for defining business rules in a tabular format. With guided decision tables, you are led by a UI-based wizard in Business Central that helps you define rule attributes, metadata, conditions, and actions based on specified data objects in your project. After you create your guided decision tables, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>All data objects related to a guided decision table must be in the same project package as the guided decision table. Assets in the same package are imported by default. After you create the necessary data objects and the guided decision table, you can use the <emphasis role="strong">Data Objects</emphasis> tab of the guided decision tables designer to verify that all required data objects are listed or to import other existing data objects by adding a <emphasis role="strong">New item</emphasis>.</simpara>
</chapter>
<chapter xml:id="data-objects-con_guided-decision-tables">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_guided-decision-tables">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="guided-decision-tables-create-proc">
<title>Creating guided decision tables</title>
<simpara>You can use guided decision tables to define rule attributes, metadata, conditions, and actions in a tabular format that can be added to your business rules project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Guided Decision Table</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Guided Decision Table</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Use Wizard</emphasis> to finish setting up the table in the wizard, or leave this option unselected to finish creating the table and specify remaining configurations in the guided decision tables designer.</simpara>
</listitem>
<listitem>
<simpara>Select the hit policy that you want your rows of rules in the table to conform to. For details, see <xref linkend="hit-policies-con"/>.</simpara>
</listitem>
<listitem>
<simpara>Specify whether you want the <emphasis role="strong">Extended entry</emphasis> or <emphasis role="strong">Limited entry</emphasis> table. For details, see <xref linkend="guided-decision-tables-types-con"/>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to complete the setup. If you have selected <emphasis role="strong">Use Wizard</emphasis>, the Guided Decision Table wizard is displayed. If you did not select the <emphasis role="strong">Use Wizard</emphasis> option, this prompt does not appear and you are taken directly to the table designer.</simpara>
<simpara>For example, the following wizard setup is for a guided decision table in a loan application decision service:</simpara>
<figure>
<title>Create guided decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6326_1.png"/>
</imageobject>
<textobject><phrase>6326 1</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>If you are using the wizard, add any available imports, fact patterns, constraints, and actions, and select whether table columns should expand. Click <emphasis role="strong">Finish</emphasis> to close the wizard and view the table designer.</simpara>
<figure>
<title>Guided Decision Table wizard</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6328_1.png"/>
</imageobject>
<textobject><phrase>6328 1</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<simpara>In the guided decision tables designer, you can add or edit columns and rows, and make other final adjustments.</simpara>
</chapter>
<chapter xml:id="hit-policies-con">
<title>Hit policies for guided decision tables</title>
<simpara>Hit policies determine the order in which rules (rows) in a guided decision table are applied, whether top to bottom, per specified priority, or other options.</simpara>
<simpara>The following hit policies are available:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">None:</emphasis> (Default hit policy) Multiple rows can be executed and the verification warns about rows that conflict. Any decision tables that have been uploaded (using a non-guided decision table spreadsheet) will adopt this hit policy.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Resolved Hit:</emphasis> Only one row at a time can be executed according to specified priority, regardless of list order (you can give row 10 priority over row 5, for example). This means you can keep the order of the rows you want for visual readability, but specify priority exceptions.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Unique Hit:</emphasis> Only one row at a time can be executed, and each row must be unique, with no overlap of conditions being met. If more than one row is executed, then the verification produces a warning at development time.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">First Hit:</emphasis> Only one row at a time can be executed in the order listed in the table, top to bottom.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule Order:</emphasis> Multiple rows can be executed and verification does not report conflicts between the rows since they are expected to happen.</simpara>
</listitem>
</itemizedlist>
<figure>
<title>Available hit policies</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/hit-policies-image_1.png"/>
</imageobject>
<textobject><phrase>hit policies image 1</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="hit-policies-examples-ref">
<title>Hit policy examples: Decision table for discounts on movie tickets</title>
<simpara>The following is part of an example decision table for discounts on movie tickets based on customer age, student status, or military status, or all three.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example decision table for available discounts on movie tickets</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Row Number</entry>
<entry align="left" valign="top">Discount Type</entry>
<entry align="left" valign="top">Discount</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Senior citizen (age 60+)</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Student</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Military</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In this example, the total discount to be applied in the end will vary depending on the hit policy specified for the table:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">None/Rule Order:</emphasis> With both <emphasis role="strong">None</emphasis> and <emphasis role="strong">Rule Order</emphasis> hit policies, all applicable rules are incorporated, in this case allowing discounts to be stacked for each customer.</simpara>
<simpara>Example: A senior citizen who is also a student and a military veteran will receive all three discounts, totaling 30%.</simpara>
<simpara>Key difference: With <emphasis role="strong">None</emphasis>, warnings are created for multiple rows applied. With <emphasis role="strong">Rule Order</emphasis>, those warnings are not created.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">First Hit/Resolved Hit:</emphasis> With both <emphasis role="strong">First Hit</emphasis> and <emphasis role="strong">Resolved Hit</emphasis> policies, only one of the discounts can be applied.</simpara>
<simpara>For <emphasis role="strong">First Hit</emphasis>, the discount that is satisfied first in the list is applied and the others are ignored.</simpara>
<simpara>Example: A senior citizen who is also a student and a military veteran will receive only the senior citizen discount of 10%, since that is listed first in the table.</simpara>
<simpara>For <emphasis role="strong">Resolved Hit</emphasis>, a modified table is required. The discount that you assign a priority exception to in the table, regardless of listed order, will be applied first. To assign this exception, include a new column that specifies the priority of one discount (row) over others.</simpara>
<simpara>Example: If military discounts are prioritized higher than age or student discounts, despite the listed order, then a senior citizen who is also a student and a military veteran will receive only the military discount of 10%, regardless of age or student status.</simpara>
<simpara>Consider the following modified decision table that accommodates a <emphasis role="strong">Resolved Hit</emphasis> policy:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Modified decision table that accommodates a <emphasis>Resolved Hit</emphasis> policy</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Row Number</entry>
<entry align="left" valign="top">Discount Type</entry>
<entry align="left" valign="top">Has Priority over Row</entry>
<entry align="left" valign="top">Discount</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Senior citizen (age 60+)</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Student</simpara></entry>
<entry align="left" valign="top"/>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Military</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In this modified table, the military discount is essentially the new row 1 and therefore takes priority over both age and student discounts, and any other discounts added later. You do not need to specify priority over rows "1 and 2", only over row "1". This changes the row hit order to 3 → 1 → 2 → …​ and so on as the table grows.</simpara>
<note>
<simpara>The row order would be changed in the same way if you actually moved the military discount to row 1 and applied a <emphasis role="strong">First Hit</emphasis> policy to the table instead. However, if you want the rules listed in a certain way and applied differently, such as in an alphabetized table, the <emphasis role="strong">Resolved Hit</emphasis> policy is useful.</simpara>
</note>
<simpara>Key difference: With <emphasis role="strong">First Hit</emphasis>, rules are applied strictly in the listed order. With <emphasis role="strong">Resolved Hit</emphasis>, rules are applied in the listed order unless priority exceptions are specified.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Unique Hit:</emphasis> A modified table is required. With a <emphasis role="strong">Unique Hit</emphasis> policy, rows must be created in a way that it is impossible to satisfy multiple rules at one time. However, you can still specify row-by-row whether to apply one rule or multiple. In this way, with a <emphasis role="strong">Unique Hit</emphasis> policy you can make decision tables more granular and prevent overlap warnings.</simpara>
<simpara>Consider the following modified decision table that accommodates a <emphasis role="strong">Unique Hit</emphasis> policy:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Modified decision table that accommodates a <emphasis>Unique Hit</emphasis> policy</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Row Number</entry>
<entry align="left" valign="top">Is Senior Citizen (age 65+)</entry>
<entry align="left" valign="top">Is Student</entry>
<entry align="left" valign="top">Is Military</entry>
<entry align="left" valign="top">Discount</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>20%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>20%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>20%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>yes</simpara></entry>
<entry align="left" valign="top"><simpara>30%</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In this modified table, each row is unique, with no allowance of overlap, and any single discount or any combination of discounts is accommodated.</simpara>
</listitem>
</itemizedlist>
<section xml:id="guided-decision-tables-types-con">
<title>Types of guided decision tables</title>
<simpara>Two types of decision tables are supported in Red Hat Decision Manager: Extended entry and Limited entry tables.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Extended entry:</emphasis> An Extended Entry decision table is one for which the column definitions specify Pattern, Field, and Operator but not value.
The values, or states, are themselves held in the body of the decision table.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/dtable-extended-entry.png"/>
</imageobject>
<textobject><phrase>Extended entry</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara><emphasis role="strong">Limited entry:</emphasis> A Limited Entry decision table is one for which the column definitions specify value in addition to Pattern, Field, and Operator.
The decision table states, held in the body of the table, are boolean where a positive value (a marked check box) has the effect of meaning the column should apply, or be matched. A negative value (a cleared check box) means the column does not apply.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/dtable-limited-entry.png"/>
</imageobject>
<textobject><phrase>Limited entry</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="guided-decision-tables-columns-create-proc">
<title>Adding columns to guided decision tables</title>
<simpara>After you have created the guided decision table, you can define and add various types of columns within the guided decision tables designer.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Any data objects that will be used for column parameters, such as Facts and Fields, have been created within the same package where the guided decision table is found, or have been imported from another package in <emphasis role="strong">Data Objects</emphasis> → <emphasis role="strong">New item</emphasis> of the guided decision tables designer.</simpara>
</listitem>
</itemizedlist>
<simpara>For descriptions of these column parameters, see the "Required column parameters" segments for each column type in <xref linkend="guided-decision-tables-columns-types-con"/>.</simpara>
<simpara>For details about creating data objects, see
<xref linkend="data-objects-create-proc_guided-decision-tables"/>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided decision tables designer, click <emphasis role="strong">Columns</emphasis> → <emphasis role="strong">Insert Column</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Include advanced options</emphasis> to view the full list of column options.</simpara>
<figure>
<title>Add columns</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-add_1.png"/>
</imageobject>
<textobject><phrase>View column options in the *Add a new column* window</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Select the column type that you want to add, click <emphasis role="strong">Next</emphasis>, and follow the steps in the wizard to specify the data required to add the column.</simpara>
<simpara>For descriptions of each column type and required parameters for setup, see <xref linkend="guided-decision-tables-columns-types-con"/>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Finish</emphasis> to add the configured column.</simpara>
</listitem>
</orderedlist>
<simpara>After all columns are added, you can begin adding rows of rules correlating to your columns to complete the decision table. For details, see <xref linkend="guided-decision-tables-rows-create-proc"/>.</simpara>
<simpara>The following is an example decision table for a loan application decision service:</simpara>
<figure>
<title>Example of complete guided decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-add_02.png"/>
</imageobject>
<textobject><phrase>Example of complete guided decision table</phrase></textobject>
</mediaobject>
</figure>
</chapter>
<chapter xml:id="guided-decision-tables-columns-types-con">
<title>Types of columns in guided decision tables</title>
<simpara>The <emphasis role="strong">Add a new column</emphasis> wizard for guided decision tables provides the following column options. (Select <emphasis role="strong">Include advanced options</emphasis> to view all options.)</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-condition-con">Add a Condition</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-condition-BRL-con">Add a Condition BRL fragment</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-metadata-con">Add a Metadata column</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-action-BRL-con">Add an Action BRL fragment</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-attribute-con">Add an Attribute column</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-delete-fact-con">Delete an existing fact</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-work-item-con">Execute a Work Item</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-field-con">Set the value of a field</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="guided-decision-tables-columns-field-work-item-con">Set the value of a field with a Work Item result</link></simpara>
</listitem>
</itemizedlist>
<simpara>These column types and the parameters required for each in the <emphasis role="strong">Add a new column</emphasis> wizard are described in the sections that follow.</simpara>
<important xml:id="required-data-objects">
<title>IMPORTANT: Required data objects for column parameters</title>
<simpara>Some of the column parameters described in this section, such as Fact Patterns and Fields, provide drop-down options consisting only of data objects already defined within the same package where the guided decision table is found. Available data objects for the package are listed in the <emphasis role="strong">Data Objects</emphasis> panel of the Project Explorer and in the <emphasis role="strong">Data Objects</emphasis> tab of the guided decision tables designer. You can create additional data objects within the package as needed, or import them from another package in <emphasis role="strong">Data Objects</emphasis> → <emphasis role="strong">New item</emphasis> of the guided decision tables designer. For details about creating data objects, see
<xref linkend="data-objects-create-proc_guided-decision-tables"/>.</simpara>
</important>
<section xml:id="guided-decision-tables-columns-condition-con">
<title>"Add a Condition"</title>
<simpara>Conditions represent fact patterns defined in the left ("WHEN") portion of a rule. With this column option, you can define one or more condition columns that check for the presence or absence of data objects with certain field values, and that affect the action ("THEN") portion of the rule. You can define a binding for the fact in the condition table, or select one that has previously been defined. You can also choose to negate the pattern.</simpara>
<formalpara>
<title>Example rule conditions</title>
<para>
<screen>when
  $i : IncomeSource( type == "Asset" ) // Binds the IncomeSource object to the $i variable
then
  ...
end</screen>
</para>
</formalpara>
<screen>when
  not IncomeSource( type == "Asset" ) // Negates matching pattern
then
  ...
end</screen>
<simpara>After a binding is specified, you can define field constraints. If two or more columns are defined using the same fact pattern binding, the field constraints become composite field constraints on the same pattern. If you define multiple bindings for a single model class, each binding becomes a separate model class in the condition ("WHEN") side of the rule.</simpara>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Pattern:</emphasis> Select from the list of fact patterns already used in conditions in your table or create a new fact pattern. A fact pattern is a combination of an available data object in the package (see the note on <link linkend="required-data-objects">Required data objects</link> for details) and a model class binding that you specify. (Examples: <literal>LoanApplication [application]</literal> or <literal>IncomeSource [income]</literal> where the bracketed portion is the binding to the given fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Entry point:</emphasis> Define the entry point for the fact pattern, if applicable. An entry point is a gate or stream through which facts enter the decision engine, if specified. (Examples: <literal>Application Stream</literal>, <literal>Credit Check Stream</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Calculation type:</emphasis> Select one of the following calculation types:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Literal value:</emphasis> The value in the cell will be compared with the field using the operator.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Formula:</emphasis> The expression in the cell will be evaluated and then compared with the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Predicate:</emphasis> No field is needed; the expression will be evaluated to <literal>true</literal> or <literal>false</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field:</emphasis> Select a field from the previously specified fact pattern. The field options are defined in the fact file in the <emphasis role="strong">Data Objects</emphasis> panel of your project. (Examples: <literal>amount</literal> or <literal>lengthYears</literal> fields within the <literal>LoanApplication</literal> fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Binding (optional):</emphasis> Define a binding for the previously selected field, if needed. (Example: For pattern <literal>LoanApplication [application]</literal>, field <literal>amount</literal>, and operator <literal>equal to</literal>, if binding is set to <literal>$amount</literal>, the end condition will be <literal>application : LoanAppplication($amount : amount == [value])</literal>.)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Operator:</emphasis> Select the operator to be applied to the fact pattern and field previously specified.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Value list (optional):</emphasis> Enter a list of value options, delimited by a comma and space, to limit table input data for the condition ("WHEN") portion of the rule. When this value list is defined, the values will be provided in the table cells for that column as a drop-down list, from which users can select only one option. (Example list: <literal>Monday, Wednesday, Friday</literal> to specify only these three options)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Default value (optional):</emphasis> Select one of the previously defined value options as the default value that will appear in the cell automatically in a new row. If the default value is not specified, the table cell will be blank by default. You can also select a default value from any previously configured data enumerations in the project, listed in the <emphasis role="strong">Enumeration Definitions</emphasis> panel of the Project Explorer. (You can create enumerations in <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> → <emphasis role="strong"><emphasis>[select project]</emphasis></emphasis> → <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Enumeration</emphasis>.)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
</itemizedlist>
<section xml:id="guided-decision-tables-any-other-add-proc">
<title>Inserting an <literal>any other</literal> value in condition column cells</title>
<simpara>For simple condition columns in guided decision tables, you can apply an <literal>any other</literal> value to table cells within the column if the following parameters are set:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Calculation type</emphasis> for the condition column has been set to <literal>Literal value</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Operator</emphasis> has been set as equality <literal>==</literal> or inequality <literal>!=</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>any other</literal> value enables a rule to be defined for any other field values not explicitly defined in the rules already in the table. In the DRL source, <literal>any other</literal> is notated as <literal>not in</literal>.</simpara>
<formalpara>
<title>Example rule condition with <literal>not in</literal> used for <literal>any other</literal></title>
<para>
<screen>when
  IncomeSource( type not in ("Asset", "Job") )
  ...
then
  ...
end</screen>
</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Select a cell of a condition column that uses the <literal>==</literal> or <literal>!=</literal> operator.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right toolbar of the table designer, click <emphasis role="strong">Edit</emphasis> → <emphasis role="strong">Insert "any other" value</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="guided-decision-tables-columns-condition-BRL-con">
<title>"Add a Condition BRL fragment"</title>
<simpara>A Business Rule Language (BRL) fragment is a section of a rule created using the guided rules designer. The condition BRL fragment is the "WHEN" portion of the rule, and the <link linkend="guided-decision-tables-columns-action-BRL-con">action BRL fragment</link> is the "THEN" portion of the rule. With this column option, you can define a condition BRL fragment to be used in the left ("WHEN") side of a rule. Simpler column types can refer to Facts and Fact fields bound in the BRL fragment and vice-versa.</simpara>
<simpara>The following example is a condition BRL fragment for a loan application:</simpara>
<figure>
<title>Add a condition BRL fragment with the embedded guided rules designer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-condition-BRL.png"/>
</imageobject>
<textobject><phrase>Condition BRL Fragment column for guided decision tables designer</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also select <emphasis role="strong">Free form DRL</emphasis> from the list of condition options to define the condition BRL fragment without the embedded guided rules designer.</simpara>
<figure>
<title>Add a condition BRL fragment with free form DRL</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-condition-BRL-free.png" contentwidth="with free form DRL option"/>
</imageobject>
<textobject><phrase>Condition BRL Fragment column for guided decision tables designer</phrase></textobject>
</mediaobject>
</figure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-condition-BRL-free-02.png" contentwidth="with free form DRL field"/>
</imageobject>
<textobject><phrase>Condition BRL Fragment column for guided decision tables designer</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<title>Template keys</title>
<simpara>When you add a field for a condition BRL fragment, one of the value options is <emphasis role="strong">Template key</emphasis> (as opposed to <emphasis role="strong">Literal</emphasis> or <emphasis role="strong">Formula</emphasis>). Template keys are placeholder variables that are interchanged with a specified value when the guided decision table is generated, and form separate columns in the table for each template key value specified. You can specify the default value of Template key in the <emphasis role="strong">Value options</emphasis> page. While Literal and Formula values are static in a decision table, Template key values can be modified as needed.</simpara>
<simpara>In the embedded guided rules designer, you can add a template key value to a field by selecting the <emphasis role="strong">Template key</emphasis> field option and entering the value in the editor in the format <literal>$key</literal>. For example, <literal>$age</literal> creates an <literal>$age</literal> column in the decision table.</simpara>
<simpara>In free form DRL, you can add a template key value to facts in the format <literal>@{key}</literal>. For example, <literal>Person( age &gt; @{age} )</literal> creates an <literal>$age</literal> column in the decision table.</simpara>
<simpara>The data type is String for new columns added using template keys.</simpara>
</note>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rule Modeller:</emphasis> Define the condition BRL fragment ("WHEN" portion) for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-metadata-con">
<title>"Add a Metadata column"</title>
<simpara>With this column option, you can define a metadata element as a column in your decision table. Each column represents the normal metadata annotation in DRL rules. By default, the metadata column is hidden. To display the column, click <emphasis role="strong">Edit Columns</emphasis> in the guided decision tables designer and clear the <emphasis role="strong">Hide column</emphasis> check box.</simpara>
<formalpara>
<title>Required column parameter</title>
<para>The following parameter is required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Metadata:</emphasis> Enter the name of the metadata item in Java variable form (that is, it cannot start with a number or contain spaces or special characters).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-action-BRL-con">
<title>"Add an Action BRL fragment"</title>
<simpara>A Business Rule Language (BRL) fragment is a section of a rule created using the guided rules designer. The <link linkend="guided-decision-tables-columns-condition-BRL-con">condition BRL fragment</link> is the "WHEN" portion of the rule, and the action BRL fragment is the "THEN" portion of the rule. With this column option you can define an action BRL fragment to be used in the right ("THEN") side of a rule. Simpler column types can refer to Facts and Fact fields bound in the BRL fragment and vice-versa.</simpara>
<simpara>The following example is an action BRL fragment for a loan application:</simpara>
<figure>
<title>Add an action BRL fragment with the embedded guided rules designer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-action-BRL.png"/>
</imageobject>
<textobject><phrase>Action BRL Fragment in the guided decision tables designer</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can also select <emphasis role="strong">Add free form DRL</emphasis> from the list of action options to define the action BRL fragment without the embedded guided rules designer.</simpara>
<figure>
<title>Add an action BRL fragment with free form DRL</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-action-BRL-free.png" contentwidth="with free form DRL option"/>
</imageobject>
<textobject><phrase>Action BRL Fragment column for guided decision tables designer</phrase></textobject>
</mediaobject>
</figure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-action-BRL-free-02.png" contentwidth="with free form DRL field"/>
</imageobject>
<textobject><phrase>Action BRL Fragment column for guided decision tables designer</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<title>Template keys</title>
<simpara>When you add a field for an action BRL fragment, one of the value options is <emphasis role="strong">Template key</emphasis> (as opposed to <emphasis role="strong">Literal</emphasis> or <emphasis role="strong">Formula</emphasis>). Template keys are placeholder variables that are interchanged with a specified value when the guided decision table is generated, and form separate columns in the table for each template key value specified. You can specify the default value of Template key in the <emphasis role="strong">Value options</emphasis> page. While Literal and Formula values are static in a decision table, Template key values can be modified as needed.</simpara>
<simpara>In the embedded guided rules designer, you can add a template key value to a field by selecting the <emphasis role="strong">Template key</emphasis> field option and entering the value in the editor in the format <literal>$key</literal>. For example, <literal>$age</literal> creates an <literal>$age</literal> column in the decision table.</simpara>
<simpara>In free form DRL, you can add a template key value to facts in the format <literal>@{key}</literal>. For example, <literal>Person( age &gt; @{age} )</literal> creates an <literal>$age</literal> column in the decision table.</simpara>
<simpara>The data type is String for new columns added using template keys.</simpara>
</note>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rule Modeller:</emphasis> Define the action BRL fragment ("THEN" portion) for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-attribute-con">
<title>"Add an Attribute column"</title>
<simpara>With this column option, you can add one or more attribute columns representing any of the DRL rule attributes, such as Saliance, Enabled, Date-Effective, and others.</simpara>
<simpara>For example, the following guided decision table uses the <literal>salience</literal> attribute to specify rule priority and the <literal>enabled</literal> attribute to enable or disable rules for evaluation. Rules with a higher <literal>salience</literal> value are evaluated first, and rules with the <literal>enabled</literal> attribute are evaluated only if the check box is selected.</simpara>
<figure>
<title>Example rules with <literal>salience</literal> and <literal>enabled</literal> attributes to define evaluation behavior</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-attributes.png"/>
</imageobject>
<textobject><phrase>Guided decision table with `salience` and `enabled` attributes</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Example rule source with the rule attributes</title>
<para>
<screen>rule "Row 1 Pricing loans"
  salience 100
  enabled true
  when
    ...
  then
    ...
end
...
rule "Row 3 Pricing loans"
  enabled false
  when
    ...
  then
    ...
end</screen>
</para>
</formalpara>
<simpara>For descriptions of each attribute, select the attribute from the list in the wizard.</simpara>
<note>
<title>Hit policies and attributes</title>
<simpara>Note that depending on the hit policy that you have defined for the decision table, some attributes may be disabled because they are internally used by the hit policy. For example, if you have assigned the <emphasis role="strong">Resolved Hit</emphasis> policy to this table so that rows (rules) are applied according to a priority order specified in the table, then the Salience attribute would be obsolete. The reason is that the Salience attribute escalates rule priority according to a defined salience value, and that value would be overridden by the <emphasis role="strong">Resolved Hit</emphasis> policy in the table.</simpara>
</note>
<formalpara>
<title>Required Column Parameter</title>
<para>The following parameter is required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Attribute:</emphasis> Select the attribute to be applied to the column.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-delete-fact-con">
<title>"Delete an existing fact"</title>
<simpara>With this column option, you can implement an action to delete a fact that was added previously as a fact pattern in the table. When this column is created, the fact types are provided in the table cells for that column as a drop-down list, from which users can select only one option.</simpara>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-work-item-con">
<title>"Execute a Work Item"</title>
<simpara>With this column option, you can execute a work item handler, based on your predefined work item definitions in Business Central. (You can create work items in <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> → <emphasis role="strong"><emphasis>[select project]</emphasis></emphasis> → <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Work Item definition</emphasis>.)</simpara>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Work Item:</emphasis> Select from the list of your predefined work items.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-field-con">
<title>"Set the value of a field"</title>
<simpara>With this column option, you can implement an action to set the value of a field on a previously bound fact for the "THEN" portion of the rule.
You have the option to notify the decision engine of the modified values which could lead to other rules being reactivated.</simpara>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Pattern:</emphasis> Select from the list of fact patterns already used in conditions or condition BRL fragments in your table or create a new fact pattern. A fact pattern is a combination of an available data object in the package (see the note on <link linkend="required-data-objects">Required data objects</link> for details) and a model class binding that you specify. (Examples: <literal>LoanApplication [application]</literal> or <literal>IncomeSource [income]</literal> where the bracketed portion is the binding to the given fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field:</emphasis> Select a field from the previously specified fact pattern. The field options are defined in the fact file in the <emphasis role="strong">Data Objects</emphasis> panel of your project. (Examples: <literal>amount</literal> or <literal>lengthYears</literal> fields within the <literal>LoanApplication</literal> fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Value list (optional):</emphasis> Enter a list of value options, delimited by a comma and space, to limit table input data for the action ("THEN") portion of the rule. When this value list is defined, the values will be provided in the table cells for that column as a drop-down list, from which users can select only one option. (Example list: <literal>Accepted, Declined, Pending</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Default value (optional):</emphasis> Select one of the previously defined value options as the default value that will appear in the cell automatically in a new row. If the default value is not specified, the table cell will be blank by default. You can also select a default value from any previously configured data enumerations in the project, listed in the <emphasis role="strong">Enumeration Definitions</emphasis> panel of the Project Explorer. (You can create enumerations in <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> → <emphasis role="strong"><emphasis>[select project]</emphasis></emphasis> → <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Enumeration</emphasis>.)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logically insert:</emphasis> This option appears when the selected Fact Pattern is not currently used in another column in the guided decision table (see the next field description). Select this to insert the fact pattern logically into the decision engine, or clear this to insert it regularly. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts have to be retracted explicitly. After logical insertions, facts are automatically retracted when the conditions that asserted the facts in the first place are no longer true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Update engine with changes:</emphasis> This option appears when the selected Fact Pattern is already used in another column in the guided decision table. Select this to update the decision engine with the modified field values, or clear this to not update the decision engine.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="guided-decision-tables-columns-field-work-item-con">
<title>"Set the value of a field with a Work Item result"</title>
<simpara>With this column option, you can implement an action to set the value of a previously defined fact field to the value of a result of a work item handler for the "THEN" portion of the rule. The work item must define a result parameter of the same data type as a field on a bound fact in order for you to set the field to the return parameter. (You can create work items in <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> → <emphasis role="strong"><emphasis>[select project]</emphasis></emphasis> → <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Work Item definition</emphasis>.)</simpara>
<simpara>An <emphasis><link linkend="guided-decision-tables-columns-work-item-con">Execute a Work Item</link></emphasis> column must already be created in the table for this column option to be created.</simpara>
<formalpara>
<title>Required column parameters</title>
<para>The following parameters are required in the <emphasis role="strong">Add a new column</emphasis> wizard to set up this column type:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Pattern:</emphasis> Select from the list of fact patterns already used in your table or create a new fact pattern. A fact pattern is a combination of an available data object in the package (see the note on <link linkend="required-data-objects">Required data objects</link> for details) and a model class binding that you specify. (Examples: <literal>LoanApplication [application]</literal> or <literal>IncomeSource [income]</literal> where the bracketed portion is the binding to the given fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field:</emphasis> Select a field from the previously specified fact pattern. The field options are defined in the fact file in the <emphasis role="strong">Data Objects</emphasis> panel of your project. (Examples: <literal>amount</literal> or <literal>lengthYears</literal> fields within the <literal>LoanApplication</literal> fact type)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Work Item:</emphasis> Select from the list of your predefined work items. (The work item must define a result parameter of the same data type as a field on a bound fact in order for you to set the field to the return parameter.)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Header (description):</emphasis> Add header text for the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hide column:</emphasis> Select this to hide the column, or clear this to display the column.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logically insert:</emphasis> This option appears when the selected Fact Pattern is not currently used in another column in the guided decision table (see the next field description). Select this to insert the fact pattern logically into the decision engine, or clear this to insert it regularly. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts have to be retracted explicitly. After logical insertions, facts are automatically retracted when the conditions that asserted the facts in the first place are no longer true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Update engine with changes:</emphasis> This option appears when the selected Fact Pattern is already used in another column in the guided decision table. Select this to update the decision engine with the modified field values, or clear this to not update the decision engine.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="guided-decision-tables-rulename-column-view-proc">
<title>Viewing Rule Name column in guided decision tables</title>
<simpara>You can view the <emphasis role="strong">Rule Name</emphasis> column in the guided decision table if needed.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided decision tables designer, click <emphasis role="strong">Columns</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Show rule name column</emphasis> check box.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Finish</emphasis> to save.</simpara>
</listitem>
</orderedlist>
<simpara>The default rule name format is <literal>Row (row_number)(table_name)</literal>. The <emphasis role="strong">Source</emphasis> contains the default value if you do not specify a rule name. In the guided decision table, you can add a rule name in the <emphasis role="strong">Rule Name</emphasis> column and override the default value.</simpara>
</chapter>
<chapter xml:id="guided-decision-tables-columns-edit-proc">
<title>Editing or deleting columns in guided decision tables</title>
<simpara>You can edit or delete the columns you have created at any time in the guided decision tables designer.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided decision tables designer, click <emphasis role="strong">Columns</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Expand the appropriate section and click <emphasis role="strong">Edit</emphasis> or <emphasis role="strong">Delete</emphasis> next to the column name.</simpara>
<figure>
<title>Edit or delete columns</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-columns-edit.png"/>
</imageobject>
<textobject><phrase>Edit or delete columns in the guided decision tables designer.</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>A condition column cannot be deleted if an existing action column uses the same pattern-matching parameters as the condition column.</simpara>
</note>
</listitem>
<listitem>
<simpara>After any column changes, click <emphasis role="strong">Finish</emphasis> in the wizard to save.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="guided-decision-tables-rows-create-proc">
<title>Adding rows and defining rules in guided decision tables</title>
<simpara>After you have created your columns in the guided decision table, you can add rows and define rules within the guided decision tables designer.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Columns for the guided decision table have been added as described in <xref linkend="guided-decision-tables-columns-create-proc"/>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided decision tables designer, click <emphasis role="strong">Insert</emphasis> → <emphasis role="strong">Append row</emphasis> or one of the <emphasis role="strong">Insert row</emphasis> options. (You can also click <emphasis role="strong">Insert column</emphasis> to open the column wizard and define a new column.)</simpara>
<figure>
<title>Add Rows</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-rows-add.png"/>
</imageobject>
<textobject><phrase>Add rows in the guided decision tables designer</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Double-click each cell and enter data. For cells with specified values, select from the cell drop-down options.</simpara>
<figure>
<title>Enter input data in each cell</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-rows-add_02.png"/>
</imageobject>
<textobject><phrase>Enter data in individual cells</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>After you define all rows of data in the guided decision table, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the guided decision tables designer to validate the table. If the table validation fails, address any problems described in the error message, review all components in the table, and try again to validate the table until the table passes.</simpara>
<note>
<simpara>Although guided decision tables have real-time verification and validation, you should still manually validate the completed decision table to ensure optimal results.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the table designer to save your changes.</simpara>
<simpara>After you define your guided decision table contents, in the upper-right corner of the guided decision tables designer, you can use the search bar if needed to search for text that appears in your guided decision table. The search feature is especially helpful in complex guided decision tables with many values:</simpara>
<figure>
<title>Search guided decision table contents</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-search.png"/>
</imageobject>
<textobject><phrase>Search guided decision table contents</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="enumerations-define-proc_guided-decision-tables">
<title>Defining enumerations for drop-down lists in rule assets</title>
<simpara>Enumeration definitions in Business Central determine the possible values of fields for conditions or actions in guided rules, guided rule templates, and guided decision tables. An enumeration definition contains a <literal>fact.field</literal> mapping to a list of supported values that are displayed as a drop-down list in the relevant field of a rule asset. When a user selects a field that is based on the same fact and field as the enumeration definition, the drop-down list of defined values is displayed.</simpara>
<simpara>You can define enumerations in Business Central or in the DRL source for your Red Hat Decision Manager project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Enumeration</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Enumeration</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects and relevant rule assets have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the enumeration.</simpara>
<simpara>The new enumeration is now listed in the <emphasis role="strong">Enumeration Definitions</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> tab of the enumerations designer, click <emphasis role="strong">Add enum</emphasis> and define the following values for the enumeration:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Fact</emphasis>: Specify an existing data object within the same package of your project with which you want to associate this enumeration. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to view the available data objects, or create the relevant data object as a new asset if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field</emphasis>: Specify an existing field identifier that you defined as part of the data object that you selected for the <emphasis role="strong">Fact</emphasis>. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to select the relevant data object and view the list of available <emphasis role="strong">Identifier</emphasis> options. You can create the relevant identifier for the data object if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Context</emphasis>: Specify a list of values in the format <literal>['string1','string2','string3']</literal> or <literal>[integer1,integer2,integer3]</literal> that you want to map to the <emphasis role="strong">Fact</emphasis> and <emphasis role="strong">Field</emphasis> definitions. These values will be displayed as a drop-down list for the relevant field of the rule asset.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following enumeration defines the drop-down values for applicant credit rating in a loan application decision service:</simpara>
<figure>
<title>Example enumeration for applicant credit rating in Business Central</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumConfig.png" align="center"/>
</imageobject>
<textobject><phrase>EnumConfig</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Example enumeration for applicant credit rating in the DRL source</title>
<para>
<screen>'Applicant.creditRating' : ['AA', 'OK', 'Sub prime']</screen>
</para>
</formalpara>
<simpara>In this example, for any guided rule, guided rule template, or guided decision table that is in the same package of the project and that uses the <literal>Applicant</literal> data object and the <literal>creditRating</literal> field, the configured values are available as drop-down options:</simpara>
<figure>
<title>Example enumeration drop-down options in a guided rule or guided rule template</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDown.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDown</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Example enumeration drop-down options in a guided decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDownGDT.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDownGDT</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<section xml:id="enumerations-advanced-ref_guided-decision-tables">
<title>Advanced enumeration options for rule assets</title>
<simpara>For advanced use cases with enumeration definitions in your Red Hat Decision Manager project, consider the following extended options for defining enumerations:</simpara>
<variablelist>
<varlistentry>
<term>Mapping between DRL values and values in Business Central</term>
<listitem>
<simpara>If you want the enumeration values to appear differently or more completely in the Business Central interface than they appear in the DRL source, use a mapping in the format <literal>'fact.field' : ['sourceValue1=UIValue1','sourceValue2=UIValue2', …​ ]</literal> for your enumeration definition values.</simpara>
<simpara>For example, in the following enumeration definition for loan status, the options <literal>A</literal> or <literal>D</literal> are used in the DRL file but the options <literal>Approved</literal> or <literal>Declined</literal> are displayed in Business Central:</simpara>
<screen>'Loan.status' : ['A=Approved','D=Declined']</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>Enumeration value dependencies</term>
<listitem>
<simpara>If you want the selected value in one drop-down list to determine the available options in a subsequent drop-down list, use the format <literal>'fact.fieldB[fieldA=value1]' : ['value2', 'value3', …​ ]</literal> for your enumeration definition.</simpara>
<simpara>For example, in the following enumeration definition for insurance policies, the <literal>policyType</literal> field accepts the values <literal>Home</literal> or <literal>Car</literal>. The type of policy that the user selects determines the policy <literal>coverage</literal> field options that are then available:</simpara>
<screen>'Insurance.policyType' : ['Home', 'Car']
'Insurance.coverage[policyType=Home]' : ['property', 'liability']
'Insurance.coverage[policyType=Car]' : ['collision', 'fullCoverage']</screen>
<note>
<simpara>Enumeration dependencies are not applied across rule conditions and actions. For example, in this insurance policy use case, the selected policy in the rule condition does not determine the available coverage options in the rule actions, if applicable.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term>External data sources in enumerations</term>
<listitem>
<simpara>If you want to retrieve a list of enumeration values from an external data source instead of defining the values directly in the enumeration definition, on the class path of your project, add a helper class that returns a <literal>java.util.List</literal> list of strings. In the enumeration definition, instead of specifying a list of values, identify the helper class that you configured to retrieve the values externally.</simpara>
<simpara>For example, in the following enumeration definition for loan applicant region, instead of defining applicant regions explicitly in the format <literal>'Applicant.region' : ['country1', 'country2', …​ ]</literal>, the enumeration uses a helper class that returns the list of values defined externally:</simpara>
<screen>'Applicant.region' : (new com.mycompany.DataHelper()).getListOfRegions()</screen>
<simpara>In this example, a <literal>DataHelper</literal> class contains a <literal>getListOfRegions()</literal> method that returns a list of strings. The enumerations are loaded in the drop-down list for the relevant field in the rule asset.</simpara>
<simpara>You can also load dependent enumeration definitions dynamically from a helper class by identifying the dependent field as usual and enclosing the call to the helper class within quotation marks:</simpara>
<screen>'Applicant.region[countryCode]' : '(new com.mycompany.DataHelper()).getListOfRegions("@{countryCode}")'</screen>
<simpara>If you want to load all enumeration data entirely from an external data source, such as a relational database, you can implement a Java class that returns a <literal>Map&lt;String, List&lt;String&gt;&gt;</literal> map. The key of the map is the <literal>fact.field</literal> mapping and the value is a <literal>java.util.List&lt;String&gt;</literal> list of values.</simpara>
<simpara>For example, the following Java class defines loan applicant regions for the related enumeration:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SampleDataSource {

  public Map&lt;String, List&lt;String&gt;&gt; loadData() {
    Map data = new HashMap();

    List d = new ArrayList();
    d.add("AU");
    d.add("DE");
    d.add("ES");
    d.add("UK");
    d.add("US");
    ...
    data.put("Applicant.region", d);

    return data;
  }

}</programlisting>
<simpara>The following enumeration definition correlates to this example Java class. The enumeration contains no references to fact or field names because they are defined in the Java class:</simpara>
<screen>=(new SampleDataSource()).loadData()</screen>
<simpara>The <literal>=</literal> operator enables Business Central to load all enumeration data from the helper class. The helper methods are statically evaluated when the enumeration definition is requested for use in an editor.</simpara>
<note>
<simpara>Defining an enumeration without a fact and field definition is currently not supported in Business Central. To define the enumeration for the associated Java class in this way, use the DRL source in your Red Hat Decision Manager project.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
</section>
</chapter>
<chapter xml:id="guided-decision-tables-validation-con">
<title>Real-time verification and validation of guided decision tables</title>
<simpara>Business Central provides a real-time verification and validation feature for guided decision tables to ensure that your tables are complete and error free. Guided decision tables are validated after each cell change. If a problem in logic is detected, an error notification appears and describes the problem.</simpara>
<section xml:id="guided-decision-tables-errors-ref">
<title>Types of problems in guided decision tables</title>
<simpara>The validation and verification feature detects the following types of problems:</simpara>
<variablelist>
<varlistentry>
<term>Redundancy</term>
<listitem>
<simpara>Redundancy occurs when two rows in a decision table execute the same consequences for the same set of facts.
For example, two rows checking a client’s birthday and providing a birthday discount may result in double discount.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Subsumption</term>
<listitem>
<simpara>Subsumption is similar to redundancy and occurs when two rules execute the same consequences, but one executes on a subset of facts of the other. For example, consider these two rules:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>when Person age &gt; 10 then Increase Counter</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>when Person age &gt; 20 then Increase Counter</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>In this case, if a person is 15 years old, only one rule fires and if a person is 20 years old, both rules fire.
Such cases cause similar trouble during runtime as redundancy.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Conflicts</term>
<listitem>
<simpara>A conflicting situation occurs when two similar conditions have different consequences.
Conflicts can occur between two rows (rules) or two cells in a decision table.</simpara>
<simpara>The following example illustrates conflict between two rows in a decision table:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>when Deposit &gt; 20000 then Approve Loan</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>when Deposit &gt; 20000 then Refuse Loan</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>In this case, there is no way to know if the loan will be approved or not.</simpara>
<simpara>The following example illustrates conflict between two cells in a decision table:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>when Age &gt; 25</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>when Age &lt; 25</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>A row with conflicting cells never executes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Broken <emphasis>Unique Hit</emphasis> Policy</term>
<listitem>
<simpara>When the <emphasis role="strong">Unique Hit</emphasis> policy is applied to a decision table, only one row at a time can be executed and each row must be unique, with no overlap of conditions being met. If more than one row is executed, then the verification report identifies the broken hit policy. For example, consider the following conditions in a table that determines eligibility for a price discount:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>when Is Student = true</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>when Is Military = true</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>If a customer is both a student and in the military, both conditions apply and break the <emphasis role="strong">Unique Hit</emphasis> policy. Rows in this type of table must therefore be created in a way that does not allow multiple rules to fire at one time. For details about hit policies, see <xref linkend="hit-policies-con"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deficiency</term>
<listitem>
<simpara>Deficiency is similar to a conflict and occurs the logic of a rule in a decision table is incomplete.
For example, consider the following two deficient rules:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>when Age &gt; 20 then Approve Loan</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>when Deposit &lt; 20000 then Refuse Loan</emphasis></simpara>
</listitem>
</itemizedlist>
<simpara>These two rules may lead to confusion for a person who is over 20 years old and has deposited less than 20000.
You can add more constraints to avoid the conflict.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Missing Columns</term>
<listitem>
<simpara>When deleted columns result in incomplete or incorrect logic, rules cannot fire properly. This is detected so that you can address the missing columns, or adjust the logic to not rely on intentionally deleted conditions or actions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Incomplete Ranges</term>
<listitem>
<simpara>Ranges of field values are incomplete if a table contains constraints against possible field values but does not define all possible values. The verification report identifies any incomplete ranges provided. For example, if your table has a check for if an application is approved, the verification report reminds you to make sure you also handle situations where the application was not approved.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="guided-decision-tables-messages-ref">
<title>Types of notifications</title>
<simpara>The verification and validation feature uses three types of notifications:</simpara>
<itemizedlist>
<listitem>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/gdtValidationVerificationIconError.png"/>
</imageobject>
<textobject><phrase>gdtValidationVerificationIconError</phrase></textobject>
</inlinemediaobject> Error: A serious problem that may lead to the guided decision table failing to work as designed at run time. Conflicts, for example, are reported as errors.</simpara>
</listitem>
<listitem>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/gdtValidationVerificationIconWarning.png"/>
</imageobject>
<textobject><phrase>gdtValidationVerificationIconWarning</phrase></textobject>
</inlinemediaobject> Warning: Likely a serious problem that may not prevent the guided decision table from working but requires attention. Subsumptions, for example, are reported as warnings.</simpara>
</listitem>
<listitem>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/gdtValidationVerificationIconInfo.png"/>
</imageobject>
<textobject><phrase>gdtValidationVerificationIconInfo</phrase></textobject>
</inlinemediaobject> Information: A moderate or minor problem that may not prevent the guided decision table from working but requires attention. Missing columns, for example, are reported as information.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Business Central verification and validation does not prevent you from saving an incorrect change.
The feature only reports issues while editing and you can still continue to overlook those and save your changes.</simpara>
</note>
</section>
<section xml:id="guided-decision-tables-validation-disable-proc">
<title>Disabling verification and validation of guided decision tables</title>
<simpara>The decision table verification and validation feature of Business Central is enabled by default. This feature helps you validate your guided decision tables, but with complex guided decision tables, this feature can hinder decision engine performance. You can disable this feature by setting the <literal>org.kie.verification.disable-dtable-realtime-verification</literal> system property value to <literal>true</literal> in your Red Hat Decision Manager distribution.</simpara>
<formalpara>
<title>Procedure</title>
<para>Navigate to <literal>~/standalone-full.xml</literal> and add the following system property:</para>
</formalpara>
<screen>&lt;property name="org.kie.verification.disable-dtable-realtime-verification" value="true"/&gt;</screen>
<simpara>For example, on Red Hat JBoss EAP, you add this system property in <literal>$EAP_HOME/standalone/configuration/standalone-full.xml</literal>.</simpara>
</section>
</chapter>
<chapter xml:id="guided-decision-tables-convert-proc">
<title>Converting a guided decision table to a spreadsheet decision table</title>
<simpara>After you define a guided decision table in Business Central, you can convert the guided decision table to an XLS spreadsheet decision table file for offline reference and file sharing. The guided decision table must be an extended entry guided decision table in order to be converted. The conversion tool does not support limited entry guided decision tables.</simpara>
<simpara>For more information about spreadsheet decision tables, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link>.</simpara>
<warning>
<simpara>Guided decision tables and spreadsheet decision tables are different table formats that support different features. Any supported features that differ between the two decision table formats (Hit policy, for example) are modified or lost when you convert one decision table format to the other.</simpara>
</warning>
<formalpara>
<title>Procedure</title>
<para>In Business Central, navigate to the guided decision table asset that you want to convert and in the upper-right toolbar of the decision tables designer, click <emphasis role="strong">Convert to XLS</emphasis>:</para>
</formalpara>
<figure>
<title>Convert an uploaded decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-decision-tables-convert.png"/>
</imageobject>
<textobject><phrase>Decision table example</phrase></textobject>
</mediaobject>
</figure>
<simpara>After the conversion, the converted decision table is then available as a spreadsheet decision table asset in your project that you can download for offline reference.</simpara>
</chapter>
<chapter xml:id="assets-executing-proc_guided-decision-tables">
<title>Executing rules</title>
<simpara>After you identify example rules or create your own rules in Business Central, you can build and deploy the associated project and execute rules locally or on KIE Server to test the rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Business Central and KIE Server are installed and running. For installation options, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right corner of the project <emphasis role="strong">Assets</emphasis> page, click <emphasis role="strong">Deploy</emphasis> to build the project and deploy it to KIE Server. If the build fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the screen.</simpara>
<simpara>For more information about project deployment options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>If the rule assets in your project are not built from an executable rule model by default, verify that the following dependency is in the <literal>pom.xml</literal> file of your project and rebuild the project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-model-compiler&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>This dependency is required for rule assets in Red Hat Decision Manager to be built from executable rule models by default. This dependency is included as part of the Red Hat Decision Manager core packaging, but depending on your Red Hat Decision Manager upgrade history, you may need to manually add this dependency to enable the executable rule model behavior.</simpara>
<simpara>For more information about executable rule models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a Maven or Java project outside of Business Central, if not created already, that you can use for executing rules locally or that you can use as a client application for executing rules on KIE Server. The project must contain a <literal>pom.xml</literal> file and any other required components for executing the project resources.</simpara>
<simpara>For example test projects, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#drl-rules-other-con">"Other methods for creating and executing DRL rules"</link>.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>pom.xml</literal> file of your test project or client application and add the following dependencies, if not added already:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-ci</literal>: Enables your client application to load Business Central project data locally using <literal>ReleaseId</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kie-server-client</literal>: Enables your client application to interact remotely with assets on KIE Server</simpara>
</listitem>
<listitem>
<simpara><literal>slf4j</literal>: (Optional) Enables your client application to use Simple Logging Facade for Java (SLF4J) to return debug logging information after you interact with KIE Server</simpara>
</listitem>
</itemizedlist>
<simpara>Example dependencies for Red Hat Decision Manager 7.10 in a client application <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For local execution --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For remote execution on KIE Server --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For debug logging (optional) --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For available versions of these artifacts, search the group ID and artifact ID in the <link xlink:href="https://repository.jboss.org/nexus/index.html#welcome">Nexus Repository Manager</link> online.</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between Red Hat Decision Manager and the Maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the dependencies for artifacts containing model classes are defined in the client application <literal>pom.xml</literal> file exactly as they appear in the <literal>pom.xml</literal> file of the deployed project. If dependencies for model classes differ between the client application and your projects, execution errors can occur.</simpara>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>For example, the following <literal>Person</literal> class dependency appears in both the client and deployed project <literal>pom.xml</literal> files:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.sample&lt;/groupId&gt;
  &lt;artifactId&gt;Person&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you added the <literal>slf4j</literal> dependency to the client application <literal>pom.xml</literal> file for debug logging, create a <literal>simplelogger.properties</literal> file on the relevant classpath (for example, in <literal>src/main/resources/META-INF</literal> in Maven) with the following content:</simpara>
<programlisting language="java" linenumbering="unnumbered">org.slf4j.simpleLogger.defaultLogLevel=debug</programlisting>
</listitem>
<listitem>
<simpara>In your client application, create a <literal>.java</literal> main class containing the necessary imports and a <literal>main()</literal> method to load the KIE base, insert facts, and execute the rules.</simpara>
<simpara>For example, a <literal>Person</literal> object in a project contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person. The following <literal>Wage</literal> rule in a project calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
<simpara>To test this rule locally outside of KIE Server (if needed), configure the <literal>.java</literal> class to import KIE services, a KIE container, and a KIE session, and then use the <literal>main()</literal> method to fire all rules against a defined fact model:</simpara>
<formalpara>
<title>Executing rules locally</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.builder.ReleaseId;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.drools.compiler.kproject.ReleaseIdImpl;

public class RulesTest {

  public static final void main(String[] args) {
    try {
      // Identify the project in the local repository:
      ReleaseId rid = new ReleaseIdImpl("com.myspace", "MyProject", "1.0.0");

      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.newKieContainer(rid);
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
<simpara>To test this rule on KIE Server, configure the <literal>.java</literal> class with the imports and rule execution information similarly to the local example, and additionally specify KIE services configuration and KIE services client details:</simpara>
<formalpara>
<title>Executing rules on KIE Server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.kie.api.command.BatchExecutionCommand;
import org.kie.api.command.Command;
import org.kie.api.KieServices;
import org.kie.api.runtime.ExecutionResults;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.RuleServicesClient;

import com.sample.Person;

public class RulesTest {

  private static final String containerName = "testProject";
  private static final String sessionName = "myStatelessSession";

  public static final void main(String[] args) {
    try {
      // Define KIE services configuration and client:
      Set&lt;Class&lt;?&gt;&gt; allClasses = new HashSet&lt;Class&lt;?&gt;&gt;();
      allClasses.add(Person.class);
      String serverUrl = "http://$HOST:$PORT/kie-server/services/rest/server";
      String username = "$USERNAME";
      String password = "$PASSWORD";
      KieServicesConfiguration config =
        KieServicesFactory.newRestConfiguration(serverUrl,
                                                username,
                                                password);
      config.setMarshallingFormat(MarshallingFormat.JAXB);
      config.addExtraClasses(allClasses);
      KieServicesClient kieServicesClient =
        KieServicesFactory.newKieServicesClient(config);

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert Person into the session:
      KieCommands kieCommands = KieServices.Factory.get().getCommands();
      List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();
      commandList.add(kieCommands.newInsert(p, "personReturnId"));

      // Fire all rules:
      commandList.add(kieCommands.newFireAllRules("numberOfFiredRules"));
      BatchExecutionCommand batch = kieCommands.newBatchExecution(commandList, sessionName);

      // Use rule services client to send request:
      RuleServicesClient ruleClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
      ServiceResponse&lt;ExecutionResults&gt; executeResponse = ruleClient.executeCommandsWithResults(containerName, batch);
      System.out.println("number of fired rules:" + executeResponse.getResult().getValue("numberOfFiredRules"));
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the configured <literal>.java</literal> class from your project directory. You can run the file in your development platform
(such as Red Hat CodeReady Studio)
or in the command line.</simpara>
<simpara>Example Maven execution (within project directory):</simpara>
<screen>mvn clean install exec:java -Dexec.mainClass="com.sample.app.RulesTest"</screen>
<simpara>Example Java execution (within project directory)</simpara>
<screen>javac -classpath "./$DEPENDENCIES/*:." RulesTest.java
java -classpath "./$DEPENDENCIES/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rule execution status in the command line and in the server log. If any rules do not execute as expected, review the configured rules in the project and the main class configuration to validate the data provided.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="next_steps_2" remap="_next_steps_2">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-test-scenarios"><emphasis>Testing a decision service using test scenarios</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-decision-tables">
<title>Designing a decision service using spreadsheet decision tables</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can define business rules in a tabular format in spreadsheet decision tables and then upload the spreadsheets to your project in Business Central. These rules are compiled into Drools Rule Language (DRL) and form the core of the decision service for your project.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the decision tables have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_decision-tables">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="decision-tables-con_decision-tables">
<title>Spreadsheet decision tables</title>
<simpara>Spreadsheet decision tables are XLS or XLSX spreadsheets that contain business rules defined in a tabular format. You can include spreadsheet decision tables with standalone Red Hat Decision Manager projects or upload them to projects in Business Central. Each row in a decision table is a rule, and each column is a condition, an action, or another rule attribute. After you create and upload your spreadsheet decision tables, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>All data objects related to a spreadsheet decision table must be in the same project package as the spreadsheet decision table. Assets in the same package are imported by default. Existing assets in other packages can be imported with the decision table.</simpara>
</chapter>
<chapter xml:id="data-objects-con_decision-tables">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_decision-tables">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="decision-tables-use-case-con">
<title>Decision table use case</title>
<simpara>An online shopping site lists the shipping charges for ordered items. The site provides free shipping under the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>The number of items ordered is 4 or more and the checkout total is $300 or more.</simpara>
</listitem>
<listitem>
<simpara>Standard shipping is selected (4 or 5 business days from the date of purchase).</simpara>
</listitem>
</itemizedlist>
<simpara>The following are the shipping rates under these conditions:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>For orders less than $300</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Number of items</entry>
<entry align="left" valign="top">Delivery day</entry>
<entry align="left" valign="top">Shipping charge in USD, N = Number of items</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>3 or fewer</simpara></entry>
<entry align="left" valign="top"><simpara>Next day</simpara><simpara>2nd day</simpara><simpara>Standard</simpara></entry>
<entry align="left" valign="top"><simpara>35</simpara><simpara>15</simpara><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 or more</simpara></entry>
<entry align="left" valign="top"><simpara>Next day</simpara><simpara>2nd day</simpara><simpara>Standard</simpara></entry>
<entry align="left" valign="top"><simpara>N*7.50</simpara><simpara>N*3.50</simpara><simpara>N*2.50</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>For orders more than $300</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Number of items</entry>
<entry align="left" valign="top">Delivery day</entry>
<entry align="left" valign="top">Shipping charge in USD, N = Number of items</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>3 or fewer</simpara></entry>
<entry align="left" valign="top"><simpara>Next day</simpara><simpara>2nd day</simpara><simpara>Standard</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara><simpara>10</simpara><simpara>N*1.50</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4 or more</simpara></entry>
<entry align="left" valign="top"><simpara>Next day</simpara><simpara>2nd day</simpara><simpara>Standard</simpara></entry>
<entry align="left" valign="top"><simpara>N*5</simpara><simpara>N*2</simpara><simpara>FREE</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>These conditions and rates are shown in the following example spreadsheet decision table:</simpara>
<figure>
<title>Decision table for shipping charges</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/decision-table-example-02.png"/>
</imageobject>
<textobject><phrase>Decision table example</phrase></textobject>
</mediaobject>
</figure>
<simpara>In order for a decision table to be uploaded in Business Central, the table must comply with certain structure and syntax requirements, within an XLS or XLSX spreadsheet, as shown in this example. For more information, see <xref linkend="decision-tables-defining-proc"/>.</simpara>
</chapter>
<chapter xml:id="decision-tables-defining-proc">
<title>Defining spreadsheet decision tables</title>
<simpara>Spreadsheet decision tables (XLS or XLSX) require two key areas that define rule data: a <literal>RuleSet</literal> area and a <literal>RuleTable</literal> area. The <literal>RuleSet</literal> area of the spreadsheet defines elements that you want to apply globally to all rules in the same package (not only the spreadsheet), such as a rule set name or universal rule attributes. The <literal>RuleTable</literal> area defines the actual rules (rows) and the conditions, actions, and other rule attributes (columns) that constitute that rule table within the specified rule set. A spreadsheet of decision tables can contain multiple <literal>RuleTable</literal> areas, but only one <literal>RuleSet</literal> area.</simpara>
<important>
<simpara>You should typically upload only one spreadsheet of decision tables, containing all necessary <literal>RuleTable</literal> definitions, per rule package in Business Central. You can upload separate decision table spreadsheets for separate packages, but uploading multiple spreadsheets in the same package can cause compilation errors from conflicting <literal>RuleSet</literal> or <literal>RuleTable</literal> attributes and is therefore not recommended.</simpara>
</important>
<simpara>Refer to the following sample spreadsheet as you define your decision table:</simpara>
<figure>
<title>Sample spreadsheet decision table for shipping charges</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/decision-table-example-02.png"/>
</imageobject>
<textobject><phrase>Decision table example</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a new XLS or XLSX spreadsheet, go to the second or third column and label a cell <literal>RuleSet</literal> (row 1 in example). Reserve the column or columns to the left for descriptive metadata (optional).</simpara>
</listitem>
<listitem>
<simpara>In the next cell to the right, enter a name for the <literal>RuleSet</literal>. This named rule set will contain all <literal>RuleTable</literal> rules defined in the rule package.</simpara>
</listitem>
<listitem>
<simpara>Under the <literal>RuleSet</literal> cell, define any rule attributes (one per cell) that you want to apply globally to all rule tables in the package. Specify attribute values in the cells to the right. For example, you can enter an <literal>Import</literal> label and in the cell to the right, specify relevant data objects from other packages that you want to import into the package for the decision table (in the format <literal>package.name.object.name</literal>). For supported cell labels and values, see <xref linkend="decision-tables-rule-set-entries-ref"/>.</simpara>
</listitem>
<listitem>
<simpara>Below the <literal>RuleSet</literal> area and in the same column as the <literal>RuleSet</literal> cell, skip a row and label a new cell <literal>RuleTable</literal> (row 7 in example) and enter a table name in the same cell. The name is used as the initial part of the name for all rules derived from this rule table, with the row number appended for distinction. You can override this automatic naming by inserting a <literal>NAME</literal> attribute column.</simpara>
</listitem>
<listitem>
<simpara>Use the next four rows to define the following elements as needed (rows 8-11 in example):</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rule attributes:</emphasis> Conditions, actions, or other attributes. For supported cell labels and values, see <xref linkend="decision-tables-rule-table-entries-ref"/>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Object types:</emphasis> The data objects to which the rule attributes apply. If the same object type applies to multiple columns, merge the object cells into one cell across multiple columns (as shown in the sample decision table), instead of repeating the object type in multiple cells. When an object type is merged, all columns below the merged range will be combined into one set of constraints within a single pattern for matching a single fact at a time. When an object is repeated in separate columns, the separate columns can create different patterns, potentially matching different or identical facts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Constraints:</emphasis> Constraints on the object types.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Column label:</emphasis> (Optional) Any descriptive label for the column, as a visual aid. Leave blank if unused.</simpara>
<note>
<simpara>As an alternative to populating both the object type and constraint cells, you can leave the object type cell or cells empty and enter the full expression in the corresponding constraint cell or cells. For example, instead of <literal>Order</literal> as the object type and <literal>itemsCount &gt; $1</literal> as a constraint (separate cells), you can leave the object type cell empty and enter <literal>Order( itemsCount &gt; $1 )</literal> in the constraint cell, and then do the same for other constraint cells.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After you have defined all necessary rule attributes (columns), enter values for each column as needed, row by row, to generate rules (rows 12-17 in example). Cells with no data are ignored (such as when a condition or action does not apply).</simpara>
<simpara>If you need to add more rule tables to this decision table spreadsheet, skip a row after the last rule in the previous table, label another <literal>RuleTable</literal> cell in the same column as the previous <literal>RuleTable</literal> and  <literal>RuleSet</literal> cells, and create the new table following the same steps in this section (rows 19-29 in example).</simpara>
</listitem>
<listitem>
<simpara>Save your XLS or XLSX spreadsheet to finish.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>By default, only the first worksheet in a spreadsheet workbook is processed as a decision table when you upload the spreadsheet in Business Central. Each <literal>RuleSet</literal> name combined with the <literal>RuleTable</literal> name must be unique across all decision table files in the same package.</simpara>
<simpara>If you want to process multiple worksheet decision tables, then create a <literal>.properties</literal> file with the same name as the spreadsheet workbook. The <literal>.properties</literal> file must contain a property sheet with comma-separated values (CSV) for the names of the worksheets, for example:</simpara>
<screen>sheets=Sheet1,Sheet2</screen>
</note>
<simpara>After you upload the decision table in Business Central, the rules are rendered as DRL rules like the following example, from the sample spreadsheet:</simpara>
<screen>//row 12
rule "Basic_12"
salience 10
  when
    $order : Order( itemsCount &gt; 0, itemsCount &lt;= 3, deliverInDays == 1 )
  then
    insert( new Charge( 35 ) );
end</screen>
<note>
<title>Enabling white space used in cell values</title>
<simpara>By default, any white space before or after values in decision table cells is removed before the decision table is processed by the decision engine. To retain white space that you use intentionally before or after values in cells, set the <literal>drools.trimCellsInDTable</literal> system property to <literal>false</literal> in your Red Hat Decision Manager distribution.</simpara>
<simpara>For example, if you use Red Hat Decision Manager with Red Hat JBoss EAP, add the following system property to your <literal>$EAP_HOME/standalone/configuration/standalone-full.xml</literal> file:</simpara>
<screen>&lt;property name="drools.trimCellsInDTable" value="false"/&gt;</screen>
<simpara>If you use the decision engine embedded in your Java application, add the system property with the following command:</simpara>
<screen>java -jar yourApplication.jar -Ddrools.trimCellsInDTable=false</screen>
</note>
<section xml:id="decision-tables-rule-set-entries-ref">
<title>RuleSet definitions</title>
<simpara>Entries in the <literal>RuleSet</literal> area of a decision table define DRL constructs and rule attributes that you want to apply to all rules in a package (not only in the spreadsheet). Entries must be in a vertically stacked sequence of cell pairs, where the first cell contains a label and the cell to the right contains the value. A decision table spreadsheet can have only one <literal>RuleSet</literal> area.</simpara>
<simpara>The following table lists the supported labels and values for <literal>RuleSet</literal> definitions:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported <literal>RuleSet</literal> definitions</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="30*"/>
<thead>
<row>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>RuleSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The package name for the generated DRL file. Optional, the default is <literal>rule_table</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be the first entry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Sequential</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> or <literal>false</literal>. If <literal>true</literal>, then salience is used to ensure that rules fire from the top down.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. If omitted, no firing order is imposed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SequentialMaxPriority</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Integer numeric value</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. In sequential mode, this option is used to set the start value of the salience. If omitted, the default value is 65535.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SequentialMinPriority</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Integer numeric value</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. In sequential mode, this option is used to check if this minimum salience value is not violated. If omitted, the default value is 0.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>EscapeQuotes</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal> or <literal>false</literal>. If <literal>true</literal>, then quotation marks are escaped so that they appear literally in the DRL.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. If omitted, quotation marks are escaped.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Import</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A comma-separated list of Java classes to import from another package.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, may be used repeatedly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Variables</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Declarations of DRL globals (a type followed by a variable name). Multiple global definitions must be separated by commas.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, may be used repeatedly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Functions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>One or more function definitions, according to DRL syntax.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, may be used repeatedly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Queries</literal></simpara></entry>
<entry align="left" valign="top"><simpara>One or more query definitions, according to DRL syntax.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, may be used repeatedly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Declare</literal></simpara></entry>
<entry align="left" valign="top"><simpara>One or more declarative types, according to DRL syntax.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, may be used repeatedly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Unit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The rule units that the rules generated from this decision table belong to.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. If omitted, the rules do not belong to any unit.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Dialect</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>java</literal> or <literal>mvel</literal>. The dialect used in the actions of the decision table.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, at most once. If omitted, <literal>java</literal> is imposed.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<warning>
<simpara>In some cases, Microsoft Office, LibreOffice, and OpenOffice might encode a double quotation mark differently, causing a compilation error. For example, <literal>“A”</literal> will fail, but <literal>"A"</literal> will pass.</simpara>
</warning>
</section>
<section xml:id="decision-tables-rule-table-entries-ref">
<title>RuleTable definitions</title>
<simpara>Entries in the <literal>RuleTable</literal> area of a decision table define conditions, actions, and other rule attributes for the rules in that rule table. A spreadsheet of decision tables can contain multiple <literal>RuleTable</literal> areas.</simpara>
<simpara>The following table lists the supported labels (column headers) and values for <literal>RuleTable</literal> definitions. For column headers, you can use either the given labels or any custom labels that begin with the letters listed in the table.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported <literal>RuleTable</literal> definitions</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="35*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Or custom label that begins with</entry>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>NAME</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N</simpara></entry>
<entry align="left" valign="top"><simpara>Provides the name for the rule generated from that row. The default is constructed from the text following the <literal>RuleTable</literal> tag and the row number.</simpara></entry>
<entry align="left" valign="top"><simpara>At most one column.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DESCRIPTION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I</simpara></entry>
<entry align="left" valign="top"><simpara>Results in a comment within the generated rule.</simpara></entry>
<entry align="left" valign="top"><simpara>At most one column.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CONDITION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>C</simpara></entry>
<entry align="left" valign="top"><simpara>Code snippet and interpolated values for constructing a constraint within a pattern in a condition.</simpara></entry>
<entry align="left" valign="top"><simpara>At least one per rule table.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ACTION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A</simpara></entry>
<entry align="left" valign="top"><simpara>Code snippet and interpolated values for constructing an action for the consequence of the rule.</simpara></entry>
<entry align="left" valign="top"><simpara>At least one per rule table.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>METADATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>@</simpara></entry>
<entry align="left" valign="top"><simpara>Code snippet and interpolated values for constructing a metadata entry for the rule.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, any number of columns.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following sections provide more details about how condition, action, and metadata columns use cell data:</simpara>
<variablelist>
<varlistentry>
<term>Conditions</term>
<listitem>
<simpara>For columns headed <literal>CONDITION</literal>, the cells in consecutive lines result in a conditional element:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">First cell:</emphasis> Text in the first cell below <literal>CONDITION</literal> develops into a pattern for the rule condition, and uses the snippet in the next line as a constraint. If the cell is merged with one or more neighboring cells, a single pattern with multiple constraints is formed. All constraints are combined into a parenthesized list and appended to the text in this cell.</simpara>
<simpara>If this cell is empty, the code snippet in the cell below it must result in a valid conditional element on its own. For example, instead of <literal>Order</literal> as the object type and <literal>itemsCount &gt; $1</literal> as a constraint (separate cells), you can leave the object type cell empty and enter <literal>Order( itemsCount &gt; $1 )</literal> in the constraint cell, and then do the same for any other constraint cells.</simpara>
<simpara>To include a pattern without constraints, you can write the pattern in front of the text of another pattern, with or without an empty pair of parentheses. You can also append a <literal>from</literal> clause to the pattern.</simpara>
<simpara>If the pattern ends with <literal>eval</literal>, code snippets produce boolean expressions for inclusion into a pair of parentheses after <literal>eval</literal>.</simpara>
<simpara>You can terminate the pattern with <literal>@watch</literal> annotation, which is used to customize the properties that the pattern is reactive on.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Second cell:</emphasis> Text in the second cell below <literal>CONDITION</literal> is processed as a constraint on the object reference in the first cell. The code snippet in this cell is modified by interpolating values from cells farther down in the column. If you want to create a constraint consisting of a comparison using <literal>==</literal> with the value from the cells below, then the field selector alone is sufficient. If you use the field selector alone, but you want to use the condition as it is without appending any <literal>==</literal> comparison, you must terminate the condition with the symbol <literal>?</literal>. Any other comparison operator must be specified as the last item within the snippet, and the value from the cells below is appended. For all other constraint forms, you must mark the position for including the contents of a cell with the symbol <literal>$param</literal>. Multiple insertions are possible if you use the symbols <literal>$1</literal>, <literal>$2</literal>, and so on, and a comma-separated list of values in the cells below. However, do not separate <literal>$1</literal>, <literal>$2</literal>, and so on, by commas, or the table will fail to process.</simpara>
<simpara>To expand a text according to the pattern <literal>forall($delimiter){$snippet}</literal>, repeat the <literal>$snippet</literal> once for each of the values of the comma-separated list in each of the cells below, insert the value in place of the symbol <literal>$</literal>, and join these expansions by the given <literal>$delimiter</literal>. Note that the <literal>forall</literal> construct may be surrounded by other text.</simpara>
<simpara>If the first cell contains an object, the completed code snippet is added to the conditional element from that cell. A pair of parentheses is provided automatically, as well as a separating comma if multiple constraints are added to a pattern in a merged cell. If the first cell is empty, the code snippet in this cell must result in a valid conditional element on its own. For example, instead of <literal>Order</literal> as the object type and <literal>itemsCount &gt; $1</literal> as a constraint (separate cells), you can leave the object type cell empty and enter <literal>Order( itemsCount &gt; $1 )</literal> in the constraint cell, and then do the same for any other constraint cells.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Third cell:</emphasis> Text in the third cell below <literal>CONDITION</literal> is a descriptive label that you define for the column, as a visual aid.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fourth cell:</emphasis> From the fourth row on, non-blank entries provide data for interpolation. A blank cell omits the condition or constraint for this rule.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Actions</term>
<listitem>
<simpara>For columns headed <literal>ACTION</literal>, the cells in consecutive lines result in an action statement:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">First cell:</emphasis> Text in the first cell below <literal>ACTION</literal> is optional. If present, the text is interpreted as an object reference.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Second cell:</emphasis> Text in the second cell below <literal>ACTION</literal> is a code snippet that is modified by interpolating values from cells farther down in the column. For a singular insertion, mark the position for including the contents of a cell with the symbol <literal>$param</literal>. Multiple insertions are possible if you use the symbols <literal>$1</literal>, <literal>$2</literal>, and so on, and a comma-separated list of values in the cells below. However, do not separate <literal>$1</literal>, <literal>$2</literal>, and so on, by commas, or the table will fail to process.</simpara>
<simpara>A text without any marker symbols can execute a method call without interpolation. In this case, use any non-blank entry in a row below the cell to include the statement. The <literal>forall</literal> construct is supported.</simpara>
<simpara>If the first cell contains an object, then the cell text (followed by a period), the text in the second cell, and a terminating semicolon are strung together, resulting in a method call that is added as an action statement for the consequence. If the first cell is empty, the code snippet in this cell must result in a valid action element on its own.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Third cell:</emphasis> Text in the third cell below <literal>ACTION</literal> is a descriptive label that you define for the column, as a visual aid.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fourth cell:</emphasis> From the fourth row on, non-blank entries provide data for interpolation. A blank cell omits the condition or constraint for this rule.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Metadata</term>
<listitem>
<simpara>For columns headed <literal>METADATA</literal>, the cells in consecutive lines result in a metadata annotation for the generated rules:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">First cell:</emphasis> Text in the first cell below <literal>METADATA</literal> is ignored.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Second cell:</emphasis> Text in the second cell below <literal>METADATA</literal> is subject to interpolation, using values from the cells in the rule rows. The metadata marker character <literal>@</literal> is prefixed automatically, so you do not need to include that character in the text for this cell.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Third cell:</emphasis> Text in the third cell below <literal>METADATA</literal> is a descriptive label that you define for the column, as a visual aid.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fourth cell:</emphasis> From the fourth row on, non-blank entries provide data for interpolation. A blank cell results in the omission of the metadata annotation for this rule.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="decision-tables-attributes-ref">
<title>Additional rule attributes for RuleSet or RuleTable definitions</title>
<simpara>The <literal>RuleSet</literal> and <literal>RuleTable</literal> areas also support labels and values for other rule attributes, such as <literal>PRIORITY</literal> or <literal>NO-LOOP</literal>. Rule attributes specified in a <literal>RuleSet</literal> area will affect all rule assets in the same package (not only in the spreadsheet). Rule attributes specified in a <literal>RuleTable</literal> area will affect only the rules in that rule table. You can use each rule attribute only once in a <literal>RuleSet</literal> area and once in a <literal>RuleTable</literal> area. If the same attribute is used in both <literal>RuleSet</literal> and <literal>RuleTable</literal> areas within the spreadsheet, then <literal>RuleTable</literal> takes priority and the attribute in the <literal>RuleSet</literal> area is overridden.</simpara>
<simpara>The following table lists the supported labels (column headers) and values for additional <literal>RuleSet</literal> or <literal>RuleTable</literal> definitions. For column headers, you can use either the given labels or any custom labels that begin with the letters listed in the table.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Additional rule attributes for <literal>RuleSet</literal> or <literal>RuleTable</literal> definitions</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="55*"/>
<thead>
<row>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Or custom label that begins with</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PRIORITY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>P</simpara></entry>
<entry align="left" valign="top"><simpara>An integer defining the <literal>salience</literal> value of the rule. Rules with a higher salience value are given higher priority when ordered in the activation queue. Overridden by the <literal>Sequential</literal> flag.</simpara><simpara>Example: <literal>PRIORITY 10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DATE-EFFECTIVE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>V</simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule can be activated only if the current date and time is after a <literal>DATE-EFFECTIVE</literal> attribute.</simpara><simpara>Example: <literal>DATE-EFFECTIVE "4-Sep-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DATE-EXPIRES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Z</simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule cannot be activated if the current date and time is after the <literal>DATE-EXPIRES</literal> attribute.</simpara><simpara>Example: <literal>DATE-EXPIRES "4-Oct-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NO-LOOP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>U</simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When this option is set to <literal>true</literal>, the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition.</simpara><simpara>Example: <literal>NO-LOOP true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AGENDA-GROUP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>G</simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated.</simpara><simpara>Example: <literal>AGENDA-GROUP "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ACTIVATION-GROUP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an activation (or XOR) group to which you want to assign the rule. In activation groups, only one rule can be activated. The first rule to fire will cancel all pending activations of all rules in the activation group.</simpara><simpara>Example: <literal>ACTIVATION-GROUP "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DURATION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>D</simpara></entry>
<entry align="left" valign="top"><simpara>A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met.</simpara><simpara>Example: <literal>DURATION 10000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TIMER</literal></simpara></entry>
<entry align="left" valign="top"><simpara>T</simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>int</literal> (interval) or <literal>cron</literal> timer definitions for scheduling the rule.</simpara><simpara>Example: <literal>TIMER "*/5 * * * *"</literal>  (every 5 minutes)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CALENDAR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>E</simpara></entry>
<entry align="left" valign="top"><simpara>A Quartz calendar definition for scheduling the rule.</simpara><simpara>Example: <literal>CALENDAR "* * 0-7,18-23 ? * *"</literal>  (exclude non-business hours)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AUTO-FOCUS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>F</simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within agenda groups. When this option is set to <literal>true</literal>, the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned.</simpara><simpara>Example: <literal>AUTO-FOCUS true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LOCK-ON-ACTIVE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>L</simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within rule flow groups or agenda groups. When this option is set to <literal>true</literal>, the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the <literal>no-loop</literal> attribute, because the activation of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again.</simpara><simpara>Example: <literal>LOCK-ON-ACTIVE true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RULEFLOW-GROUP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>R</simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow.</simpara><simpara>Example: <literal>RULEFLOW-GROUP "GroupName"</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<figure>
<title>Sample decision table spreadsheet with attribute columns</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/decision-table-example-03.png"/>
</imageobject>
<textobject><phrase>Example decision table with definitions used</phrase></textobject>
</mediaobject>
</figure>
</section>
</chapter>
<chapter xml:id="decision-tables-upload-proc">
<title>Uploading spreadsheet decision tables to Business Central</title>
<simpara>After you define your rules in an external XLS or XLSX spreadsheet of decision tables, you can upload the spreadsheet file to your project in Business Central.</simpara>
<important>
<simpara>You should typically upload only one spreadsheet of decision tables, containing all necessary <literal>RuleTable</literal> definitions, per rule package in Business Central. You can upload separate decision table spreadsheets for separate packages, but uploading multiple spreadsheets in the same package can cause compilation errors from conflicting <literal>RuleSet</literal> or <literal>RuleTable</literal> attributes and is therefore not recommended.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Decision Table (Spreadsheet)</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Decision Table</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Choose File</emphasis> icon, and select the spreadsheet. Click <emphasis role="strong">Ok</emphasis> to upload.</simpara>
</listitem>
<listitem>
<simpara>In the decision tables designer, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar to validate the table. If the table validation fails, open the XLS or XLSX file and address any syntax errors. For syntax help, see <xref linkend="decision-tables-defining-proc"/>.</simpara>
<simpara>You can upload a new version of the decision table or download the current version:</simpara>
<figure>
<title>Uploaded decision table options</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/decision-table-uploaded.png"/>
</imageobject>
<textobject><phrase>Decision table example</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="decision-tables-convert-proc">
<title>Converting an uploaded spreadsheet decision table to a guided decision table in Business Central</title>
<simpara>After you upload an XLS or XLSX spreadsheet decision table file to your project in Business Central, you can convert the decision table to a guided decision table that you can modify directly in Business Central.</simpara>
<simpara>For more information about guided decision tables, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link>.</simpara>
<warning>
<simpara>Guided decision tables and spreadsheet decision tables are different decision table formats that support different features. Any supported features that differ between the two decision table formats are modified or lost when you convert one decision table format to the other.</simpara>
</warning>
<formalpara>
<title>Procedure</title>
<para>In Business Central, navigate to the uploaded decision table asset that you want to convert and in the upper-right toolbar of the decision tables designer, click <emphasis role="strong">Convert</emphasis>:</para>
</formalpara>
<figure>
<title>Convert an uploaded decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/decision-table-uploaded-convert.png"/>
</imageobject>
<textobject><phrase>Decision table example</phrase></textobject>
</mediaobject>
</figure>
<simpara>After the conversion, the converted decision table is then available as a guided decision table asset in your project that you can modify directly in Business Central.</simpara>
</chapter>
<chapter xml:id="assets-executing-proc_decision-tables">
<title>Executing rules</title>
<simpara>After you identify example rules or create your own rules in Business Central, you can build and deploy the associated project and execute rules locally or on KIE Server to test the rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Business Central and KIE Server are installed and running. For installation options, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right corner of the project <emphasis role="strong">Assets</emphasis> page, click <emphasis role="strong">Deploy</emphasis> to build the project and deploy it to KIE Server. If the build fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the screen.</simpara>
<simpara>For more information about project deployment options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>If the rule assets in your project are not built from an executable rule model by default, verify that the following dependency is in the <literal>pom.xml</literal> file of your project and rebuild the project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-model-compiler&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>This dependency is required for rule assets in Red Hat Decision Manager to be built from executable rule models by default. This dependency is included as part of the Red Hat Decision Manager core packaging, but depending on your Red Hat Decision Manager upgrade history, you may need to manually add this dependency to enable the executable rule model behavior.</simpara>
<simpara>For more information about executable rule models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a Maven or Java project outside of Business Central, if not created already, that you can use for executing rules locally or that you can use as a client application for executing rules on KIE Server. The project must contain a <literal>pom.xml</literal> file and any other required components for executing the project resources.</simpara>
<simpara>For example test projects, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#drl-rules-other-con">"Other methods for creating and executing DRL rules"</link>.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>pom.xml</literal> file of your test project or client application and add the following dependencies, if not added already:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-ci</literal>: Enables your client application to load Business Central project data locally using <literal>ReleaseId</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kie-server-client</literal>: Enables your client application to interact remotely with assets on KIE Server</simpara>
</listitem>
<listitem>
<simpara><literal>slf4j</literal>: (Optional) Enables your client application to use Simple Logging Facade for Java (SLF4J) to return debug logging information after you interact with KIE Server</simpara>
</listitem>
</itemizedlist>
<simpara>Example dependencies for Red Hat Decision Manager 7.10 in a client application <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For local execution --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For remote execution on KIE Server --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For debug logging (optional) --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For available versions of these artifacts, search the group ID and artifact ID in the <link xlink:href="https://repository.jboss.org/nexus/index.html#welcome">Nexus Repository Manager</link> online.</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between Red Hat Decision Manager and the Maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the dependencies for artifacts containing model classes are defined in the client application <literal>pom.xml</literal> file exactly as they appear in the <literal>pom.xml</literal> file of the deployed project. If dependencies for model classes differ between the client application and your projects, execution errors can occur.</simpara>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>For example, the following <literal>Person</literal> class dependency appears in both the client and deployed project <literal>pom.xml</literal> files:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.sample&lt;/groupId&gt;
  &lt;artifactId&gt;Person&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you added the <literal>slf4j</literal> dependency to the client application <literal>pom.xml</literal> file for debug logging, create a <literal>simplelogger.properties</literal> file on the relevant classpath (for example, in <literal>src/main/resources/META-INF</literal> in Maven) with the following content:</simpara>
<programlisting language="java" linenumbering="unnumbered">org.slf4j.simpleLogger.defaultLogLevel=debug</programlisting>
</listitem>
<listitem>
<simpara>In your client application, create a <literal>.java</literal> main class containing the necessary imports and a <literal>main()</literal> method to load the KIE base, insert facts, and execute the rules.</simpara>
<simpara>For example, a <literal>Person</literal> object in a project contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person. The following <literal>Wage</literal> rule in a project calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
<simpara>To test this rule locally outside of KIE Server (if needed), configure the <literal>.java</literal> class to import KIE services, a KIE container, and a KIE session, and then use the <literal>main()</literal> method to fire all rules against a defined fact model:</simpara>
<formalpara>
<title>Executing rules locally</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.builder.ReleaseId;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.drools.compiler.kproject.ReleaseIdImpl;

public class RulesTest {

  public static final void main(String[] args) {
    try {
      // Identify the project in the local repository:
      ReleaseId rid = new ReleaseIdImpl("com.myspace", "MyProject", "1.0.0");

      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.newKieContainer(rid);
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
<simpara>To test this rule on KIE Server, configure the <literal>.java</literal> class with the imports and rule execution information similarly to the local example, and additionally specify KIE services configuration and KIE services client details:</simpara>
<formalpara>
<title>Executing rules on KIE Server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.kie.api.command.BatchExecutionCommand;
import org.kie.api.command.Command;
import org.kie.api.KieServices;
import org.kie.api.runtime.ExecutionResults;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.RuleServicesClient;

import com.sample.Person;

public class RulesTest {

  private static final String containerName = "testProject";
  private static final String sessionName = "myStatelessSession";

  public static final void main(String[] args) {
    try {
      // Define KIE services configuration and client:
      Set&lt;Class&lt;?&gt;&gt; allClasses = new HashSet&lt;Class&lt;?&gt;&gt;();
      allClasses.add(Person.class);
      String serverUrl = "http://$HOST:$PORT/kie-server/services/rest/server";
      String username = "$USERNAME";
      String password = "$PASSWORD";
      KieServicesConfiguration config =
        KieServicesFactory.newRestConfiguration(serverUrl,
                                                username,
                                                password);
      config.setMarshallingFormat(MarshallingFormat.JAXB);
      config.addExtraClasses(allClasses);
      KieServicesClient kieServicesClient =
        KieServicesFactory.newKieServicesClient(config);

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert Person into the session:
      KieCommands kieCommands = KieServices.Factory.get().getCommands();
      List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();
      commandList.add(kieCommands.newInsert(p, "personReturnId"));

      // Fire all rules:
      commandList.add(kieCommands.newFireAllRules("numberOfFiredRules"));
      BatchExecutionCommand batch = kieCommands.newBatchExecution(commandList, sessionName);

      // Use rule services client to send request:
      RuleServicesClient ruleClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
      ServiceResponse&lt;ExecutionResults&gt; executeResponse = ruleClient.executeCommandsWithResults(containerName, batch);
      System.out.println("number of fired rules:" + executeResponse.getResult().getValue("numberOfFiredRules"));
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the configured <literal>.java</literal> class from your project directory. You can run the file in your development platform
(such as Red Hat CodeReady Studio)
or in the command line.</simpara>
<simpara>Example Maven execution (within project directory):</simpara>
<screen>mvn clean install exec:java -Dexec.mainClass="com.sample.app.RulesTest"</screen>
<simpara>Example Java execution (within project directory)</simpara>
<screen>javac -classpath "./$DEPENDENCIES/*:." RulesTest.java
java -classpath "./$DEPENDENCIES/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rule execution status in the command line and in the server log. If any rules do not execute as expected, review the configured rules in the project and the main class configuration to validate the data provided.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="next_steps_3" remap="_next_steps_3">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-test-scenarios"><emphasis>Testing a decision service using test scenarios</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-guided-rules">
<title>Designing a decision service using guided rules</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can define business rules using the guided rules designer in Business Central. These guided rules are compiled into Drools Rule Language (DRL) and form the core of the decision service for your project.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the guided rules have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_guided-rules">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="guided-rules-con_guided-rules">
<title>Guided rules</title>
<simpara>Guided rules are business rules that you create in a UI-based guided rules designer in Business Central that leads you through the rule-creation process. The guided rules designer provides fields and options for acceptable input based on the data objects for the rule being defined. The guided rules that you define are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>All data objects related to a guided rule must be in the same project package as the guided rule. Assets in the same package are imported by default. After you create the necessary data objects and the guided rule, you can use the <emphasis role="strong">Data Objects</emphasis> tab of the guided rules designer to verify that all required data objects are listed or to import other existing data objects by adding a <emphasis role="strong">New item</emphasis>.</simpara>
</chapter>
<chapter xml:id="data-objects-con_guided-rules">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_guided-rules">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="guided-rules-create-proc_guided-rules">
<title>Creating guided rules</title>
<simpara>Guided rules enable you to define business rules in a structured format, based on the data objects associated with the rules. You can create and define guided rules individually for your project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Guided Rule</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Guided Rule</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects have been assigned or will be assigned.</simpara>
<simpara>You can also select <emphasis role="strong">Show declared DSL sentences</emphasis> if any domain specific language (DSL) assets have been defined in your project. These DSL assets will then become usable objects for conditions and actions that you define in the guided rules designer.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the rule asset.</simpara>
<simpara>The new guided rule is now listed in the <emphasis role="strong">Guided Rules</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>, or in the <emphasis role="strong">Guided Rules (with DSL)</emphasis> panel if you selected the <emphasis role="strong">Show declared DSL sentences</emphasis> option.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Data Objects</emphasis> tab and confirm that all data objects required for your rules are listed. If not, click <emphasis role="strong">New item</emphasis> to import data objects from other packages, or
<link linkend="data-objects-create-proc_guided-rules">create data objects</link>
within your package.</simpara>
</listitem>
<listitem>
<simpara>After all data objects are in place, return to the <emphasis role="strong">Model</emphasis> tab of the guided rules designer and use the buttons on the right side of the window to add and define the <emphasis role="strong">WHEN</emphasis> (condition) and <emphasis role="strong">THEN</emphasis> (action) sections of the rule, based on the available data objects.</simpara>
<figure>
<title>The guided rules designer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/1140_01.png"/>
</imageobject>
<textobject><phrase>The guided rules designer</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <emphasis role="strong">WHEN</emphasis> part of the rule contains the conditions that must be met to execute an action. For example, if a bank requires loan applicants to have over 21 years of age, then the <emphasis role="strong">WHEN</emphasis> condition of an <literal>Underage</literal> rule would be <literal>Age | less than | 21</literal>.</simpara>
<simpara>The <emphasis role="strong">THEN</emphasis> part of the rule contains the actions to be performed when the conditional part of the rule has been met. For example, when the loan applicant is under 21 years old, the <emphasis role="strong">THEN</emphasis> action would set <literal>approved</literal> to <literal>false</literal>, declining the loan because the applicant is under age.</simpara>
<simpara>You can also specify exceptions for more complex rules, such as if a bank may approve of an under-aged applicant when a guarantor is involved. In that case, you would create or import a <emphasis role="strong">guarantor</emphasis> data object and then add the field to the guided rule.</simpara>
</listitem>
<listitem>
<simpara>After you define all components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the guided rules designer to validate the guided rule. If the rule validation fails, address any problems described in the error message, review all components in the rule, and try again to validate the rule until the rule passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the guided rules designer to save your work.</simpara>
</listitem>
</orderedlist>
<section xml:id="guided-rules-WHEN-proc_guided-rules">
<title>Adding WHEN conditions in guided rules</title>
<simpara>The <emphasis role="strong">WHEN</emphasis> part of the rule contains the conditions that must be met to execute an action. For example, if a bank requires loan applicants to have over 21 years of age, then the <emphasis role="strong">WHEN</emphasis> condition of an <literal>Underage</literal> rule would be <literal>Age | less than | 21</literal>. You can set simple or complex conditions to determine how and when your rules are applied.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your rules have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rules designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided rules designer, click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the <literal>WHEN</literal> section.</simpara>
<simpara>The <emphasis role="strong">Add a condition to the rule</emphasis> window with the available condition elements opens.</simpara>
<figure>
<title>Add a condition to the rule</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5687.png"/>
</imageobject>
<textobject><phrase>Add a condition to the rule</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes the data objects from the <emphasis role="strong">Data Objects</emphasis> tab of the guided rules designer, any DSL objects defined for the package (if you selected <emphasis role="strong">Show declared DSL sentences</emphasis> when you created this guided rule), and the following standard options:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">The following does not exist:</emphasis> Use this to specify facts and constraints that must not exist.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">The following exists:</emphasis> Use this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Any of the following are true:</emphasis> Use this to list any facts or constraints that must be true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From:</emphasis> Use this to define a <literal>From</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Accumulate:</emphasis> Use this to define an <literal>Accumulate</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Collect:</emphasis> Use this to define a <literal>Collect</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Entry Point:</emphasis> Use this to define an <literal>Entry Point</literal> for the pattern.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Free form DRL:</emphasis> Use this to insert a free-form DRL field where you can define condition elements freely, without the guided rules designer.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose a condition element (for example, <emphasis role="strong">LoanApplication</emphasis>) and click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the condition element in the guided rules designer and use the <emphasis role="strong">Modify constraints for LoanApplication</emphasis> window to add a restriction on a field, apply multiple field constraints, add a new formula style expression, apply an expression editor, or set a variable name.</simpara>
<figure>
<title>Modify a condition</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5689.png"/>
</imageobject>
<textobject><phrase>Modifying a condition</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>A variable name enables you to identify a fact or field in other constructs within the guided rule. For example, you could set the variable of <literal>LoanApplication</literal> to <literal>a</literal> and then reference <literal>a</literal> in a separate <literal>Bankruptcy</literal> constraint that specifies which application the bankruptcy is based on.</simpara>
<screen>a : LoanApplication()
Bankruptcy( application == a ).</screen>
</note>
<simpara>After you select a constraint, the window closes automatically.</simpara>
</listitem>
<listitem>
<simpara>Choose an operator for the restriction (for example, <literal>greater than</literal>) from the drop-down menu next to the added restriction.</simpara>
</listitem>
<listitem>
<simpara>Click the edit icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6191.png"/>
</imageobject>
<textobject><phrase>6191</phrase></textobject>
</inlinemediaobject>) to define the field value. The field value can be a literal value, a formula, or a full MVEL expression.</simpara>
</listitem>
<listitem>
<simpara>To apply multiple field constraints, click the condition and in the <emphasis role="strong">Modify constraints for LoanApplication</emphasis> window, select <emphasis role="strong">All of(And)</emphasis> or <emphasis role="strong">Any of(Or)</emphasis> from the <emphasis role="strong">Multiple field constraint</emphasis> drop-down menu.</simpara>
<figure>
<title>Add multiple field constraints</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5688.png"/>
</imageobject>
<textobject><phrase>Modifying a condition</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click the constraint in the guided rules designer and further define the field value.</simpara>
</listitem>
<listitem>
<simpara>After you define all condition components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the guided rules designer to validate the guided rule conditions. If the rule validation fails, address any problems described in the error message, review all components in the rule, and try again to validate the rule until the rule passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the guided rules designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="guided-rules-THEN-proc_guided-rules">
<title>Adding THEN actions in guided rules</title>
<simpara>The <emphasis role="strong">THEN</emphasis> part of the rule contains the actions to be performed when the <emphasis role="strong">WHEN</emphasis> condition of the rule has been met. For example, when a loan applicant is under 21 years old, the <emphasis role="strong">THEN</emphasis> action might set <literal>approved</literal> to <literal>false</literal>, declining the loan because the applicant is under age. You can set simple or complex actions to determine how and when your rules are applied.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your rules have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rules designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided rules designer, click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the <literal>THEN</literal> section.</simpara>
<simpara>The <emphasis role="strong">Add a new action</emphasis> window with the available action elements opens.</simpara>
<figure>
<title>Add a new action to the rule</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5695.png"/>
</imageobject>
<textobject><phrase>Add a new action to the rule</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes insertion and modification options based on the data objects in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rules designer, and on any DSL objects defined for the package (if you selected <emphasis role="strong">Show declared DSL sentences</emphasis> when you created this guided rule):</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Change field values of:</emphasis> Use this to set the value of fields on a fact (such as <literal>LoanApplication</literal>) without notifying the decision engine of the change.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete:</emphasis> Use this to delete a fact.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Modify:</emphasis> Use this to specify fields to be modified for a fact and to notify the decision engine of the change.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Insert fact:</emphasis> Use this to insert a fact and define resulting fields and values for the fact.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logically Insert fact:</emphasis> Use this to insert a fact logically into the decision engine and define resulting fields and values for the fact. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts have to be retracted explicitly. After logical insertions, facts are automatically retracted when the conditions that originally asserted the facts are no longer true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Add free form DRL:</emphasis> Use this to insert a free-form DRL field where you can define condition elements freely, without the guided rules designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Call method on:</emphasis> Use this to invoke a method from another fact.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose an action element (for example, <emphasis role="strong">Modify</emphasis>) and click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the action element in the guided rules designer and use the <emphasis role="strong">Add a field</emphasis> window to select a field.</simpara>
<figure>
<title>Add a field</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5696.png"/>
</imageobject>
<textobject><phrase>Add a field</phrase></textobject>
</mediaobject>
</figure>
<simpara>After you select a field, the window closes automatically.</simpara>
</listitem>
<listitem>
<simpara>Click the edit icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6191.png"/>
</imageobject>
<textobject><phrase>6191</phrase></textobject>
</inlinemediaobject>) to define the field value. The field value can be a literal value or a formula.</simpara>
</listitem>
<listitem>
<simpara>After you define all action components of the rule, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the guided rules designer to validate the guided rule actions. If the rule validation fails, address any problems described in the error message, review all components in the rule, and try again to validate the rule until the rule passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the guided rules designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="enumerations-define-proc_guided-rules">
<title>Defining enumerations for drop-down lists in rule assets</title>
<simpara>Enumeration definitions in Business Central determine the possible values of fields for conditions or actions in guided rules, guided rule templates, and guided decision tables. An enumeration definition contains a <literal>fact.field</literal> mapping to a list of supported values that are displayed as a drop-down list in the relevant field of a rule asset. When a user selects a field that is based on the same fact and field as the enumeration definition, the drop-down list of defined values is displayed.</simpara>
<simpara>You can define enumerations in Business Central or in the DRL source for your Red Hat Decision Manager project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Enumeration</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Enumeration</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects and relevant rule assets have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the enumeration.</simpara>
<simpara>The new enumeration is now listed in the <emphasis role="strong">Enumeration Definitions</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> tab of the enumerations designer, click <emphasis role="strong">Add enum</emphasis> and define the following values for the enumeration:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Fact</emphasis>: Specify an existing data object within the same package of your project with which you want to associate this enumeration. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to view the available data objects, or create the relevant data object as a new asset if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field</emphasis>: Specify an existing field identifier that you defined as part of the data object that you selected for the <emphasis role="strong">Fact</emphasis>. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to select the relevant data object and view the list of available <emphasis role="strong">Identifier</emphasis> options. You can create the relevant identifier for the data object if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Context</emphasis>: Specify a list of values in the format <literal>['string1','string2','string3']</literal> or <literal>[integer1,integer2,integer3]</literal> that you want to map to the <emphasis role="strong">Fact</emphasis> and <emphasis role="strong">Field</emphasis> definitions. These values will be displayed as a drop-down list for the relevant field of the rule asset.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following enumeration defines the drop-down values for applicant credit rating in a loan application decision service:</simpara>
<figure>
<title>Example enumeration for applicant credit rating in Business Central</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumConfig.png" align="center"/>
</imageobject>
<textobject><phrase>EnumConfig</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Example enumeration for applicant credit rating in the DRL source</title>
<para>
<screen>'Applicant.creditRating' : ['AA', 'OK', 'Sub prime']</screen>
</para>
</formalpara>
<simpara>In this example, for any guided rule, guided rule template, or guided decision table that is in the same package of the project and that uses the <literal>Applicant</literal> data object and the <literal>creditRating</literal> field, the configured values are available as drop-down options:</simpara>
<figure>
<title>Example enumeration drop-down options in a guided rule or guided rule template</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDown.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDown</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Example enumeration drop-down options in a guided decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDownGDT.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDownGDT</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<section xml:id="enumerations-advanced-ref_guided-rules">
<title>Advanced enumeration options for rule assets</title>
<simpara>For advanced use cases with enumeration definitions in your Red Hat Decision Manager project, consider the following extended options for defining enumerations:</simpara>
<variablelist>
<varlistentry>
<term>Mapping between DRL values and values in Business Central</term>
<listitem>
<simpara>If you want the enumeration values to appear differently or more completely in the Business Central interface than they appear in the DRL source, use a mapping in the format <literal>'fact.field' : ['sourceValue1=UIValue1','sourceValue2=UIValue2', …​ ]</literal> for your enumeration definition values.</simpara>
<simpara>For example, in the following enumeration definition for loan status, the options <literal>A</literal> or <literal>D</literal> are used in the DRL file but the options <literal>Approved</literal> or <literal>Declined</literal> are displayed in Business Central:</simpara>
<screen>'Loan.status' : ['A=Approved','D=Declined']</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>Enumeration value dependencies</term>
<listitem>
<simpara>If you want the selected value in one drop-down list to determine the available options in a subsequent drop-down list, use the format <literal>'fact.fieldB[fieldA=value1]' : ['value2', 'value3', …​ ]</literal> for your enumeration definition.</simpara>
<simpara>For example, in the following enumeration definition for insurance policies, the <literal>policyType</literal> field accepts the values <literal>Home</literal> or <literal>Car</literal>. The type of policy that the user selects determines the policy <literal>coverage</literal> field options that are then available:</simpara>
<screen>'Insurance.policyType' : ['Home', 'Car']
'Insurance.coverage[policyType=Home]' : ['property', 'liability']
'Insurance.coverage[policyType=Car]' : ['collision', 'fullCoverage']</screen>
<note>
<simpara>Enumeration dependencies are not applied across rule conditions and actions. For example, in this insurance policy use case, the selected policy in the rule condition does not determine the available coverage options in the rule actions, if applicable.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term>External data sources in enumerations</term>
<listitem>
<simpara>If you want to retrieve a list of enumeration values from an external data source instead of defining the values directly in the enumeration definition, on the class path of your project, add a helper class that returns a <literal>java.util.List</literal> list of strings. In the enumeration definition, instead of specifying a list of values, identify the helper class that you configured to retrieve the values externally.</simpara>
<simpara>For example, in the following enumeration definition for loan applicant region, instead of defining applicant regions explicitly in the format <literal>'Applicant.region' : ['country1', 'country2', …​ ]</literal>, the enumeration uses a helper class that returns the list of values defined externally:</simpara>
<screen>'Applicant.region' : (new com.mycompany.DataHelper()).getListOfRegions()</screen>
<simpara>In this example, a <literal>DataHelper</literal> class contains a <literal>getListOfRegions()</literal> method that returns a list of strings. The enumerations are loaded in the drop-down list for the relevant field in the rule asset.</simpara>
<simpara>You can also load dependent enumeration definitions dynamically from a helper class by identifying the dependent field as usual and enclosing the call to the helper class within quotation marks:</simpara>
<screen>'Applicant.region[countryCode]' : '(new com.mycompany.DataHelper()).getListOfRegions("@{countryCode}")'</screen>
<simpara>If you want to load all enumeration data entirely from an external data source, such as a relational database, you can implement a Java class that returns a <literal>Map&lt;String, List&lt;String&gt;&gt;</literal> map. The key of the map is the <literal>fact.field</literal> mapping and the value is a <literal>java.util.List&lt;String&gt;</literal> list of values.</simpara>
<simpara>For example, the following Java class defines loan applicant regions for the related enumeration:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SampleDataSource {

  public Map&lt;String, List&lt;String&gt;&gt; loadData() {
    Map data = new HashMap();

    List d = new ArrayList();
    d.add("AU");
    d.add("DE");
    d.add("ES");
    d.add("UK");
    d.add("US");
    ...
    data.put("Applicant.region", d);

    return data;
  }

}</programlisting>
<simpara>The following enumeration definition correlates to this example Java class. The enumeration contains no references to fact or field names because they are defined in the Java class:</simpara>
<screen>=(new SampleDataSource()).loadData()</screen>
<simpara>The <literal>=</literal> operator enables Business Central to load all enumeration data from the helper class. The helper methods are statically evaluated when the enumeration definition is requested for use in an editor.</simpara>
<note>
<simpara>Defining an enumeration without a fact and field definition is currently not supported in Business Central. To define the enumeration for the associated Java class in this way, use the DRL source in your Red Hat Decision Manager project.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="guided-rules-options-proc_guided-rules">
<title>Adding other rule options</title>
<simpara>You can also use the rule designer to add metadata within a rule, define additional rule attributes (such as <literal>salience</literal> and <literal>no-loop</literal>), and freeze areas of the rule to restrict modifications to conditions or actions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the rule designer, click <emphasis role="strong">(show options…​)</emphasis> under the <emphasis role="strong">THEN</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the window to add options.</simpara>
</listitem>
<listitem>
<simpara>Select an option to be added to the rule:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Metadata:</emphasis> Enter a metadata label and click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>). Then enter any needed data in the field provided in the rule designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Attribute:</emphasis> Select from the list of rule attributes. Then further define the value in the field or option displayed in the rule designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Freeze areas for editing:</emphasis> Select <emphasis role="strong">Conditions</emphasis> or <emphasis role="strong">Actions</emphasis> to restrict the area from being modified in the rule designer.</simpara>
<figure>
<title>Rule options</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/1141.png"/>
</imageobject>
<textobject><phrase>Additional rule options</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the rule designer to save your work.</simpara>
</listitem>
</orderedlist>
<section xml:id="rules-attributes-ref_guided-rules">
<title>Rule attributes</title>
<simpara>Rule attributes are additional specifications that you can add to business rules to modify rule behavior.</simpara>
<simpara>The following table lists the names and supported values of the attributes that you can assign to rules:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Rule attributes</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Attribute</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>salience</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An integer defining the priority of the rule. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara><simpara>Example: <literal>salience 10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule is enabled. When the option is not selected, the rule is disabled.</simpara><simpara>Example: <literal>enabled true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-effective</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule can be activated only if the current date and time is after a <literal>date-effective</literal> attribute.</simpara><simpara>Example: <literal>date-effective "4-Sep-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-expires</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule cannot be activated if the current date and time is after the <literal>date-expires</literal> attribute.</simpara><simpara>Example: <literal>date-expires "4-Oct-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>no-loop</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition. When the condition is not selected, the rule can be looped in these circumstances.</simpara><simpara>Example: <literal>no-loop true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>agenda-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated.</simpara><simpara>Example: <literal>agenda-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>activation-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an activation (or XOR) group to which you want to assign the rule. In activation groups, only one rule can be activated. The first rule to fire will cancel all pending activations of all rules in the activation group.</simpara><simpara>Example: <literal>activation-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>duration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met.</simpara><simpara>Example: <literal>duration 10000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>timer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>int</literal> (interval) or <literal>cron</literal> timer definitions for scheduling the rule.</simpara><simpara>Example: <literal>timer ( cron:* 0/15 * * * ? )</literal>  (every 15 minutes)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>calendar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A <link xlink:href="http://www.quartz-scheduler.org/">Quartz</link> calendar definition for scheduling the rule.</simpara><simpara>Example: <literal>calendars "* * 0-7,18-23 ? * *"</literal>  (exclude non-business hours)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>auto-focus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within agenda groups. When the option is selected, the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned.</simpara><simpara>Example: <literal>auto-focus true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>lock-on-active</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within rule flow groups or agenda groups. When the option is selected, the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the <literal>no-loop</literal> attribute, because the activation of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again.</simpara><simpara>Example: <literal>lock-on-active true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ruleflow-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow.</simpara><simpara>Example: <literal>ruleflow-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dialect</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>JAVA</literal> or <literal>MVEL</literal> as the language to be used for code expressions in the rule. By default, the rule uses the dialect specified at the package level. Any dialect specified here overrides the package dialect setting for the rule.</simpara>
<simpara>Example: <literal>dialect "JAVA"</literal></simpara>
<note>
<simpara>When you use Red Hat Decision Manager without the executable model, the <literal>dialect "JAVA"</literal> rule consequences support only Java 5 syntax. For more information about executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
</chapter>
<chapter xml:id="assets-executing-proc_guided-rules">
<title>Executing rules</title>
<simpara>After you identify example rules or create your own rules in Business Central, you can build and deploy the associated project and execute rules locally or on KIE Server to test the rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Business Central and KIE Server are installed and running. For installation options, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right corner of the project <emphasis role="strong">Assets</emphasis> page, click <emphasis role="strong">Deploy</emphasis> to build the project and deploy it to KIE Server. If the build fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the screen.</simpara>
<simpara>For more information about project deployment options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>If the rule assets in your project are not built from an executable rule model by default, verify that the following dependency is in the <literal>pom.xml</literal> file of your project and rebuild the project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-model-compiler&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>This dependency is required for rule assets in Red Hat Decision Manager to be built from executable rule models by default. This dependency is included as part of the Red Hat Decision Manager core packaging, but depending on your Red Hat Decision Manager upgrade history, you may need to manually add this dependency to enable the executable rule model behavior.</simpara>
<simpara>For more information about executable rule models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a Maven or Java project outside of Business Central, if not created already, that you can use for executing rules locally or that you can use as a client application for executing rules on KIE Server. The project must contain a <literal>pom.xml</literal> file and any other required components for executing the project resources.</simpara>
<simpara>For example test projects, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#drl-rules-other-con">"Other methods for creating and executing DRL rules"</link>.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>pom.xml</literal> file of your test project or client application and add the following dependencies, if not added already:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-ci</literal>: Enables your client application to load Business Central project data locally using <literal>ReleaseId</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kie-server-client</literal>: Enables your client application to interact remotely with assets on KIE Server</simpara>
</listitem>
<listitem>
<simpara><literal>slf4j</literal>: (Optional) Enables your client application to use Simple Logging Facade for Java (SLF4J) to return debug logging information after you interact with KIE Server</simpara>
</listitem>
</itemizedlist>
<simpara>Example dependencies for Red Hat Decision Manager 7.10 in a client application <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For local execution --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For remote execution on KIE Server --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For debug logging (optional) --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For available versions of these artifacts, search the group ID and artifact ID in the <link xlink:href="https://repository.jboss.org/nexus/index.html#welcome">Nexus Repository Manager</link> online.</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between Red Hat Decision Manager and the Maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the dependencies for artifacts containing model classes are defined in the client application <literal>pom.xml</literal> file exactly as they appear in the <literal>pom.xml</literal> file of the deployed project. If dependencies for model classes differ between the client application and your projects, execution errors can occur.</simpara>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>For example, the following <literal>Person</literal> class dependency appears in both the client and deployed project <literal>pom.xml</literal> files:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.sample&lt;/groupId&gt;
  &lt;artifactId&gt;Person&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you added the <literal>slf4j</literal> dependency to the client application <literal>pom.xml</literal> file for debug logging, create a <literal>simplelogger.properties</literal> file on the relevant classpath (for example, in <literal>src/main/resources/META-INF</literal> in Maven) with the following content:</simpara>
<programlisting language="java" linenumbering="unnumbered">org.slf4j.simpleLogger.defaultLogLevel=debug</programlisting>
</listitem>
<listitem>
<simpara>In your client application, create a <literal>.java</literal> main class containing the necessary imports and a <literal>main()</literal> method to load the KIE base, insert facts, and execute the rules.</simpara>
<simpara>For example, a <literal>Person</literal> object in a project contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person. The following <literal>Wage</literal> rule in a project calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
<simpara>To test this rule locally outside of KIE Server (if needed), configure the <literal>.java</literal> class to import KIE services, a KIE container, and a KIE session, and then use the <literal>main()</literal> method to fire all rules against a defined fact model:</simpara>
<formalpara>
<title>Executing rules locally</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.builder.ReleaseId;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.drools.compiler.kproject.ReleaseIdImpl;

public class RulesTest {

  public static final void main(String[] args) {
    try {
      // Identify the project in the local repository:
      ReleaseId rid = new ReleaseIdImpl("com.myspace", "MyProject", "1.0.0");

      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.newKieContainer(rid);
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
<simpara>To test this rule on KIE Server, configure the <literal>.java</literal> class with the imports and rule execution information similarly to the local example, and additionally specify KIE services configuration and KIE services client details:</simpara>
<formalpara>
<title>Executing rules on KIE Server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.kie.api.command.BatchExecutionCommand;
import org.kie.api.command.Command;
import org.kie.api.KieServices;
import org.kie.api.runtime.ExecutionResults;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.RuleServicesClient;

import com.sample.Person;

public class RulesTest {

  private static final String containerName = "testProject";
  private static final String sessionName = "myStatelessSession";

  public static final void main(String[] args) {
    try {
      // Define KIE services configuration and client:
      Set&lt;Class&lt;?&gt;&gt; allClasses = new HashSet&lt;Class&lt;?&gt;&gt;();
      allClasses.add(Person.class);
      String serverUrl = "http://$HOST:$PORT/kie-server/services/rest/server";
      String username = "$USERNAME";
      String password = "$PASSWORD";
      KieServicesConfiguration config =
        KieServicesFactory.newRestConfiguration(serverUrl,
                                                username,
                                                password);
      config.setMarshallingFormat(MarshallingFormat.JAXB);
      config.addExtraClasses(allClasses);
      KieServicesClient kieServicesClient =
        KieServicesFactory.newKieServicesClient(config);

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert Person into the session:
      KieCommands kieCommands = KieServices.Factory.get().getCommands();
      List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();
      commandList.add(kieCommands.newInsert(p, "personReturnId"));

      // Fire all rules:
      commandList.add(kieCommands.newFireAllRules("numberOfFiredRules"));
      BatchExecutionCommand batch = kieCommands.newBatchExecution(commandList, sessionName);

      // Use rule services client to send request:
      RuleServicesClient ruleClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
      ServiceResponse&lt;ExecutionResults&gt; executeResponse = ruleClient.executeCommandsWithResults(containerName, batch);
      System.out.println("number of fired rules:" + executeResponse.getResult().getValue("numberOfFiredRules"));
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the configured <literal>.java</literal> class from your project directory. You can run the file in your development platform
(such as Red Hat CodeReady Studio)
or in the command line.</simpara>
<simpara>Example Maven execution (within project directory):</simpara>
<screen>mvn clean install exec:java -Dexec.mainClass="com.sample.app.RulesTest"</screen>
<simpara>Example Java execution (within project directory)</simpara>
<screen>javac -classpath "./$DEPENDENCIES/*:." RulesTest.java
java -classpath "./$DEPENDENCIES/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rule execution status in the command line and in the server log. If any rules do not execute as expected, review the configured rules in the project and the main class configuration to validate the data provided.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="next_steps_4" remap="_next_steps_4">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-test-scenarios"><emphasis>Testing a decision service using test scenarios</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-guided-rule-templates">
<title>Designing a decision service using guided rule templates</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can define business rule templates using the guided rule templates designer in Business Central. These guided rule templates provide a reusable rule structure for multiple rules that are compiled into Drools Rule Language (DRL) and form the core of the decision service for your project.</simpara>
<note>
<simpara>You can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Decision Manager 7.10, see the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link> (step-by-step tutorial with a DMN decision service example)</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link> (overview of DMN support and capabilities in Red Hat Decision Manager)</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the guided rule templates have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</partintro>
<chapter xml:id="decision-authoring-assets-ref_guided-rule-templates">
<title>Decision-authoring assets in Red Hat Decision Manager</title>
<simpara>Red Hat Decision Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.</simpara>
<simpara>The following table highlights the main decision-authoring assets supported in Red Hat Decision Manager projects to help you decide or confirm the best method for defining decisions in your decision service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Decision-authoring assets supported in Red Hat Decision Manager</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Asset</entry>
<entry align="left" valign="top">Highlights</entry>
<entry align="left" valign="top">Authoring tools</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Decision Model and Notation (DMN) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are decision models based on a notation standard defined by the Object Management Group (OMG)</simpara>
</listitem>
<listitem>
<simpara>Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating comprehensive, illustrative, and stable decision flows</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or other DMN-compliant editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are tables of rules that you create in a UI-based table designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are a wizard-led alternative to spreadsheet decision tables</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Support hit policies, real-time validation, and other additional features not supported in other assets</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in a controlled tabular format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spreadsheet decision tables</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are XLS or XLSX spreadsheet decision tables that you can upload into Business Central</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules in decision tables already managed outside of Business Central</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly when uploaded</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Spreadsheet editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-decision-tables"><emphasis>Designing a decision service using spreadsheet decision tables</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you create in a UI-based rule designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating single rules in a controlled format to minimize compilation errors</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rules"><emphasis>Designing a decision service using guided rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Guided rule templates</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are reusable rule structures that you create in a UI-based template designer in Business Central</simpara>
</listitem>
<listitem>
<simpara>Provide fields and options for acceptable input</simpara>
</listitem>
<listitem>
<simpara>Support template keys and values for creating rule templates (fundamental to the purpose of this asset)</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating many rules with the same rule structure but with different defined field values</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-rule-templates"><emphasis>Designing a decision service using guided rule templates</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DRL rules</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are individual rules that you define directly in <literal>.drl</literal> text files</simpara>
</listitem>
<listitem>
<simpara>Provide the most flexibility for defining rules and other technicalities of rule behavior</simpara>
</listitem>
<listitem>
<simpara>Can be created in certain standalone environments and integrated with Red Hat Decision Manager</simpara>
</listitem>
<listitem>
<simpara>Are optimal for creating rules that require advanced DRL options</simpara>
</listitem>
<listitem>
<simpara>Have strict syntax requirements for rules to be compiled properly</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Business Central or integrated development environment (IDE)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Predictive Model Markup Language (PMML) models</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Are predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)</simpara>
</listitem>
<listitem>
<simpara>Use an XML schema that allows the PMML models to be shared between PMML-compliant platforms</simpara>
</listitem>
<listitem>
<simpara>Support Regression, Scorecard, Tree, Mining, and other model types</simpara>
</listitem>
<listitem>
<simpara>Can be included with a standalone Red Hat Decision Manager project or imported into a project in Business Central</simpara>
</listitem>
<listitem>
<simpara>Are optimal for incorporating predictive data into decision services in Red Hat Decision Manager</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>PMML or XML editor</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-pmml-models"><emphasis>Designing a decision service using PMML models</emphasis></link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="guided-rule-templates-con">
<title>Guided rule templates</title>
<simpara>Guided rule templates are business rule structures with placeholder values (template keys) that are interchanged with actual values defined in separate data tables. Each row of values defined in the corresponding data table for that template results in a rule. Guided rule templates are ideal when many rules have the same conditions, actions, and other attributes but differ in values of facts or constraints. In such cases, instead of creating many similar guided rules and defining values in each rule, you can create a guided rule template with the rule structure that applies to each rule and then define only the differing values in the data table.</simpara>
<simpara>The guided rule templates designer provides fields and options for acceptable template input based on the data objects for the rule template being defined, and a corresponding data table where you add template key values. After you create your guided rule template and add values in the corresponding data table, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>All data objects related to a guided rule template must be in the same project package as the guided rule template. Assets in the same package are imported by default. After you create the necessary data objects and the guided rule template, you can use the <emphasis role="strong">Data Objects</emphasis> tab of the guided rule templates designer to verify that all required data objects are listed or to import other existing data objects by adding a <emphasis role="strong">New item</emphasis>.</simpara>
</chapter>
<chapter xml:id="data-objects-con_guided-rule-templates">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_guided-rule-templates">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="guided-rule-templates-create-proc">
<title>Creating guided rule templates</title>
<simpara>You can use guided rule templates to define rule structures with placeholder values (template keys) that correspond to actual values defined in a data table. Guided rule templates are an efficient alternative to defining sets of many guided rules individually that use the same structure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Guided Rule Template</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Guided Rule Template</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the rule template.</simpara>
<simpara>The new guided rule template is now listed in the <emphasis role="strong">Guided Rule Templates</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Data Objects</emphasis> tab and confirm that all data objects required for your rules are listed. If not, click <emphasis role="strong">New item</emphasis> to import data objects from other packages, or
<link linkend="data-objects-create-proc_guided-rule-templates">create data objects</link>
within your package.</simpara>
</listitem>
<listitem>
<simpara>After all data objects are in place, return to the <emphasis role="strong">Model</emphasis> tab and use the buttons on the right side of the window to add and define the <emphasis role="strong">WHEN</emphasis> (condition) and <emphasis role="strong">THEN</emphasis> (action) sections of the rule template, based on the available data objects. For the field values that vary per rule, use template keys in the format <literal>$key</literal> in the rule designer or in the format <literal>@{key}</literal> in free form DRL (if used).</simpara>
<figure>
<title>Sample guided rule template</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-template.png"/>
</imageobject>
<textobject><phrase>Sample guided rule template</phrase></textobject>
</mediaobject>
</figure>
<note>
<title>Note on template keys</title>
<simpara>Template keys are fundamental in guided rule templates. Template keys are what enable field values in the templates to be interchanged with actual values that you define in the corresponding data table to generate different rules from the same template. You can use other value types, such as <emphasis role="strong">Literal</emphasis> or <emphasis role="strong">Formula</emphasis>, for values that are part of the rule structure of all rules based on that template. However, for any values that differ among the rules, use the <emphasis role="strong">Template key</emphasis> field type with a specified key. Without template keys in a guided rule template, the corresponding data table is not generated in the template designer and the template essentially functions as an individual guided rule.</simpara>
</note>
<simpara>The <emphasis role="strong">WHEN</emphasis> part of the rule template is the condition that must be met to execute an action. For example, if a telecommunications company charges customers based on the services they subscribe to (Internet, phone, and TV), then one of the <emphasis role="strong">WHEN</emphasis> conditions would be <literal>internetService | equal to | $hasInternetService</literal>. The template key <literal>$hasInternetService</literal> is interchanged with an actual Boolean value (<literal>true</literal> or <literal>false</literal>) defined in the data table for the template.</simpara>
<simpara>The <emphasis role="strong">THEN</emphasis> part of the rule template is the action to be performed when the conditional part of the rule has been met. For example, if a customer subscribes to only Internet service, a <emphasis role="strong">THEN</emphasis> action for <literal>RecurringPayment</literal> with a template key <literal>$amount</literal> would set the actual monthly amount to the integer value defined for Internet service charges in the data table.</simpara>
</listitem>
<listitem>
<simpara>After you define all components of the rule, click <emphasis role="strong">Save</emphasis> in the guided rule templates designer to save your work.</simpara>
</listitem>
</orderedlist>
<section xml:id="guided-rule-templates-WHEN-proc">
<title>Adding WHEN conditions in guided rule templates</title>
<simpara>The <emphasis role="strong">WHEN</emphasis> part of the rule contains the conditions that must be met to execute an action. For example, if a telecommunications company charges customers based on the services they subscribe to (Internet, phone, and TV), then one of the <emphasis role="strong">WHEN</emphasis> conditions would be <literal>internetService | equal to | $hasInternetService</literal>. The template key <literal>$hasInternetService</literal> is interchanged with an actual Boolean value (<literal>true</literal> or <literal>false</literal>) defined in the data table for the template.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your rules have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rule templates designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided rule templates designer, click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the <literal>WHEN</literal> section.</simpara>
<simpara>The <emphasis role="strong">Add a condition to the rule</emphasis> window with the available condition elements opens.</simpara>
<figure>
<title>Add a condition to the rule</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-add-condition.png"/>
</imageobject>
<textobject><phrase>Add a condition to the rule</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes the data objects from the <emphasis role="strong">Data Objects</emphasis> tab of the guided rule templates designer, any DSL objects defined for the package, and the following standard options:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">The following does not exist:</emphasis> Use this to specify facts and constraints that must not exist.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">The following exists:</emphasis> Use this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Any of the following are true:</emphasis> Use this to list any facts or constraints that must be true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From:</emphasis> Use this to define a <literal>From</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Accumulate:</emphasis> Use this to define an <literal>Accumulate</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Collect:</emphasis> Use this to define a <literal>Collect</literal> conditional element for the rule.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">From Entry Point:</emphasis> Use this to define an <literal>Entry Point</literal> for the pattern.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Free form DRL:</emphasis> Use this to insert a free-form DRL field where you can define condition elements freely, without the guided rules designer. For template keys in free form DRL, use the format <literal>@{key}</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose a condition element (for example, <emphasis role="strong">Customer</emphasis>) and click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the condition element in the guided rule templates designer and use the <emphasis role="strong">Modify constraints for Customer</emphasis> window to add a restriction on a field, apply multiple field constraints, add a new formula style expression, apply an expression editor, or set a variable name.</simpara>
<figure>
<title>Modify a condition</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-modify-condition.png"/>
</imageobject>
<textobject><phrase>Modifying a condition</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>A variable name enables you to identify a fact or field in other constructs within the guided rule. For example, you could set the variable of <literal>Customer</literal> to <literal>c</literal> and then reference <literal>c</literal> in a separate <literal>Applicant</literal> constraint that specifies that the <literal>Customer</literal> is the <literal>Applicant</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">c : Customer()
Applicant( this == c )</programlisting>
</note>
<simpara>After you select a constraint, the window closes automatically.</simpara>
</listitem>
<listitem>
<simpara>Choose an operator for the restriction (for example, <literal>equal to</literal>) from the drop-down menu next to the added restriction.</simpara>
</listitem>
<listitem>
<simpara>Click the edit icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6191.png"/>
</imageobject>
<textobject><phrase>6191</phrase></textobject>
</inlinemediaobject>) to define the field value.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Template key</emphasis> and add a template key in the format <literal>$key</literal> if this value varies among the rules that are based on this template. This allows the field value to be interchanged with actual values that you define in the corresponding data table to generate different rules from the same template. For field values that do not vary among the rules and are part of the rule template, you can use any other value type.</simpara>
</listitem>
<listitem>
<simpara>To apply multiple field constraints, click the condition and in the <emphasis role="strong">Modify constraints for Customer</emphasis> window, select <emphasis role="strong">All of(And)</emphasis> or <emphasis role="strong">Any of(Or)</emphasis> from the <emphasis role="strong">Multiple field constraint</emphasis> drop-down menu.</simpara>
<figure>
<title>Add multiple field constraints</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-multiple-constraints.png"/>
</imageobject>
<textobject><phrase>Add multiple field constraints</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click the constraint in the guided rule templates designer and further define the field values.</simpara>
</listitem>
<listitem>
<simpara>After you define all condition elements, click <emphasis role="strong">Save</emphasis> in the guided rule templates designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="guided-rule-templates-THEN-proc">
<title>Adding THEN actions in guided rule templates</title>
<simpara>The <emphasis role="strong">THEN</emphasis> part of the rule template is the action to be performed when the conditional part of the rule has been met. For example, if a customer subscribes to only Internet service, a <emphasis role="strong">THEN</emphasis> action for <literal>RecurringPayment</literal> with a template key <literal>$amount</literal> would set the actual monthly amount to the integer value defined for Internet service charges in the data table.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your rules have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rule templates designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided rule templates designer, click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the <literal>THEN</literal> section.</simpara>
<simpara>The <emphasis role="strong">Add a new action</emphasis> window with the available action elements opens.</simpara>
<figure>
<title>Add a new action to the rule</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-add-action.png"/>
</imageobject>
<textobject><phrase>Add a new action to the rule</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes insertion and modification options based on the data objects in the <emphasis role="strong">Data Objects</emphasis> tab of the guided rule templates designer, and on any DSL objects defined for the package:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Insert fact:</emphasis> Use this to insert a fact and define resulting fields and values for the fact.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logically Insert fact:</emphasis> Use this to insert a fact logically into the decision engine and define resulting fields and values for the fact. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts have to be retracted explicitly. After logical insertions, facts are automatically retracted when the conditions that originally asserted the facts are no longer true.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Add free form DRL:</emphasis> Use this to insert a free-form DRL field where you can define condition elements freely, without the guided rules designer. For template keys in free form DRL, use the format <literal>@{key}</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose an action element (for example, <emphasis role="strong">Logically Insert fact RecurringPayment</emphasis>) and click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the action element in the guided rule templates designer and use the <emphasis role="strong">Add a field</emphasis> window to select a field.</simpara>
<figure>
<title>Add a field</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-add-field.png"/>
</imageobject>
<textobject><phrase>Add a field</phrase></textobject>
</mediaobject>
</figure>
<simpara>After you select a field, the window closes automatically.</simpara>
</listitem>
<listitem>
<simpara>Click the edit icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/6191.png"/>
</imageobject>
<textobject><phrase>6191</phrase></textobject>
</inlinemediaobject>) to define the field value.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Template key</emphasis> and add a template key in the format <literal>$key</literal> if this value varies among the rules that are based on this template. This allows the field value to be interchanged with actual values that you define in the corresponding data table to generate different rules from the same template. For field values that do not vary among the rules and are part of the rule template, you can use any other value type.</simpara>
</listitem>
<listitem>
<simpara>After you define all action elements, click <emphasis role="strong">Save</emphasis> in the guided rule templates designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="enumerations-define-proc_guided-rule-templates">
<title>Defining enumerations for drop-down lists in rule assets</title>
<simpara>Enumeration definitions in Business Central determine the possible values of fields for conditions or actions in guided rules, guided rule templates, and guided decision tables. An enumeration definition contains a <literal>fact.field</literal> mapping to a list of supported values that are displayed as a drop-down list in the relevant field of a rule asset. When a user selects a field that is based on the same fact and field as the enumeration definition, the drop-down list of defined values is displayed.</simpara>
<simpara>You can define enumerations in Business Central or in the DRL source for your Red Hat Decision Manager project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Enumeration</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Enumeration</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required data objects and relevant rule assets have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the enumeration.</simpara>
<simpara>The new enumeration is now listed in the <emphasis role="strong">Enumeration Definitions</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> tab of the enumerations designer, click <emphasis role="strong">Add enum</emphasis> and define the following values for the enumeration:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Fact</emphasis>: Specify an existing data object within the same package of your project with which you want to associate this enumeration. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to view the available data objects, or create the relevant data object as a new asset if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Field</emphasis>: Specify an existing field identifier that you defined as part of the data object that you selected for the <emphasis role="strong">Fact</emphasis>. Open the <emphasis role="strong">Data Objects</emphasis> panel in the <emphasis role="strong">Project Explorer</emphasis> to select the relevant data object and view the list of available <emphasis role="strong">Identifier</emphasis> options. You can create the relevant identifier for the data object if needed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Context</emphasis>: Specify a list of values in the format <literal>['string1','string2','string3']</literal> or <literal>[integer1,integer2,integer3]</literal> that you want to map to the <emphasis role="strong">Fact</emphasis> and <emphasis role="strong">Field</emphasis> definitions. These values will be displayed as a drop-down list for the relevant field of the rule asset.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following enumeration defines the drop-down values for applicant credit rating in a loan application decision service:</simpara>
<figure>
<title>Example enumeration for applicant credit rating in Business Central</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumConfig.png" align="center"/>
</imageobject>
<textobject><phrase>EnumConfig</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Example enumeration for applicant credit rating in the DRL source</title>
<para>
<screen>'Applicant.creditRating' : ['AA', 'OK', 'Sub prime']</screen>
</para>
</formalpara>
<simpara>In this example, for any guided rule, guided rule template, or guided decision table that is in the same package of the project and that uses the <literal>Applicant</literal> data object and the <literal>creditRating</literal> field, the configured values are available as drop-down options:</simpara>
<figure>
<title>Example enumeration drop-down options in a guided rule or guided rule template</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDown.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDown</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Example enumeration drop-down options in a guided decision table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/EnumDropDownGDT.png" align="center"/>
</imageobject>
<textobject><phrase>EnumDropDownGDT</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<section xml:id="enumerations-advanced-ref_guided-rule-templates">
<title>Advanced enumeration options for rule assets</title>
<simpara>For advanced use cases with enumeration definitions in your Red Hat Decision Manager project, consider the following extended options for defining enumerations:</simpara>
<variablelist>
<varlistentry>
<term>Mapping between DRL values and values in Business Central</term>
<listitem>
<simpara>If you want the enumeration values to appear differently or more completely in the Business Central interface than they appear in the DRL source, use a mapping in the format <literal>'fact.field' : ['sourceValue1=UIValue1','sourceValue2=UIValue2', …​ ]</literal> for your enumeration definition values.</simpara>
<simpara>For example, in the following enumeration definition for loan status, the options <literal>A</literal> or <literal>D</literal> are used in the DRL file but the options <literal>Approved</literal> or <literal>Declined</literal> are displayed in Business Central:</simpara>
<screen>'Loan.status' : ['A=Approved','D=Declined']</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>Enumeration value dependencies</term>
<listitem>
<simpara>If you want the selected value in one drop-down list to determine the available options in a subsequent drop-down list, use the format <literal>'fact.fieldB[fieldA=value1]' : ['value2', 'value3', …​ ]</literal> for your enumeration definition.</simpara>
<simpara>For example, in the following enumeration definition for insurance policies, the <literal>policyType</literal> field accepts the values <literal>Home</literal> or <literal>Car</literal>. The type of policy that the user selects determines the policy <literal>coverage</literal> field options that are then available:</simpara>
<screen>'Insurance.policyType' : ['Home', 'Car']
'Insurance.coverage[policyType=Home]' : ['property', 'liability']
'Insurance.coverage[policyType=Car]' : ['collision', 'fullCoverage']</screen>
<note>
<simpara>Enumeration dependencies are not applied across rule conditions and actions. For example, in this insurance policy use case, the selected policy in the rule condition does not determine the available coverage options in the rule actions, if applicable.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term>External data sources in enumerations</term>
<listitem>
<simpara>If you want to retrieve a list of enumeration values from an external data source instead of defining the values directly in the enumeration definition, on the class path of your project, add a helper class that returns a <literal>java.util.List</literal> list of strings. In the enumeration definition, instead of specifying a list of values, identify the helper class that you configured to retrieve the values externally.</simpara>
<simpara>For example, in the following enumeration definition for loan applicant region, instead of defining applicant regions explicitly in the format <literal>'Applicant.region' : ['country1', 'country2', …​ ]</literal>, the enumeration uses a helper class that returns the list of values defined externally:</simpara>
<screen>'Applicant.region' : (new com.mycompany.DataHelper()).getListOfRegions()</screen>
<simpara>In this example, a <literal>DataHelper</literal> class contains a <literal>getListOfRegions()</literal> method that returns a list of strings. The enumerations are loaded in the drop-down list for the relevant field in the rule asset.</simpara>
<simpara>You can also load dependent enumeration definitions dynamically from a helper class by identifying the dependent field as usual and enclosing the call to the helper class within quotation marks:</simpara>
<screen>'Applicant.region[countryCode]' : '(new com.mycompany.DataHelper()).getListOfRegions("@{countryCode}")'</screen>
<simpara>If you want to load all enumeration data entirely from an external data source, such as a relational database, you can implement a Java class that returns a <literal>Map&lt;String, List&lt;String&gt;&gt;</literal> map. The key of the map is the <literal>fact.field</literal> mapping and the value is a <literal>java.util.List&lt;String&gt;</literal> list of values.</simpara>
<simpara>For example, the following Java class defines loan applicant regions for the related enumeration:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class SampleDataSource {

  public Map&lt;String, List&lt;String&gt;&gt; loadData() {
    Map data = new HashMap();

    List d = new ArrayList();
    d.add("AU");
    d.add("DE");
    d.add("ES");
    d.add("UK");
    d.add("US");
    ...
    data.put("Applicant.region", d);

    return data;
  }

}</programlisting>
<simpara>The following enumeration definition correlates to this example Java class. The enumeration contains no references to fact or field names because they are defined in the Java class:</simpara>
<screen>=(new SampleDataSource()).loadData()</screen>
<simpara>The <literal>=</literal> operator enables Business Central to load all enumeration data from the helper class. The helper methods are statically evaluated when the enumeration definition is requested for use in an editor.</simpara>
<note>
<simpara>Defining an enumeration without a fact and field definition is currently not supported in Business Central. To define the enumeration for the associated Java class in this way, use the DRL source in your Red Hat Decision Manager project.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="guided-rules-options-proc_guided-rule-templates">
<title>Adding other rule options</title>
<simpara>You can also use the rule designer to add metadata within a rule, define additional rule attributes (such as <literal>salience</literal> and <literal>no-loop</literal>), and freeze areas of the rule to restrict modifications to conditions or actions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the rule designer, click <emphasis role="strong">(show options…​)</emphasis> under the <emphasis role="strong">THEN</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) on the right side of the window to add options.</simpara>
</listitem>
<listitem>
<simpara>Select an option to be added to the rule:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Metadata:</emphasis> Enter a metadata label and click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>). Then enter any needed data in the field provided in the rule designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Attribute:</emphasis> Select from the list of rule attributes. Then further define the value in the field or option displayed in the rule designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Freeze areas for editing:</emphasis> Select <emphasis role="strong">Conditions</emphasis> or <emphasis role="strong">Actions</emphasis> to restrict the area from being modified in the rule designer.</simpara>
<figure>
<title>Rule options</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/1141.png"/>
</imageobject>
<textobject><phrase>Additional rule options</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the rule designer to save your work.</simpara>
</listitem>
</orderedlist>
<section xml:id="rules-attributes-ref_guided-rule-templates">
<title>Rule attributes</title>
<simpara>Rule attributes are additional specifications that you can add to business rules to modify rule behavior.</simpara>
<simpara>The following table lists the names and supported values of the attributes that you can assign to rules:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Rule attributes</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Attribute</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>salience</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An integer defining the priority of the rule. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara><simpara>Example: <literal>salience 10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule is enabled. When the option is not selected, the rule is disabled.</simpara><simpara>Example: <literal>enabled true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-effective</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule can be activated only if the current date and time is after a <literal>date-effective</literal> attribute.</simpara><simpara>Example: <literal>date-effective "4-Sep-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date-expires</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string containing a date and time definition. The rule cannot be activated if the current date and time is after the <literal>date-expires</literal> attribute.</simpara><simpara>Example: <literal>date-expires "4-Oct-2018"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>no-loop</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value. When the option is selected, the rule cannot be reactivated (looped) if a consequence of the rule re-triggers a previously met condition. When the condition is not selected, the rule can be looped in these circumstances.</simpara><simpara>Example: <literal>no-loop true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>agenda-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an agenda group to which you want to assign the rule. Agenda groups allow you to partition the agenda to provide more execution control over groups of rules. Only rules in an agenda group that has acquired a focus are able to be activated.</simpara><simpara>Example: <literal>agenda-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>activation-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying an activation (or XOR) group to which you want to assign the rule. In activation groups, only one rule can be activated. The first rule to fire will cancel all pending activations of all rules in the activation group.</simpara><simpara>Example: <literal>activation-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>duration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A long integer value defining the duration of time in milliseconds after which the rule can be activated, if the rule conditions are still met.</simpara><simpara>Example: <literal>duration 10000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>timer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>int</literal> (interval) or <literal>cron</literal> timer definitions for scheduling the rule.</simpara><simpara>Example: <literal>timer ( cron:* 0/15 * * * ? )</literal>  (every 15 minutes)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>calendar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A <link xlink:href="http://www.quartz-scheduler.org/">Quartz</link> calendar definition for scheduling the rule.</simpara><simpara>Example: <literal>calendars "* * 0-7,18-23 ? * *"</literal>  (exclude non-business hours)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>auto-focus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within agenda groups. When the option is selected, the next time the rule is activated, a focus is automatically given to the agenda group to which the rule is assigned.</simpara><simpara>Example: <literal>auto-focus true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>lock-on-active</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A Boolean value, applicable only to rules within rule flow groups or agenda groups. When the option is selected, the next time the ruleflow group for the rule becomes active or the agenda group for the rule receives a focus, the rule cannot be activated again until the ruleflow group is no longer active or the agenda group loses the focus. This is a stronger version of the <literal>no-loop</literal> attribute, because the activation of a matching rule is discarded regardless of the origin of the update (not only by the rule itself). This attribute is ideal for calculation rules where you have a number of rules that modify a fact and you do not want any rule re-matching and firing again.</simpara><simpara>Example: <literal>lock-on-active true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ruleflow-group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying a rule flow group. In rule flow groups, rules can fire only when the group is activated by the associated rule flow.</simpara><simpara>Example: <literal>ruleflow-group "GroupName"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>dialect</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A string identifying either <literal>JAVA</literal> or <literal>MVEL</literal> as the language to be used for code expressions in the rule. By default, the rule uses the dialect specified at the package level. Any dialect specified here overrides the package dialect setting for the rule.</simpara>
<simpara>Example: <literal>dialect "JAVA"</literal></simpara>
<note>
<simpara>When you use Red Hat Decision Manager without the executable model, the <literal>dialect "JAVA"</literal> rule consequences support only Java 5 syntax. For more information about executable models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
</chapter>
<chapter xml:id="guided-rule-templates-tables-proc">
<title>Defining data tables for guided rule templates</title>
<simpara>After you create a guided rule template and add template keys for field values, a data table is displayed in the <emphasis role="strong">Data</emphasis> table of the guided rule templates designer. Each column in the data table corresponds to a template key that you added in the guided rule template. Use this table to define values for each template key row by row. Each row of values that you define in the data table for that template results in a rule.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the guided rule templates designer, click the <emphasis role="strong">Data</emphasis> tab to view the data table. Each column in the data table corresponds to a template key that you added in the guided rule template.</simpara>
<note>
<simpara>If you did not add any template keys to the rule template, then this data table does not appear and the template does not function as a genuine template but essentially as an individual guided rule. For this reason, template keys are fundamental in creating guided rule templates.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add row</emphasis> and define the data values for each template key column to generate that rule (row).</simpara>
</listitem>
<listitem>
<simpara>Continue adding rows and defining data values for each rule that will be generated. You can click <emphasis role="strong">Add row</emphasis> for each new row, or click the plus icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/5686.png"/>
</imageobject>
<textobject><phrase>5686</phrase></textobject>
</inlinemediaobject>) or minus icon to add or remove rows.</simpara>
<figure>
<title>Sample data table for a guided rule template</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-data-table.png"/>
</imageobject>
<textobject><phrase>Sample data table for a guided rule template</phrase></textobject>
</mediaobject>
</figure>
<simpara>To view the DRL code, click the <emphasis role="strong">Source</emphasis> tab in the guided rule templates designer.</simpara>
<simpara>Example:</simpara>
<screen>rule "PaymentRules_6"
	when
		Customer( internetService == false ,
			phoneService == false ,
			TVService == true )
	then
		RecurringPayment fact0 = new RecurringPayment();
		fact0.setAmount( 5 );
		insertLogical( fact0 );
end

rule "PaymentRules_5"
	when
		Customer( internetService == false ,
			phoneService == true ,
			TVService == false )
	then
		RecurringPayment fact0 = new RecurringPayment();
		fact0.setAmount( 5 );
		insertLogical( fact0 );
end
...
//Other rules omitted for brevity.</screen>
</listitem>
<listitem>
<simpara>As a visual aid, click the grid icon in the upper-left corner of the data table to toggle cell merging on and off, if needed. Cells in the same column with identical values are merged into a single cell.</simpara>
<figure>
<title>Merge cells in a data table</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-cell-merging.png"/>
</imageobject>
<textobject><phrase>Merge cells in a data table</phrase></textobject>
</mediaobject>
</figure>
<simpara>You can then use the expand/collapse icon [+/-] in the upper-left corner of each newly merged cell to collapse the rows corresponding to the merged cell, or to re-expand the collapsed rows.</simpara>
<figure>
<title>Collapse merged cells</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Workbench/AuthoringAssets/guided-rule-templates-cell-merging-02.png"/>
</imageobject>
<textobject><phrase>Collapse merged cells</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>After you define the template key data for all rules and adjust the table display as needed, click <emphasis role="strong">Validate</emphasis> in the upper-right toolbar of the guided rule templates designer to validate the guided rule template. If the rule template validation fails, address any problems described in the error message, review all components in the rule template and data defined in the data table, and try again to validate the rule template until the rule template passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the guided rule templates designer to save your work.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="assets-executing-proc_guided-rule-templates">
<title>Executing rules</title>
<simpara>After you identify example rules or create your own rules in Business Central, you can build and deploy the associated project and execute rules locally or on KIE Server to test the rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Business Central and KIE Server are installed and running. For installation options, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>In the upper-right corner of the project <emphasis role="strong">Assets</emphasis> page, click <emphasis role="strong">Deploy</emphasis> to build the project and deploy it to KIE Server. If the build fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the screen.</simpara>
<simpara>For more information about project deployment options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
<note>
<simpara>If the rule assets in your project are not built from an executable rule model by default, verify that the following dependency is in the <literal>pom.xml</literal> file of your project and rebuild the project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;org.drools&lt;/groupId&gt;
  &lt;artifactId&gt;drools-model-compiler&lt;/artifactId&gt;
  &lt;version&gt;${rhdm.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>This dependency is required for rule assets in Red Hat Decision Manager to be built from executable rule models by default. This dependency is included as part of the Red Hat Decision Manager core packaging, but depending on your Red Hat Decision Manager upgrade history, you may need to manually add this dependency to enable the executable rule model behavior.</simpara>
<simpara>For more information about executable rule models, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#executable-model-con_packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a Maven or Java project outside of Business Central, if not created already, that you can use for executing rules locally or that you can use as a client application for executing rules on KIE Server. The project must contain a <literal>pom.xml</literal> file and any other required components for executing the project resources.</simpara>
<simpara>For example test projects, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#drl-rules-other-con">"Other methods for creating and executing DRL rules"</link>.</simpara>
</listitem>
<listitem>
<simpara>Open the <literal>pom.xml</literal> file of your test project or client application and add the following dependencies, if not added already:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-ci</literal>: Enables your client application to load Business Central project data locally using <literal>ReleaseId</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kie-server-client</literal>: Enables your client application to interact remotely with assets on KIE Server</simpara>
</listitem>
<listitem>
<simpara><literal>slf4j</literal>: (Optional) Enables your client application to use Simple Logging Facade for Java (SLF4J) to return debug logging information after you interact with KIE Server</simpara>
</listitem>
</itemizedlist>
<simpara>Example dependencies for Red Hat Decision Manager 7.10 in a client application <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;!-- For local execution --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie&lt;/groupId&gt;
  &lt;artifactId&gt;kie-ci&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For remote execution on KIE Server --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.kie.server&lt;/groupId&gt;
  &lt;artifactId&gt;kie-server-client&lt;/artifactId&gt;
  &lt;version&gt;7.48.0.Final-redhat-00002&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- For debug logging (optional) --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
  &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
  &lt;version&gt;1.7.25&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For available versions of these artifacts, search the group ID and artifact ID in the <link xlink:href="https://repository.jboss.org/nexus/index.html#welcome">Nexus Repository Manager</link> online.</simpara>
<note>
<simpara>Instead of specifying a Red Hat Decision Manager <literal>&lt;version&gt;</literal> for individual dependencies, consider adding the Red Hat Business Automation bill of materials (BOM) dependency to your project <literal>pom.xml</literal> file. The Red Hat Business Automation BOM applies to both Red Hat Decision Manager and Red Hat Process Automation Manager. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.</simpara>
<simpara>Example BOM dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.redhat.ba&lt;/groupId&gt;
  &lt;artifactId&gt;ba-platform-bom&lt;/artifactId&gt;
  &lt;version&gt;7.10.0.redhat-00002&lt;/version&gt;
  &lt;scope&gt;import&lt;/scope&gt;
  &lt;type&gt;pom&lt;/type&gt;
&lt;/dependency&gt;</programlisting>
<simpara>For more information about the Red Hat Business Automation BOM, see
<link xlink:href="https://access.redhat.com/solutions/3363991">What is the mapping between Red Hat Decision Manager and the Maven library version?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the dependencies for artifacts containing model classes are defined in the client application <literal>pom.xml</literal> file exactly as they appear in the <literal>pom.xml</literal> file of the deployed project. If dependencies for model classes differ between the client application and your projects, execution errors can occur.</simpara>
<simpara>To access the project <literal>pom.xml</literal> file in Business Central, select any existing asset in the project and then in the <emphasis role="strong">Project Explorer</emphasis> menu on the left side of the screen, click the <emphasis role="strong">Customize View</emphasis> gear icon and select <emphasis role="strong">Repository View</emphasis> → <emphasis role="strong">pom.xml</emphasis>.</simpara>
<simpara>For example, the following <literal>Person</literal> class dependency appears in both the client and deployed project <literal>pom.xml</literal> files:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;com.sample&lt;/groupId&gt;
  &lt;artifactId&gt;Person&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you added the <literal>slf4j</literal> dependency to the client application <literal>pom.xml</literal> file for debug logging, create a <literal>simplelogger.properties</literal> file on the relevant classpath (for example, in <literal>src/main/resources/META-INF</literal> in Maven) with the following content:</simpara>
<programlisting language="java" linenumbering="unnumbered">org.slf4j.simpleLogger.defaultLogLevel=debug</programlisting>
</listitem>
<listitem>
<simpara>In your client application, create a <literal>.java</literal> main class containing the necessary imports and a <literal>main()</literal> method to load the KIE base, insert facts, and execute the rules.</simpara>
<simpara>For example, a <literal>Person</literal> object in a project contains getter and setter methods to set and retrieve the first name, last name, hourly rate, and the wage of a person. The following <literal>Wage</literal> rule in a project calculates the wage and hourly rate values and displays a message based on the result:</simpara>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import com.sample.Person;

dialect "java"

rule "Wage"
  when
    Person(hourlyRate * wage &gt; 100)
    Person(name : firstName, surname : lastName)
  then
    System.out.println("Hello" + " " + name + " " + surname + "!");
    System.out.println("You are rich!");
end</programlisting>
<simpara>To test this rule locally outside of KIE Server (if needed), configure the <literal>.java</literal> class to import KIE services, a KIE container, and a KIE session, and then use the <literal>main()</literal> method to fire all rules against a defined fact model:</simpara>
<formalpara>
<title>Executing rules locally</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices;
import org.kie.api.builder.ReleaseId;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.drools.compiler.kproject.ReleaseIdImpl;

public class RulesTest {

  public static final void main(String[] args) {
    try {
      // Identify the project in the local repository:
      ReleaseId rid = new ReleaseIdImpl("com.myspace", "MyProject", "1.0.0");

      // Load the KIE base:
      KieServices ks = KieServices.Factory.get();
      KieContainer kContainer = ks.newKieContainer(rid);
      KieSession kSession = kContainer.newKieSession();

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert the person into the session:
      kSession.insert(p);

      // Fire all rules:
      kSession.fireAllRules();
      kSession.dispose();
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
<simpara>To test this rule on KIE Server, configure the <literal>.java</literal> class with the imports and rule execution information similarly to the local example, and additionally specify KIE services configuration and KIE services client details:</simpara>
<formalpara>
<title>Executing rules on KIE Server</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package com.sample;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.kie.api.command.BatchExecutionCommand;
import org.kie.api.command.Command;
import org.kie.api.KieServices;
import org.kie.api.runtime.ExecutionResults;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.RuleServicesClient;

import com.sample.Person;

public class RulesTest {

  private static final String containerName = "testProject";
  private static final String sessionName = "myStatelessSession";

  public static final void main(String[] args) {
    try {
      // Define KIE services configuration and client:
      Set&lt;Class&lt;?&gt;&gt; allClasses = new HashSet&lt;Class&lt;?&gt;&gt;();
      allClasses.add(Person.class);
      String serverUrl = "http://$HOST:$PORT/kie-server/services/rest/server";
      String username = "$USERNAME";
      String password = "$PASSWORD";
      KieServicesConfiguration config =
        KieServicesFactory.newRestConfiguration(serverUrl,
                                                username,
                                                password);
      config.setMarshallingFormat(MarshallingFormat.JAXB);
      config.addExtraClasses(allClasses);
      KieServicesClient kieServicesClient =
        KieServicesFactory.newKieServicesClient(config);

      // Set up the fact model:
      Person p = new Person();
      p.setWage(12);
      p.setFirstName("Tom");
      p.setLastName("Summers");
      p.setHourlyRate(10);

      // Insert Person into the session:
      KieCommands kieCommands = KieServices.Factory.get().getCommands();
      List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;();
      commandList.add(kieCommands.newInsert(p, "personReturnId"));

      // Fire all rules:
      commandList.add(kieCommands.newFireAllRules("numberOfFiredRules"));
      BatchExecutionCommand batch = kieCommands.newBatchExecution(commandList, sessionName);

      // Use rule services client to send request:
      RuleServicesClient ruleClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
      ServiceResponse&lt;ExecutionResults&gt; executeResponse = ruleClient.executeCommandsWithResults(containerName, batch);
      System.out.println("number of fired rules:" + executeResponse.getResult().getValue("numberOfFiredRules"));
    }

    catch (Throwable t) {
      t.printStackTrace();
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the configured <literal>.java</literal> class from your project directory. You can run the file in your development platform
(such as Red Hat CodeReady Studio)
or in the command line.</simpara>
<simpara>Example Maven execution (within project directory):</simpara>
<screen>mvn clean install exec:java -Dexec.mainClass="com.sample.app.RulesTest"</screen>
<simpara>Example Java execution (within project directory)</simpara>
<screen>javac -classpath "./$DEPENDENCIES/*:." RulesTest.java
java -classpath "./$DEPENDENCIES/*:." RulesTest</screen>
</listitem>
<listitem>
<simpara>Review the rule execution status in the command line and in the server log. If any rules do not execute as expected, review the configured rules in the project and the main class configuration to validate the data provided.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="next_steps_5" remap="_next_steps_5">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-test-scenarios"><emphasis>Testing a decision service using test scenarios</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-test-scenarios">
<title>Testing a decision service using test scenarios</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can use test scenarios in Business Central to test a decision service before a project is deployed. You can test DMN-based and rules-based decision services to ensure these are functioning properly and as expected. Also, you can test a decision service at any time during project development.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The space and project for the decision service have been created in Business Central. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>Business rules and their associated data objects have been defined for the rules-based decision service. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-guided-decision-tables"><emphasis>Designing a decision service using guided decision tables</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>DMN decision logic and its associated custom data types have been defined for the DMN-based decision service. For details, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Having defined business rules is not a technical prerequisite for test scenarios, because the scenarios can test the defined data that constitutes the business rules. However, creating the rules first is helpful so that you can also test entire rules in test scenarios and so that the scenarios more closely match the intended decision service. For DMN-based test scenarios ensure that the DMN decision logic and its associated custom data types are defined for the decision service.</simpara>
</note>
</partintro>
<chapter xml:id="test-scenarios-intro-con_test-scenarios">
<title>Test scenarios</title>
<simpara>Test scenarios in Red Hat Decision Manager enable you to validate the functionality of business rules and business rule data (for rules-based test scenarios) or of DMN models (for DMN-based test scenarios) before deploying them into a production environment. With a test scenario, you use data from your project to set given conditions and expected results based on one or more defined business rules. When you run the scenario, the expected results and actual results of the rule instance are compared. If the expected results match the actual results, the test is successful. If the expected results do not match the actual results, then the test fails.</simpara>
<simpara>Red Hat Decision Manager currently supports both the new <emphasis role="strong">Test Scenarios</emphasis> designer and the former <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer. The default designer is the new test scenarios designer, which supports testing of both rules and DMN models and provides an enhanced overall user experience with test scenarios. If required, you can continue to use the legacy test scenarios designer, which supports rule-based test scenarios only.</simpara>
<simpara>You can run the defined test scenarios in a number of ways, for example, you can run available test scenarios at the project level or inside a specific test scenario asset. Test scenarios are independent and cannot affect or modify other test scenarios. You can run test scenarios at any time during project development in Business Central. You do not have to compile or deploy your decision service to run test scenarios.</simpara>
<simpara>You can import data objects from different packages to the same project package as the test scenario. Assets in the same package are imported by default. After you create the necessary data objects and the test scenario, you can use the <emphasis role="strong">Data Objects</emphasis> tab of the test scenarios designer to verify that all required data objects are listed or to import other existing data objects by adding a <emphasis role="strong">New item</emphasis>.</simpara>
<important>
<simpara>Throughout the test scenarios documentation, all references to <emphasis>test scenarios</emphasis> and the <emphasis>test scenarios designer</emphasis> are for the new version, unless explicitly noted as the legacy version.</simpara>
</important>
</chapter>
<chapter xml:id="data-objects-con_test-scenarios">
<title>Data objects</title>
<simpara>Data objects are the building blocks for the rule assets that you create. Data objects are custom data types implemented as Java objects in specified packages of your project. For example, you might create a <literal>Person</literal> object with data fields <literal>Name</literal>, <literal>Address</literal>, and <literal>DateOfBirth</literal> to specify personal details for loan application rules. These custom data types determine what data your assets and your decision services are based on.</simpara>
<section xml:id="data-objects-create-proc_test-scenarios">
<title>Creating data objects</title>
<simpara>The following procedure is a generic overview of creating data objects. It is not specific to a particular business asset.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique <emphasis role="strong">Data Object</emphasis> name and select the <emphasis role="strong">Package</emphasis> where you want the data object to be available for other rule assets. Data objects with the same name cannot exist in the same package. In the specified DRL file, you can import a data object from any package.</simpara>
<important>
<title>Importing data objects from other packages</title>
<simpara>You can import an existing data object from another package directly into the asset designers like guided rules or guided decision table designers. Select the relevant rule asset within the project and in the asset designer, go to <emphasis role="strong">Data Objects → New item</emphasis> to select the object to be imported.</simpara>
</important>
</listitem>
<listitem>
<simpara>To make your data object persistable, select the <emphasis role="strong">Persistable</emphasis> checkbox. Persistable data objects are able to be stored in a database according to the JPA specification. The default JPA is Hibernate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the data object designer, click <emphasis role="strong">add field</emphasis> to add a field to the object with the attributes <emphasis role="strong">Id</emphasis>, <emphasis role="strong">Label</emphasis>, and <emphasis role="strong">Type</emphasis>. Required attributes are marked with an asterisk (*).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Id:</emphasis> Enter the unique ID of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Label:</emphasis> (Optional) Enter a label for the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type:</emphasis> Enter the data type of the field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">List:</emphasis> (Optional) Select this check box to enable the field to hold multiple items for the specified type.</simpara>
<figure>
<title>Add data fields to a data object</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/DataModelerNewField2-new.png"/>
</imageobject>
<textobject><phrase>Add data fields to a data object</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to add the new field, or click <emphasis role="strong">Create and continue</emphasis> to add the new field and continue adding other fields.</simpara>
<note>
<simpara>To edit a field, select the field row and use the <emphasis role="strong">general properties</emphasis> on the right side of the screen.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="test-designer-con">
<title>Test scenarios designer in Business Central</title>
<simpara>The test scenarios designer provides a tabular layout that helps you in defining a scenario template and all the associated test cases. The designer layout consists of a table which has a header and the individual rows. The header consists of three parts, the <emphasis role="strong">GIVEN</emphasis> and <emphasis role="strong">EXPECT</emphasis> row, a row with instances, and a row with corresponding fields. The header is also known as test scenario template and the individual rows are called test scenarios definitions.</simpara>
<simpara>The test scenario template or header has the following two parts:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">GIVEN</emphasis> data objects and their fields - represents the input information</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">EXPECT</emphasis> data objects and their fields - represents the objects and their fields whose exact values are checked based on the given information and which also constitutes the expected result.</simpara>
</listitem>
</itemizedlist>
<simpara>The test scenarios definitions represent the separate test cases of a template.</simpara>
<simpara>You can access the <emphasis role="strong">Project Explorer</emphasis> from the left panel of the designer whereas from the right panel you can access the <emphasis role="strong">Settings</emphasis>, <emphasis role="strong">Test Tools</emphasis>, <emphasis role="strong">Scenario Cheatsheet</emphasis>, <emphasis role="strong">Test Report</emphasis> and the <emphasis role="strong">Coverage Report</emphasis> tabs. You can access the <emphasis role="strong">Settings</emphasis> tab to view and edit the global settings of rule-based and DMN-based test scenarios. You can use the <emphasis role="strong">Test Tools</emphasis> to configure the data object mappings. <emphasis role="strong">Scenario Cheatsheet</emphasis> tab contains notes and the cheat sheet which you can use as reference. The <emphasis role="strong">Test Report</emphasis> tab displays the overview of the tests and the scenario status. To view the test coverage statistics, you can use the <emphasis role="strong">Coverage Report</emphasis> tab from the right side of the test scenario designer.</simpara>
<section xml:id="test-designer-data-objects-import-proc">
<title>Importing data objects</title>
<simpara>The test scenarios designer loads all data objects that are located in the same package as the test scenario. You can view all the data objects from the <emphasis role="strong">Data Objects</emphasis> tab in the designer. The loaded data objects are also displayed in the <emphasis role="strong">Test Tools</emphasis> panel.</simpara>
<simpara>You need to close and reopen the designer in case the data objects change (for example, when a new data object is created or when an existing one is deleted). Select a data object from the list to display its fields and the field types.</simpara>
<simpara>In case you want to use a data object located in a different package than the test scenario, you need to import the data object first. Follow the procedure below to import a data object for rules-based test scenarios.</simpara>
<note>
<simpara>You cannot import any data objects while creating DMN-based test scenarios. DMN-based test scenarios do not use any data objects from the project but uses the custom data types defined in the DMN file.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Go to <emphasis role="strong">Project Explorer</emphasis> panel in the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>From <emphasis role="strong">Test Scenario</emphasis>, select a test scenario.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Data Objects</emphasis> tab and click <emphasis role="strong">New Item</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Add import</emphasis> window, choose the data object from the drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> and then <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Close and reopen the test scenarios designer to view the new data object from the data objects list.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-designer-test-scenario-import-proc">
<title>Importing a test scenario</title>
<simpara>You can import an existing test scenario using the <emphasis role="strong">Import Asset</emphasis> button in the <emphasis role="strong">Asset</emphasis> tab from the project view.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>From the project’s <emphasis role="strong">Asset</emphasis> tab, click <emphasis role="strong">Import Asset</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Create new Import Asset</emphasis> window,</simpara>
<itemizedlist>
<listitem>
<simpara>Enter the name of the import asset.</simpara>
</listitem>
<listitem>
<simpara>Select the package from the <emphasis role="strong">Package</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>From <emphasis role="strong">Please select a file to upload</emphasis>, click <emphasis role="strong">Choose File…​</emphasis> to browse to test scenario file.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select the file and click <emphasis role="strong">Open</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> and the test scenario opens in the test scenario designer.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-designer-save-test-proc">
<title>Saving a test scenario</title>
<simpara>You can save a test scenario at any time while creating a test scenario template or defining the test scenarios.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the test scenarios designer toolbar on the upper-right, click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Confirm Save</emphasis> window,</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you wish to add a comment regarding the test scenario, click <emphasis role="strong">add a comment</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> again.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>A message stating that the test scenario was saved successfully appears on the screen.</simpara>
</section>
<section xml:id="test-designer-copy-test-proc">
<title>Copying a test scenario</title>
<simpara>You can copy an existing test scenario to the same package or to some other package by using the <emphasis role="strong">Copy</emphasis> button from the upper-right toolbar.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the test scenarios designer toolbar on the upper-right, click <emphasis role="strong">Copy</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Make a Copy</emphasis> window,</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter a name in the <emphasis role="strong">New Name</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Select the package you want to copy the test scenario to.</simpara>
</listitem>
<listitem>
<simpara>Optional: To add a comment, click <emphasis role="strong">add a comment</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Make a Copy</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>A message stating that the test scenario was copied successfully appears on the screen.</simpara>
</section>
<section xml:id="test-designer-download-test-proc">
<title>Downloading a test scenario</title>
<simpara>You can download a copy of the test scenario to your local machine for future reference or as backup.</simpara>
<formalpara>
<title>Procedure</title>
<para>In the test scenarios designer toolbar on the upper-right, click the <emphasis role="strong">Download</emphasis> icon.</para>
</formalpara>
<simpara>The <literal>.scesim</literal> file is downloaded to your local machine.</simpara>
</section>
<section xml:id="test-designer-latest-version-test-proc">
<title>Switching between versions of a test scenario</title>
<simpara>Business Central provides you the ability to switch between the various versions of a test scenario. Every time you save the scenario, a new version of the scenario is listed under <emphasis role="strong">Latest Versions</emphasis>. To use this feature, you must save the test scenario file at least once.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the test scenarios designer toolbar on the upper-right, click <emphasis role="strong">Latest Version</emphasis>. All the versions of the file are listed under <emphasis role="strong">Latest Version</emphasis>, if they exist.</simpara>
</listitem>
<listitem>
<simpara>Click the version you want to work on.</simpara>
<simpara>The selected version of the test scenario opens in the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>From the designer toolbar, click <emphasis role="strong">Restore</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Confirm Restore</emphasis>,</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To add a comment, click <emphasis role="strong">add a comment</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Restore</emphasis> to confirm.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>A message stating that the selected version has been reloaded successfully in the designer appears on the screen.</simpara>
</section>
<section xml:id="test-designer-view-hide-alerts-con">
<title>View or hide the alerts panel</title>
<simpara>The <emphasis role="strong">Alerts</emphasis> panel appears at the bottom of the test scenarios designer or the project view. It contains the build information and error messages in case the executed tests are failed.</simpara>
<formalpara>
<title>Procedure</title>
<para>From the designer toolbar on the upper-right, click <emphasis role="strong">Hide Alerts</emphasis>/<emphasis role="strong">View Alerts</emphasis> to enable or disable the reporting panel.</para>
</formalpara>
</section>
<section xml:id="test-designer-contextual-menu-ref">
<title>Contextual menu options</title>
<simpara>The test scenarios designer provides contextual menu options, which enables you to perform basic operations on the table such as adding, deleting, and, duplicating rows and columns. To use the contextual menus, you need to right-click a table element. Menu options differ based on the table element you select.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Contextual menu options</title>
<?dbhtml table-width=""?>
<?dbfo table-width=""?>
<?dblatex table-width=""?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="85*"/>
<colspec colname="col_2" colwidth="128*"/>
<colspec colname="col_3" colwidth="213*"/>
<thead>
<row>
<entry align="left" valign="top">Table element</entry>
<entry align="left" valign="top">Cell label</entry>
<entry align="left" valign="top">Available context menu options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="2"><simpara>Header</simpara></entry>
<entry align="left" valign="top"><simpara>#, Scenario description</simpara></entry>
<entry align="left" valign="top"><simpara>Insert row below</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GIVEN, EXPECT</simpara></entry>
<entry align="left" valign="top"><simpara>Insert leftmost column, Insert rightmost column, Insert row below</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>INSTANCE 1, INSTANCE 2, PROPERTY 1, PROPERTY 2</simpara></entry>
<entry align="left" valign="top"><simpara>Insert column left, Insert column right, Delete column, Duplicate Instance, Insert row below</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rows</simpara></entry>
<entry align="left" valign="top"><simpara>All the cells with row numbers, test scenarios description or test scenarios definition</simpara></entry>
<entry align="left" valign="top"><simpara>Insert row above, Insert row below, Duplicate row, Delete row, Run scenario</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Description of table interactions</title>
<?dbhtml table-width=""?>
<?dbfo table-width=""?>
<?dblatex table-width=""?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="106*"/>
<colspec colname="col_2" colwidth="319*"/>
<thead>
<row>
<entry align="left" valign="top">Table interaction</entry>
<entry align="left" valign="middle">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Insert leftmost column</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new leftmost column (in either the GIVEN or EXPECT section of the table based on user selection).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Insert rightmost column</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new rightmost column (in either the GIVEN or EXPECT section of the table based on user selection).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Insert column left</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new column to the left of the selected column. The new column is of the same type as the selected column (in either the GIVEN or EXPECT section of the table based on user selection).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Insert column right</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new column to the right of the selected column. The new column is of the same type as the selected column (in either the GIVEN or EXPECT section of the table based on user selection).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Delete column</simpara></entry>
<entry align="left" valign="top"><simpara>Deletes the selected column.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Insert row above</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new row above the selected row.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Insert row below</simpara></entry>
<entry align="left" valign="top"><simpara>Inserts a new row below the selected row. If invoked from a header cell, inserts a new row with index 1.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Duplicate row</simpara></entry>
<entry align="left" valign="top"><simpara>Duplicates the selected row.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Duplicate Instance</simpara></entry>
<entry align="left" valign="top"><simpara>Duplicates the selected instance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Delete row</simpara></entry>
<entry align="left" valign="top"><simpara>Deletes the selected row.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Run scenario</simpara></entry>
<entry align="left" valign="top"><simpara>Runs a single test scenario.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> context menu options behave differently.</simpara>
<itemizedlist>
<listitem>
<simpara>If the selected column does not have a type defined, a new column without a type is added.</simpara>
</listitem>
<listitem>
<simpara>If the selected column has a type defined, either a new empty column or a column with the parent instance type is created.</simpara>
<itemizedlist>
<listitem>
<simpara>If the action is performed from an instance header, a new column without a type is created.</simpara>
</listitem>
<listitem>
<simpara>If the action is performed from a property header, a new column with the parent instance type is created.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="test-designer-global-settings-panel-con">
<title>Global settings for test scenarios</title>
<simpara>You can use the global <emphasis role="strong">Settings</emphasis> tab on the right side of the test scenarios designer to set and modify the additional properties of assets.</simpara>
<section xml:id="test-designer-global-settings-panel-rule-based-proc">
<title>Configuring global settings for rule-based test scenarios</title>
<simpara>Follow the procedure below to view and edit the global settings of rule-based test scenarios.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Click <emphasis role="strong">Settings</emphasis> tab on the right side of the test scenario designer to display the attributes.</simpara>
</listitem>
<listitem>
<simpara>Configure the following attributes in the <emphasis role="strong">Settings</emphasis> panel:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: You can change the name of the existing test scenarios by using the <emphasis role="strong">Rename</emphasis> option from the upper-right toolbar in the designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: This attribute specifies it is a rule-based test scenario and it is read-only.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Stateless Session</emphasis>: Select or clear this check box to specify if the KieSession is stateless or not.</simpara>
<note>
<simpara>If the current KieSession is stateless and the check box is not selected, the tests will fail.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">KieSession</emphasis>: (Optional) Enter the KieSession for the test scenario.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">RuleFlowGroup/AgendaGroup</emphasis>: (Optional) Enter the RuleFlowGroup or AgendaGroup for the test scenario.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Optional: To skip the entire simulation from project level after test execution, select the check box.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-designer-global-settings-panel-dmn-based-proc">
<title>Configuring global settings for DMN-based test scenarios</title>
<simpara>Follow the procedure below to view and edit the global settings of DMN-based test scenarios.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Click <emphasis role="strong">Settings</emphasis> tab on the right side of the test scenario designer to display the attributes.</simpara>
</listitem>
<listitem>
<simpara>Configure the following attributes in the <emphasis role="strong">Settings</emphasis> panel:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: You can change the name of the existing test scenarios by using the <emphasis role="strong">Rename</emphasis> option from the upper-right toolbar in the designer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: This attribute specifies it is a DMN-based test scenario and it is read-only.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">DMN model</emphasis>: (Optional) Enter the DMN model for the test scenario.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">DMN name</emphasis>: This is the name of the DMN model and it is read-only.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">DMN namespace</emphasis>: This is the default namespace for DMN model and it is read-only.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Optional: To skip the entire simulation from project level after test execution, select the check box.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="test-designer-create-test-scenario-template-con">
<title>Test scenario template</title>
<simpara>Before specifying test scenario definitions, you need to create a test scenario template. The header of the test scenario table defines the template for each scenario. You need to set the types of the instance and property headers for both the GIVEN and EXPECT sections. Instance headers map to a particular data object (a fact), whereas the property headers map to a particular field of the corresponding data object.</simpara>
<simpara>Using the test scenarios designer, you can create test scenario templates for both rule-based and DMN-based test scenarios.</simpara>
<section xml:id="test-designer-create-test-template-rule-based-proc">
<title>Creating a test scenario template for rule-based test scenarios</title>
<simpara>Create a test scenario template for rule-based test scenarios by following the procedure below to validate your rules and data.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project for which you want to create the test scenario.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Test Scenario</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a <emphasis role="strong">Test Scenario</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package you select must contain all the required data objects and rule assets have been assigned or will be assigned.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">RULE</emphasis> as the <emphasis role="strong">Source type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create and open the test scenario in the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>To map the <emphasis role="strong">GIVEN</emphasis> column header to a data object:</simpara>
<figure>
<title>Test scenario GIVEN header cells</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test_scenario_GIVEN_header_cells.png"/>
</imageobject>
<textobject><phrase>test scenario GIVEN header cells</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select an instance header cell in the <emphasis role="strong">GIVEN</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Select the data object from the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To map the <emphasis role="strong">EXPECT</emphasis> column header to a data object:</simpara>
<figure>
<title>Test scenario EXPECT header cells</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test_scenario_EXPECT_header_cells.png"/>
</imageobject>
<textobject><phrase>test scenario EXPECT header cells</phrase></textobject>
</mediaobject>
</figure>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select an instance header cell in the <emphasis role="strong">EXPECT</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Select the data object from the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To map a data object field to a property cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select an instance header cell or property header cell.</simpara>
</listitem>
<listitem>
<simpara>Select the data object field from the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To insert more properties of the data object, right-click the property header and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required.</simpara>
</listitem>
<listitem>
<simpara>To define a java method to a property cell during test scenarios execution:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select an instance header cell or property header cell.</simpara>
</listitem>
<listitem>
<simpara>Select the data object field from the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Use the MVEL expression with the prefix <emphasis role="strong">#</emphasis> to define a java method for test scenario execution.</simpara>
</listitem>
<listitem>
<simpara>To insert more properties of the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Use the contextual menu to add or remove columns and rows as needed.</simpara>
</listitem>
</orderedlist>
<simpara>For more details about the expression syntax in rule-based scenarios, see <xref linkend="test-designer-expressions-syntax-rule-based-ref"/>.</simpara>
</section>
<section xml:id="test-designer-alias-proc">
<title>Using aliases in rule-based test scenarios</title>
<simpara>In the test scenarios designer, once you map a header cell with a data object, the data object is removed from the <emphasis role="strong">Test Tools</emphasis> tab. You can re-map a data object to another header cell by using an alias. Aliases enable you to specify multiple instances of the same data object in a test scenario. You can also create property aliases to rename the used properties directly in the table.</simpara>
<formalpara>
<title>Procedure</title>
<para>In the test scenarios designer in Business Central, double-click a header cell and manually change the name. Ensure that the aliases are uniquely named.</para>
</formalpara>
<simpara>The instance now appears in the list of data objects in the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</section>
</chapter>
<chapter xml:id="test-designer-test-template-dmn-based-con">
<title>Test template for DMN-based test scenarios</title>
<simpara>Business Central automatically generates the template for every DMN-based test scenario asset and it contains all the specified inputs and decisions of the related DMN model. For each input node in the DMN model, a <emphasis role="strong">GIVEN</emphasis> column is added, whereas each decision node is represented by an <emphasis role="strong">EXPECT</emphasis> column. You can modify the default template at any time as per your needs. Also, to test only a specific part of the whole DMN model, its possible to remove the generated columns as well as move decision nodes from the EXPECT to the GIVEN section.</simpara>
<section xml:id="test-designer-create-test-template-dmn-based-proc">
<title>Creating a test scenario template for DMN-based test scenarios</title>
<simpara>Create a test scenario template for DMN-based scenarios by following the procedure below to validate your DMN models.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project that you want to create the test scenario for.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Test Scenario</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a <emphasis role="strong">Test Scenario</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">DMN</emphasis> as the <emphasis role="strong">Source type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select an existing DMN asset using the <emphasis role="strong">Choose DMN asset</emphasis> option.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create and open the test scenario in the test scenarios designer.</simpara>
<simpara>The template is automatically generated and you can modify it as per your needs.</simpara>
</listitem>
<listitem>
<simpara>To define a java method to a property cell during test scenario execution:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click an instance header cell or property header cell.</simpara>
</listitem>
<listitem>
<simpara>Select the data object field from the <emphasis role="strong">Test Tools</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Use an expression to define a java method for test scenario execution.</simpara>
</listitem>
<listitem>
<simpara>To add more properties to the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Use the contextual menu to add or remove columns and rows as needed.</simpara>
</listitem>
</orderedlist>
<simpara>For more details about the expression syntax in DMN-based scenarios, see <xref linkend="test-designer-expressions-syntax-dmn-based-ref"/>.</simpara>
</section>
</chapter>
<chapter xml:id="test-designer-test-scenario-definition-proc">
<title>Defining a test scenario</title>
<simpara>After creating a test scenario template you have to define the test scenario next. The rows of the test scenario table define the individual test scenarios. A test scenario has a unique index number, description, set of input values (the <emphasis role="strong">Given</emphasis> values), and a set of output values (the <emphasis role="strong">Expect</emphasis> values).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The test scenario template has been created for the selected test scenario.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the test scenario in the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>Enter a description of the test scenario and fill in required values in each cell of the row.</simpara>
</listitem>
<listitem>
<simpara>Use the contextual menu to add or remove rows as required.</simpara>
<simpara>Double click a cell to start inline editing. To skip a particular cell from test evaluation, leave it empty.</simpara>
</listitem>
</orderedlist>
<simpara>After defining the test scenario, you can run the test next.</simpara>
</chapter>
<chapter xml:id="test-scenarios-background-instance-con">
<title>Background instance in test scenarios</title>
<simpara>In test scenario designer, you can use the <emphasis role="strong">Background</emphasis> tab to add and set background data for rules-based and DMN-based test scenarios. You can add and define the GIVEN data which is common for the entire test scenario simulation, based on the available data objects. <emphasis role="strong">Background</emphasis> tab has the ability to add and share the data among every test scenario. Data added using the <emphasis role="strong">Background</emphasis> tab can not be overridden by <emphasis role="strong">Model</emphasis> tab data.</simpara>
<simpara>For example, if the test scenario example requires the same value for the person <literal>Age</literal> in all test scenarios, you can define the <literal>Age</literal> value in the <emphasis role="strong">Background</emphasis> page and exclude that column from the test scenario table template. In this case, the <literal>Age</literal> is set to <literal>25</literal> for all test scenarios.</simpara>
<figure>
<title>Example test scenarios with repeated value for Age</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test_scenarios_with_repeated_value_for_Age.png"/>
</imageobject>
<textobject><phrase>test scenarios with repeated value for Age</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Example background definition of repeated value for Age</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/background_definition_of_repeated_value_for_Age.png"/>
</imageobject>
<textobject><phrase>background definition of repeated value for Age</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Modified test scenario template with excluded Age column</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/Modified_test_scenario_template_with_excluded_Age_column.png"/>
</imageobject>
<textobject><phrase>Modified test scenario template with excluded Age column</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>The GIVEN data which is defined in the <emphasis role="strong">Background</emphasis> tab can only be shared between the test scenarios of the same <emphasis role="strong">*.scesim</emphasis> file and will not be shared among different test scenarios.</simpara>
</note>
<section xml:id="test-scenarios-background-rule-based-proc">
<title>Adding a background data in rule-based test scenarios</title>
<simpara>Follow the procedure below to add and set a background data in rule-based test scenarios.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The rule-based test scenario template are created for the selected test scenario. For more information about creating rule-based test scenarios, see <xref linkend="test-designer-create-test-template-rule-based-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>The individual test scenarios are defined. For more information about defining a test scenario, see <xref linkend="test-designer-test-scenario-definition-proc"/>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the rule-based test scenarios in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Background</emphasis> tab of the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>Select an instance header cell in the <emphasis role="strong">GIVEN</emphasis> section to add a background data object field.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a property header cell to add a background data object field.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To add more properties to the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required.</simpara>
</listitem>
<listitem>
<simpara>Use the contextual menu to add or remove columns and rows as needed.</simpara>
</listitem>
<listitem>
<simpara>Run the defined test scenarios.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-scenarios-background-dmn-based-proc">
<title>Adding a background data in DMN-based test scenarios</title>
<simpara>Follow the procedure below to add and set a background data in DMN-based test scenarios.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The DMN-based test scenario template is created for the selected test scenario. For more information about creating DMN-based test scenarios, see <xref linkend="test-designer-create-test-template-dmn-based-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>The individual test scenarios are defined. For more information about defining a test scenario, see <xref linkend="test-designer-test-scenario-definition-proc"/>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the DMN-based test scenarios in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Background</emphasis> tab of the test scenarios designer.</simpara>
</listitem>
<listitem>
<simpara>Select an instance header cell in the <emphasis role="strong">GIVEN</emphasis> section to add a background data object field.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a property header cell to add a background data object field.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To add more properties to the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required.</simpara>
</listitem>
<listitem>
<simpara>Use the contextual menu to add or remove columns and rows as needed.</simpara>
</listitem>
<listitem>
<simpara>Run the defined test scenarios.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="test-designer-list-map-add-remove-item-proc">
<title>Using list and map collections in test scenarios</title>
<simpara>The test scenarios designer supports list and map collections for both DMN-based as well as rules-based test scenarios. You can create and define a collection like a list or a map ​as the value of a particular cell in both <emphasis role="strong">GIVEN</emphasis> and <emphasis role="strong">EXPECT</emphasis> columns.</simpara>
<note>
<simpara>For map entries, an entry key must be a <literal>String</literal> data type.</simpara>
</note>
<simpara>To pass the parameter in the <emphasis role="strong">EXPECT</emphasis> column of Rule-based collection editor use the <literal>actualValue</literal> keyword whereas use the <literal>?</literal> keyword in DMN-based test scenario.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the column type first (use a field whose type is a list or a map).</simpara>
</listitem>
<listitem>
<simpara>Double click a cell in the column to input a value.</simpara>
</listitem>
<listitem>
<simpara>To create the list values for the data objects in the collection editor popup:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select <emphasis role="strong">Create List</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add new item</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter the required value and click the check icon <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-datatype-constraints-tickmark.png"/>
</imageobject>
<textobject><phrase>dmn datatype constraints tickmark</phrase></textobject>
</inlinemediaobject> to save each collection item that you add.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To edit an item from the collection, click the pencil icon in the collection popup editor.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save changes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To delete an item from the collection, click the bin icon in the collection popup editor.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To define the list values for the data objects in the collection editor popup:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select <emphasis role="strong">Define List</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Use the MVEL or FEEL expression to define a list value in the text field.</simpara>
<simpara>Rule-based test scenario uses MVEL expression language and DMN-based test scenario uses FEEL expression language.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To create the map values for the data objects in the collection editor popup:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select <emphasis role="strong">Create Map</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add new item</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter the required value and click the check icon <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/dmn/dmn-datatype-constraints-tickmark.png"/>
</imageobject>
<textobject><phrase>dmn datatype constraints tickmark</phrase></textobject>
</inlinemediaobject> to save each collection item that you add.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To edit an item from the collection, click the pencil icon in the collection popup editor.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save changes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To delete an item from the collection, click the bin icon in the collection popup editor.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To define the map values for the data objects in the collection editor popup:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select <emphasis role="strong">Define Map</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Use the MVEL or FEEL expression to define a map value in the text field.</simpara>
<simpara>Rule-based test scenario uses MVEL expression language and DMN-based test scenario uses FEEL expression language.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
<note>
<simpara>To define the map values for DMN-based test scenario, you can add a fact and use the FEEL expression, instead of using the collection editor.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Remove</emphasis> to delete the entire collection.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="test-designer-expressions-syntax-intro-ref">
<title>Expression syntax in test scenarios</title>
<simpara>The test scenarios designer supports different expression languages for both rule-based and DMN-based test scenarios. While rule-based test scenarios support the MVFLEX Expression Language (MVEL) and DMN-based test scenarios support the Friendly Enough Expression Language (FEEL).</simpara>
<section xml:id="test-designer-expressions-syntax-rule-based-ref">
<title>Expression syntax in rule-based test scenarios</title>
<simpara>Rule-based test scenario supports the following built-in data types:</simpara>
<itemizedlist>
<listitem>
<simpara>String</simpara>
</listitem>
<listitem>
<simpara>Boolean</simpara>
</listitem>
<listitem>
<simpara>Integer</simpara>
</listitem>
<listitem>
<simpara>Long</simpara>
</listitem>
<listitem>
<simpara>Double</simpara>
</listitem>
<listitem>
<simpara>Float</simpara>
</listitem>
<listitem>
<simpara>Character</simpara>
</listitem>
<listitem>
<simpara>Byte</simpara>
</listitem>
<listitem>
<simpara>Short</simpara>
</listitem>
<listitem>
<simpara>LocalDate</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For any other data types, use the MVEL expression with the prefix <literal>#</literal>.</simpara>
</note>
<simpara>Follow the BigDecimal example in the test scenario designer to use the <literal>#</literal> prefix to set the java expression:</simpara>
<itemizedlist>
<listitem>
<simpara>Enter <literal># java.math.BigDecimal.valueOf(10)</literal> for the <emphasis role="strong">GIVEN</emphasis> column value.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal># actualValue.intValue() == 10</literal> for the <emphasis role="strong">EXPECT</emphasis> column value.</simpara>
</listitem>
</itemizedlist>
<simpara>You can refer to the actual value of the <emphasis role="strong">EXPECT</emphasis> column in the java expression to execute a condition.</simpara>
<simpara>The following rule-based test scenario definition expressions are supported by the test scenarios designer:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Description of expressions syntax</title>
<?dbhtml table-width=""?>
<?dbfo table-width=""?>
<?dblatex table-width=""?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="142*"/>
<colspec colname="col_2" colwidth="283*"/>
<thead>
<row>
<entry align="left" valign="top">Operator</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>=</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies equal to a value. This is default for all columns and is the only operator supported by the GIVEN column.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>=, =!, &lt;&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies inequality of a value. This operator can be combined with other operators.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt;, &gt;, &lt;=, &gt;=</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a comparison: less than, greater than, less or equals than, and greater or equals than.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>#</simpara></entry>
<entry align="left" valign="top"><simpara>This operator is used to set the java expression value to a property header cell which can be executed as a java method.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>[value1, value2, value3]</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a list of values. If one or more values are valid, the scenario definition is evaluated as true.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>expression1; expression2; expression3</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a list of expressions. If all expressions are valid, the scenario definition is evaluated as true.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>An empty cell is skipped from evaluation. To define an empty string, use <literal>=</literal>,<literal>[]</literal>, or <literal>;</literal>. To define a null value, use <literal>null</literal>.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Example expressions</title>
<?dbhtml table-width=""?>
<?dbfo table-width=""?>
<?dblatex table-width=""?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="77*"/>
<colspec colname="col_2" colwidth="348*"/>
<thead>
<row>
<entry align="left" valign="top">Expression</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is equal to -1.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt; 0</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is less than 0.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>! &gt; 0</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is not greater than 0.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>[-1, 0, 1]</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is equal to either -1 or 0 or 1.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt;&gt; [1, -1]</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is neither equal to 1 nor -1.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>! 100; 0</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is not equal to 100 but is equal to 0.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>!= &lt; 0; &lt;&gt; &gt; 1</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is neither less than 0 nor greater than 1.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt;&gt; &lt;= 0; &gt;= 1</simpara></entry>
<entry align="left" valign="top"><simpara>The actual value is neither less than 0 nor equal to 0 but is greater than or equal to 1.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>You can refer to the supported commands and syntax in the <emphasis role="strong">Scenario Cheatsheet</emphasis> tab on the right of the rule-based test scenarios designer.</simpara>
</note>
</section>
<section xml:id="test-designer-expressions-syntax-dmn-based-ref">
<title>Expression syntax in DMN-based scenarios</title>
<simpara>The following data types are supported by the DMN-based test scenarios in the test scenarios designer:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Data types supported by DMN-based scenarios</title>
<?dbhtml table-width=""?>
<?dbfo table-width=""?>
<?dblatex table-width=""?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="142*"/>
<colspec colname="col_2" colwidth="283*"/>
<thead>
<row>
<entry align="left" valign="top">Supported data types</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>numbers &amp; strings</simpara></entry>
<entry align="left" valign="top"><simpara>Strings must be delimited by quotation marks, for example, <literal>"John Doe"</literal>, <literal>"Brno"</literal> or <literal>""</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>boolean values</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>, <literal>false</literal>, and <literal>null</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>dates and time</simpara></entry>
<entry align="left" valign="top"><simpara>For example, <literal>date("2019-05-13")</literal> or <literal>time("14:10:00+02:00")</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>functions</simpara></entry>
<entry align="left" valign="top"><simpara>Supports built-in math functions, for example, <literal>avg</literal>, <literal>max</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>contexts</simpara></entry>
<entry align="left" valign="top"><simpara>For example, <literal>{x : 5, y : 3}</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ranges and lists</simpara></entry>
<entry align="left" valign="top"><simpara>For example, <literal>[1 .. 10]</literal> or <literal>[2, 3, 4, 5]</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>You can refer to the supported commands and syntax in the <emphasis role="strong">Scenario Cheatsheet</emphasis> tab on the right of the DMN-based test scenarios designer.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="test-designer-run-test-proc">
<title>Running the test scenarios</title>
<simpara>After creating a test scenario template and defining the test scenarios, you can run the tests to validate your business rules and data.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To run defined test scenarios, do any of the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>To execute all the available test scenarios in your project inside multiple assets, in the upper-right corner of your project page, click <emphasis role="strong">Test</emphasis>.</simpara>
<figure>
<title>Run all the test scenarios from the project view</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/AuthoringAssets/test-scenarios-run-all-tests-button.png"/>
</imageobject>
<textobject><phrase>Run all the test scenarios from the project view</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>To execute all available test scenarios defined in a <literal>.scesim</literal> file, at the top of the Test Scenario designer, click the <emphasis role="strong">Run Test</emphasis> <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/AuthoringAssets/test-scenarios-run-test-icon.png"/>
</imageobject>
<textobject><phrase>Run Test icon</phrase></textobject>
</inlinemediaobject> icon.</simpara>
</listitem>
<listitem>
<simpara>To run a single test scenario defined in a single <literal>.scesim</literal> file, right-click the row of the test scenario you want to run and select <emphasis role="strong">Run scenario</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Test Report</emphasis> panel displays the overview of the tests and the scenario status.</simpara>
<simpara>After the tests execute, if the values entered in the test scenario table do not match with the expected values, then the corresponding cells are highlighted.</simpara>
</listitem>
<listitem>
<simpara>If tests fail, you can do the following tasks to troubleshoot the failure:</simpara>
<itemizedlist>
<listitem>
<simpara>To review the error message in the pop-up window, hover your mouse cursor over the highlighted cell.</simpara>
</listitem>
<listitem>
<simpara>To open the <emphasis role="strong">Alerts</emphasis> panel at the bottom of the designer or the project view for the error messages, click <emphasis role="strong">View Alerts</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Make the necessary changes and run the test again until the scenario passes.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="test-scenarios-running-locally-proc">
<title>Running a test scenario locally</title>
<simpara>In Red Hat Decision Manager, you can either run the test scenarios directly in Business Central or locally using the command line.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>On the Project’s home page, select the <emphasis role="strong">Settings</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">git</emphasis> <emphasis role="strong">URL</emphasis> and click the <emphasis role="strong">Clipboard</emphasis> <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/AuthoringAssets/test-scenarios-clipboard-icon.png"/>
</imageobject>
<textobject><phrase>Copy to clipboard icon</phrase></textobject>
</inlinemediaobject> to copy the git url.</simpara>
</listitem>
<listitem>
<simpara>Open a command terminal and navigate to the directory where you want to clone the git project.</simpara>
</listitem>
<listitem>
<simpara>Run the following command:</simpara>
<screen>git clone your_git_project_url</screen>
<simpara>Replace <literal>your_git_project_url</literal> with relevant data like <literal>git://localhost:9418/MySpace/ProjectTestScenarios</literal>.</simpara>
</listitem>
<listitem>
<simpara>Once the project is successfully cloned, navigate to the git project directory and execute the following command:</simpara>
<screen>mvn clean test</screen>
<simpara>Your project’s build information and the test results (such as, the number of tests run and whether the test run was a success or not) are displayed in the command terminal. In case of failures, make the necessary changes in Business Central, pull the changes and run the command again.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="test-designer-test-scenario-export-import-spreadsheet-con">
<title>Exporting and importing test scenario spreadsheets</title>
<simpara>These sections show how to export and import test scenario spreadsheets in the test scenario designer. You can analyze and manage test scenario spreadsheets with software such as Microsoft Excel or LibreOffice Calc. Test scenario designer supports the <literal>.CSV</literal> file format. For more information about the RFC specification for the Comma-Separated Values (CSV) format, see <link xlink:href="https://tools.ietf.org/html/rfc4180">Common Format and MIME Type for Comma-Separated Values (CSV) Files</link>.</simpara>
<section xml:id="test-designer-test-scenario-export-spreadsheet-proc">
<title>Exporting a test scenario spreadsheet</title>
<simpara>Follow the procedure below to export a test scenario spreadsheet using the Test Scenario designer.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the Test Scenario designer toolbar on the upper-right, click <emphasis role="strong">Export</emphasis> <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/AuthoringAssets/test-scenarios-export-button.png"/>
</imageobject>
<textobject><phrase>test scenarios export button</phrase></textobject>
</inlinemediaobject> button.</simpara>
</listitem>
<listitem>
<simpara>Select a destination in your local file directory and confirm to save the <literal>.CSV</literal> file.</simpara>
</listitem>
</orderedlist>
<simpara>The <literal>.CSV</literal> file is exported to your local machine.</simpara>
</section>
<section xml:id="test-designer-test-scenario-import-spreadsheet-proc">
<title>Importing a test scenario spreadsheet</title>
<simpara>Follow the procedure below to import a test scenario spreadsheet using the Test Scenario designer.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the Test Scenario designer toolbar on the upper-right, click <emphasis role="strong">Import</emphasis> <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/AuthoringAssets/test-scenarios-import-button.png"/>
</imageobject>
<textobject><phrase>test scenarios import button</phrase></textobject>
</inlinemediaobject> button.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Select file to Import</emphasis> prompt, click <emphasis role="strong">Choose File…​</emphasis> and select the <literal>.CSV</literal> file you would like to import from your local file directory.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Import</emphasis>.</simpara>
</listitem>
</orderedlist>
<simpara>The <literal>.CSV</literal> file is imported to the Test Scenario designer.</simpara>
<warning>
<simpara>You must not modify the headers in the selected <literal>.CSV</literal> file. Otherwise, the spreadsheet may not be successfully imported.</simpara>
</warning>
</section>
</chapter>
<chapter xml:id="test-scenarios-coverage-report-con">
<title>Coverage reports for test scenarios</title>
<simpara>The test scenario designer provides a clear and coherent way of displaying the test coverage statistics using the <emphasis role="strong">Coverage Report</emphasis> tab on the right side of the test scenario designer. You can also download the coverage report to view and analyze the test coverage statistics. Downloaded test scenario coverage report supports the <literal>.CSV</literal> file format. For more information about the RFC specification for the Comma-Separated Values (CSV) format, see <link xlink:href="https://tools.ietf.org/html/rfc4180">Common Format and MIME Type for Comma-Separated Values (CSV) Files</link>.</simpara>
<simpara>You can view the coverage report for rule-based and DMN-based test scenarios.</simpara>
<section xml:id="test-scenarios-coverage-report-rule-based-proc">
<title>Generating coverage reports for rule-based test scenarios</title>
<simpara>In rule-based test scenarios, the <emphasis role="strong">Coverage Report</emphasis> tab contains the detailed information about the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Number of available rules</simpara>
</listitem>
<listitem>
<simpara>Number of fired rules</simpara>
</listitem>
<listitem>
<simpara>Percentage of fired rules</simpara>
</listitem>
<listitem>
<simpara>Percentage of executed rules represented as a pie chart</simpara>
</listitem>
<listitem>
<simpara>Number of times each rule has executed</simpara>
</listitem>
<listitem>
<simpara>The rules that are executed for each defined test scenario</simpara>
</listitem>
</itemizedlist>
<simpara>Follow the procedure to generate a coverage report for rule-based test scenarios:</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The rule-based test scenario template are created for the selected test scenario. For more information about creating rule-based test scenarios, see <xref linkend="test-designer-create-test-template-rule-based-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>The individual test scenarios are defined. For more information about defining a test scenario, see <xref linkend="test-designer-test-scenario-definition-proc"/>.</simpara>
<note>
<simpara>To generate the coverage report for rule-based test scenario, you must create at least one rule.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the rule-based test scenarios in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara>Run the defined test scenarios.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Coverage Report</emphasis> on the right of the test scenario designer to display the test coverage statistics.</simpara>
</listitem>
<listitem>
<simpara>Optional: To download the test scenario coverage report, Click <emphasis role="strong">Download report</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-scenarios-coverage-report-dmn-based-proc">
<title>Generating coverage reports for DMN-based test scenarios</title>
<simpara>In DMN-based test scenarios, the <emphasis role="strong">Coverage Report</emphasis> tab contains the detailed information about the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Number of available decisions</simpara>
</listitem>
<listitem>
<simpara>Number of executed decisions</simpara>
</listitem>
<listitem>
<simpara>Percentage of executed decisions</simpara>
</listitem>
<listitem>
<simpara>Percentage of executed decisions represented as a pie chart</simpara>
</listitem>
<listitem>
<simpara>Number of times each decision has executed</simpara>
</listitem>
<listitem>
<simpara>Decisions that are executed for each defined test scenario</simpara>
</listitem>
</itemizedlist>
<simpara>Follow the procedure to generate a coverage report for DMN-based test scenarios:</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The DMN-based test scenario template is created for the selected test scenario. For more information about creating DMN-based test scenarios, see <xref linkend="test-designer-create-test-template-dmn-based-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>The individual test scenarios are defined. For more information about defining a test scenario, see <xref linkend="test-designer-test-scenario-definition-proc"/>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the DMN-based test scenarios in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara>Run the defined test scenarios.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Coverage Report</emphasis> on the right of the test scenario designer to display the test coverage statistics.</simpara>
</listitem>
<listitem>
<simpara>Optional: To download the test scenario coverage report, Click <emphasis role="strong">Download report</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="test-scenarios-execution-rest-api-proc">
<title>Executing a test scenario using the KIE Server REST API</title>
<simpara>Directly interacting with the REST endpoints of KIE Server provides the most separation between the calling code and the decision logic definition.
You can use the KIE Server REST API to execute the test scenarios externally. It executes the test scenarios against the deployed project.</simpara>
<note>
<simpara>This functionality is disabled by default, use <literal>org.kie.scenariosimulation.server.ext.disabled</literal> system property to enable it.</simpara>
</note>
<simpara>For more information about the KIE Server REST API, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-kie-apis"><emphasis>Interacting with Red Hat Decision Manager using KIE APIs</emphasis></link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>KIE Server is installed and configured, including a known user name and credentials for a user with the <literal>kie-server</literal> role. For installation options, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/installing_and_configuring_red_hat_decision_manager#assembly-planning"><emphasis>Planning a Red Hat Decision Manager installation</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>You have built the project as a KJAR artifact and deployed it to KIE Server.</simpara>
</listitem>
<listitem>
<simpara>You have the ID of the KIE container.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Determine the base URL for accessing the KIE Server REST API endpoints. This requires knowing the following values (with the default local deployment values as an example):</simpara>
<itemizedlist>
<listitem>
<simpara>Host (<literal>localhost</literal>)</simpara>
</listitem>
<listitem>
<simpara>Port (<literal>8080</literal>)</simpara>
</listitem>
<listitem>
<simpara>Root context (<literal>kie-server</literal>)</simpara>
</listitem>
<listitem>
<simpara>Base REST path (<literal>services/rest/</literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>Example base URL in local deployment for the traffic violations project:</simpara>
<simpara><literal>http://localhost:8080/kie-server/services/rest/server/containers/traffic_1.0.0-SNAPSHOT</literal></simpara>
</listitem>
<listitem>
<simpara>Determine user authentication requirements.</simpara>
<simpara>When users are defined directly in the KIE Server configuration, HTTP Basic authentication is used and requires the user name and password. Successful requests require that the user have the <literal>kie-server</literal> role.</simpara>
<simpara>The following example demonstrates how to add credentials to a curl request:</simpara>
<screen>curl -u username:password &lt;request&gt;</screen>
<simpara>If KIE Server is configured with Red Hat Single Sign-On, the request must include a bearer token:</simpara>
<programlisting language="java" linenumbering="unnumbered">curl -H "Authorization: bearer $TOKEN" &lt;request&gt;</programlisting>
</listitem>
<listitem>
<simpara>Specify the format of the request and response. The REST API endpoints work with XML format and are set using request headers:</simpara>
<formalpara>
<title>XML</title>
<para>
<screen>curl -H "accept: application/xml" -H "content-type: application/xml"</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Execute the test scenario:</simpara>
<simpara><emphasis role="strong">[POST]</emphasis> <literal>server/containers/{containerId}/scesim</literal></simpara>
<simpara>Example curl request:</simpara>
<screen>curl -X POST "http://localhost:8080/kie-server/services/rest/server/containers/traffic_1.0.0-SNAPSHOT/scesim"\ -u 'wbadmin:wbadmin;' \ -H "accept: application/xml" -H "content-type: application/xml"\ -d @Violation.scesim</screen>
<simpara>Example XML request:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;ScenarioSimulationModel version="1.8"&gt;
  &lt;simulation&gt;
    &lt;scesimModelDescriptor&gt;
      &lt;factMappings&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements/&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;Index&lt;/name&gt;
            &lt;type&gt;OTHER&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;#&lt;/name&gt;
            &lt;className&gt;java.lang.Integer&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;java.lang.Integer&lt;/className&gt;
          &lt;factAlias&gt;#&lt;/factAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;70.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements/&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;Description&lt;/name&gt;
            &lt;type&gt;OTHER&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Scenario description&lt;/name&gt;
            &lt;className&gt;java.lang.String&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;java.lang.String&lt;/className&gt;
          &lt;factAlias&gt;Scenario description&lt;/factAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;300.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Driver&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Points&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|1&lt;/name&gt;
            &lt;type&gt;GIVEN&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Driver&lt;/name&gt;
            &lt;className&gt;Driver&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;number&lt;/className&gt;
          &lt;factAlias&gt;Driver&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Points&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Violation&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Type&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|6&lt;/name&gt;
            &lt;type&gt;GIVEN&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Violation&lt;/name&gt;
            &lt;className&gt;Violation&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;Type&lt;/className&gt;
          &lt;factAlias&gt;Violation&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Type&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Violation&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Speed Limit&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|7&lt;/name&gt;
            &lt;type&gt;GIVEN&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Violation&lt;/name&gt;
            &lt;className&gt;Violation&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;number&lt;/className&gt;
          &lt;factAlias&gt;Violation&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Speed Limit&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Violation&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Actual Speed&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|8&lt;/name&gt;
            &lt;type&gt;GIVEN&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Violation&lt;/name&gt;
            &lt;className&gt;Violation&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;number&lt;/className&gt;
          &lt;factAlias&gt;Violation&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Actual Speed&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Fine&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Points&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|11&lt;/name&gt;
            &lt;type&gt;EXPECT&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Fine&lt;/name&gt;
            &lt;className&gt;Fine&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;number&lt;/className&gt;
          &lt;factAlias&gt;Fine&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Points&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Fine&lt;/step&gt;
            &lt;/ExpressionElement&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Amount&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|12&lt;/name&gt;
            &lt;type&gt;EXPECT&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Fine&lt;/name&gt;
            &lt;className&gt;Fine&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;number&lt;/className&gt;
          &lt;factAlias&gt;Fine&lt;/factAlias&gt;
          &lt;expressionAlias&gt;Amount&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements&gt;
            &lt;ExpressionElement&gt;
              &lt;step&gt;Should the driver be suspended?&lt;/step&gt;
            &lt;/ExpressionElement&gt;
          &lt;/expressionElements&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;0|13&lt;/name&gt;
            &lt;type&gt;EXPECT&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Should the driver be suspended?&lt;/name&gt;
            &lt;className&gt;Should the driver be suspended?&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;string&lt;/className&gt;
          &lt;factAlias&gt;Should the driver be suspended?&lt;/factAlias&gt;
          &lt;expressionAlias&gt;value&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
      &lt;/factMappings&gt;
    &lt;/scesimModelDescriptor&gt;
    &lt;scesimData&gt;
      &lt;Scenario&gt;
        &lt;factMappingValues&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Scenario description&lt;/name&gt;
              &lt;className&gt;java.lang.String&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;Description&lt;/name&gt;
              &lt;type&gt;OTHER&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;Above speed limit: 10km/h and 30 km/h&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Driver&lt;/name&gt;
              &lt;className&gt;Driver&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|1&lt;/name&gt;
              &lt;type&gt;GIVEN&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;10&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Violation&lt;/name&gt;
              &lt;className&gt;Violation&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|6&lt;/name&gt;
              &lt;type&gt;GIVEN&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;&amp;quot;speed&amp;quot;&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Violation&lt;/name&gt;
              &lt;className&gt;Violation&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|7&lt;/name&gt;
              &lt;type&gt;GIVEN&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;100&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Violation&lt;/name&gt;
              &lt;className&gt;Violation&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|8&lt;/name&gt;
              &lt;type&gt;GIVEN&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;120&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Fine&lt;/name&gt;
              &lt;className&gt;Fine&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|11&lt;/name&gt;
              &lt;type&gt;EXPECT&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;3&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Fine&lt;/name&gt;
              &lt;className&gt;Fine&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|12&lt;/name&gt;
              &lt;type&gt;EXPECT&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;500&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Should the driver be suspended?&lt;/name&gt;
              &lt;className&gt;Should the driver be suspended?&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;0|13&lt;/name&gt;
              &lt;type&gt;EXPECT&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;&amp;quot;No&amp;quot;&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;#&lt;/name&gt;
              &lt;className&gt;java.lang.Integer&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;Index&lt;/name&gt;
              &lt;type&gt;OTHER&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
            &lt;rawValue class="string"&gt;1&lt;/rawValue&gt;
          &lt;/FactMappingValue&gt;
        &lt;/factMappingValues&gt;
      &lt;/Scenario&gt;
    &lt;/scesimData&gt;
  &lt;/simulation&gt;
  &lt;background&gt;
    &lt;scesimModelDescriptor&gt;
      &lt;factMappings&gt;
        &lt;FactMapping&gt;
          &lt;expressionElements/&gt;
          &lt;expressionIdentifier&gt;
            &lt;name&gt;1|1&lt;/name&gt;
            &lt;type&gt;GIVEN&lt;/type&gt;
          &lt;/expressionIdentifier&gt;
          &lt;factIdentifier&gt;
            &lt;name&gt;Empty&lt;/name&gt;
            &lt;className&gt;java.lang.Void&lt;/className&gt;
          &lt;/factIdentifier&gt;
          &lt;className&gt;java.lang.Void&lt;/className&gt;
          &lt;factAlias&gt;Instance 1&lt;/factAlias&gt;
          &lt;expressionAlias&gt;PROPERTY 1&lt;/expressionAlias&gt;
          &lt;factMappingValueType&gt;NOT_EXPRESSION&lt;/factMappingValueType&gt;
          &lt;columnWidth&gt;114.0&lt;/columnWidth&gt;
        &lt;/FactMapping&gt;
      &lt;/factMappings&gt;
    &lt;/scesimModelDescriptor&gt;
    &lt;scesimData&gt;
      &lt;BackgroundData&gt;
        &lt;factMappingValues&gt;
          &lt;FactMappingValue&gt;
            &lt;factIdentifier&gt;
              &lt;name&gt;Empty&lt;/name&gt;
              &lt;className&gt;java.lang.Void&lt;/className&gt;
            &lt;/factIdentifier&gt;
            &lt;expressionIdentifier&gt;
              &lt;name&gt;1|1&lt;/name&gt;
              &lt;type&gt;GIVEN&lt;/type&gt;
            &lt;/expressionIdentifier&gt;
          &lt;/FactMappingValue&gt;
        &lt;/factMappingValues&gt;
      &lt;/BackgroundData&gt;
    &lt;/scesimData&gt;
  &lt;/background&gt;
  &lt;settings&gt;
    &lt;dmnFilePath&gt;src/main/resources/org/kie/example/traffic/traffic_violation/Traffic Violation.dmn&lt;/dmnFilePath&gt;
    &lt;type&gt;DMN&lt;/type&gt;
    &lt;fileName&gt;&lt;/fileName&gt;
    &lt;dmnNamespace&gt;https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF&lt;/dmnNamespace&gt;
    &lt;dmnName&gt;Traffic Violation&lt;/dmnName&gt;
    &lt;skipFromBuild&gt;false&lt;/skipFromBuild&gt;
    &lt;stateless&gt;false&lt;/stateless&gt;
  &lt;/settings&gt;
  &lt;imports&gt;
    &lt;imports/&gt;
  &lt;/imports&gt;
&lt;/ScenarioSimulationModel&gt;</programlisting>
<simpara>Example XML response:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;response type="SUCCESS" msg="Test Scenario successfully executed"&gt;
      &lt;scenario-simulation-result&gt;
            &lt;run-count&gt;5&lt;/run-count&gt;
            &lt;ignore-count&gt;0&lt;/ignore-count&gt;
            &lt;run-time&gt;31&lt;/run-time&gt;
      &lt;/scenario-simulation-result&gt;
&lt;/response&gt;</programlisting>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="test-designer-create-mortgages-example-proc">
<title>Creating test scenario using the sample Mortgages project</title>
<simpara>This chapter illustrates creating and executing a test scenario from the sample <emphasis role="strong">Mortgages</emphasis> project shipped with Business Central using the test scenario designer. The test scenario example in this chapter is based on the <emphasis role="strong">Pricing loans</emphasis> guided decision table from the <emphasis role="strong">Mortgages</emphasis> project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click <emphasis role="strong">Mortgages</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If the project is not listed under <emphasis role="strong">Projects</emphasis>, from <emphasis role="strong">MySpace</emphasis>, click <emphasis role="strong">Try Samples</emphasis> → <emphasis role="strong">Mortgages</emphasis> → <emphasis role="strong">OK</emphasis>.</simpara>
<simpara>The Assets window appears.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Test Scenario</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>scenario_pricing_loans</literal> as the <emphasis role="strong">Test Scenario</emphasis> name and select the default <literal>mortgages.mortgages</literal> package from the <emphasis role="strong">Package</emphasis> drop-down list.</simpara>
<simpara>The package you select must contain all the required rule assets.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">RULE</emphasis> as the <emphasis role="strong">Source type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create and open the test scenario in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara>Expand <emphasis role="strong">Project Explorer</emphasis> and verify the following:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Applicant</literal>, <literal>Bankruptcy</literal>, <literal>IncomeSource</literal>, and <literal>LoanApplication</literal> data objects exist.</simpara>
</listitem>
<listitem>
<simpara><literal>Pricing loans</literal> guided decision table exists.</simpara>
</listitem>
<listitem>
<simpara>Verify that the new test scenario is listed under <emphasis role="strong">Test Scenario</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After verifying that everything is in place, return to the <emphasis role="strong">Model</emphasis> tab of the test scenario designer and define the <emphasis role="strong">GIVEN</emphasis> and <emphasis role="strong">EXPECT</emphasis> data for the scenario, based on the available data objects.</simpara>
<figure>
<title>A blank test scenario designer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenarios-blank-preview-editor.png"/>
</imageobject>
<textobject><phrase>test scenarios blank preview editor</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Define the <emphasis role="strong">GIVEN</emphasis> column details:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the cell named <emphasis role="strong">INSTANCE 1</emphasis> under the <emphasis role="strong">GIVEN</emphasis> column header.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To create properties for the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required. For this example, you need to create two more property cells under the <emphasis role="strong">GIVEN</emphasis> column.</simpara>
</listitem>
<listitem>
<simpara>Select the first property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">amount</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object field to the property header cell.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the second property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">deposit</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the third property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">lengthYears</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Right-click the <emphasis role="strong">LoanApplication</emphasis> header cell and select <emphasis role="strong">Insert column right</emphasis>. A new <emphasis role="strong">GIVEN</emphasis> column to the right is created.</simpara>
</listitem>
<listitem>
<simpara>Select the new header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select the <emphasis role="strong">IncomeSource</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object to the header cell.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the property header cell below <emphasis role="strong">IncomeSource</emphasis>:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">IncomeSource</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object field to the property header cell.</simpara>
<simpara>You have now defined all the <emphasis role="strong">GIVEN</emphasis> column cells.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Next, define the <emphasis role="strong">EXPECT</emphasis> column details:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the cell named <emphasis role="strong">INSTANCE 2</emphasis> under the <emphasis role="strong">EXPECT</emphasis> column header.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To create properties for the data object, right-click the property header cell and select <emphasis role="strong">Insert column right</emphasis> or <emphasis role="strong">Insert column left</emphasis> as required. Create two more property cells under the <emphasis role="strong">EXPECT</emphasis> column.</simpara>
</listitem>
<listitem>
<simpara>Select the first property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">approved</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object field to the property header cell.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the second property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">insuranceCost</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object field to the property header cell.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the third property header cell:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Test Tools</emphasis> panel, select and expand the <emphasis role="strong">LoanApplication</emphasis> data object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">approvedRate</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Insert Data Object</emphasis> to map the data object field to the property header cell.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To define the test scenario, enter the following data in the first row:</simpara>
<itemizedlist>
<listitem>
<simpara>Enter <literal>Row 1 test scenario</literal> as the <emphasis role="strong">Scenario Description</emphasis>, <literal>150000</literal> as the <emphasis role="strong">amount</emphasis>, <literal>19000</literal> as the <emphasis role="strong">deposit</emphasis>, <literal>30</literal> as the <emphasis role="strong">lengthYears</emphasis>, and <literal>Asset</literal> as the <emphasis role="strong">type</emphasis> for the <emphasis role="strong">GIVEN</emphasis> column values.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>true</literal> as <emphasis role="strong">approved</emphasis>, <literal>0</literal> as the <emphasis role="strong">insuranceCost</emphasis> and <literal>2</literal> as the <emphasis role="strong">approvedRate</emphasis> for the <emphasis role="strong">EXPECT</emphasis> column values.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Next enter the following data in the second row:</simpara>
<itemizedlist>
<listitem>
<simpara>Enter <literal>Row 2 test scenario</literal> as the <emphasis role="strong">Scenario Description</emphasis>, <literal>100002</literal> as the <emphasis role="strong">amount</emphasis>, <literal>2999</literal> as the <emphasis role="strong">deposit</emphasis>, <literal>20</literal> as the <emphasis role="strong">lengthYears</emphasis>, and <literal>Job</literal> as the <emphasis role="strong">type</emphasis> for the <emphasis role="strong">GIVEN</emphasis> column values.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>true</literal> as <emphasis role="strong">approved</emphasis>, <literal>10</literal> as the <emphasis role="strong">insuranceCost</emphasis> and <literal>6</literal> as the <emphasis role="strong">approvedRate</emphasis> for the <emphasis role="strong">EXPECT</emphasis> column values.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After you have defined all <emphasis role="strong">GIVEN</emphasis>, <emphasis role="strong">EXPECT</emphasis>, and other data for the scenario, click <emphasis role="strong">Save</emphasis> in the test scenario designer to save your work.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Run Test</emphasis> in the upper-right corner to run the <literal>.scesim</literal> file.</simpara>
<simpara>The test result is displayed in the <emphasis role="strong">Test Report</emphasis> panel. Click <emphasis role="strong">View Alerts</emphasis> to display messages from the <emphasis role="strong">Alerts</emphasis> section. If a test fails, refer to the messages in the <emphasis role="strong">Alerts</emphasis> section at the bottom of the window, review and correct all components in the scenario, and try again to validate the scenario until the scenario passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the test scenario designer to save your work after you have made all necessary changes.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="test-scenarios-legacy-designer-con">
<title>Test scenarios (legacy) designer in Business Central</title>
<simpara>Red Hat Decision Manager currently supports both the new <emphasis role="strong">Test Scenarios</emphasis> designer and the former <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer. The default designer is the new test scenarios designer, which supports testing of both rules and DMN models and provides an enhanced overall user experience with test scenarios. If required, you can continue to use the legacy test scenarios designer, which supports rule-based test scenarios only.</simpara>
<section xml:id="test-scenarios-legacy-create-proc">
<title>Creating and running a test scenario (legacy)</title>
<simpara>You can create test scenarios in Business Central to test the functionality of business rule data before deployment. A basic test scenario must have at least the following data:</simpara>
<itemizedlist>
<listitem>
<simpara>Related data objects</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">GIVEN</emphasis> facts</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">EXPECT</emphasis> results</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The legacy test scenarios designer supports the <literal>LocalDate</literal> java built-in data type. You can use the <literal>LocalDate</literal> java built-in data type in the <literal>dd-mmm-yyyy</literal> date format. For example, you can set this in the <literal>17-Oct-2020</literal> date format.</simpara>
</note>
<simpara>With this data, the test scenario can validate the expected and actual results for that rule instance based on the defined facts. You can also add a <emphasis role="strong">CALL METHOD</emphasis> and any available <emphasis role="strong">globals</emphasis> to a test scenario, but these scenario settings are optional.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In Business Central, go to <emphasis role="strong">Menu</emphasis> → <emphasis role="strong">Design</emphasis> → <emphasis role="strong">Projects</emphasis> and click the project name.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis> → <emphasis role="strong">Test Scenarios (Legacy)</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter an informative <emphasis role="strong">Test Scenario</emphasis> name and select the appropriate <emphasis role="strong">Package</emphasis>. The package that you specify must be the same package where the required rule assets have been assigned or will be assigned. You can import data objects from any package into the asset’s designer.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Ok</emphasis> to create the test scenario.</simpara>
<simpara>The new test scenario is now listed in the <emphasis role="strong">Test Scenarios</emphasis> panel of the <emphasis role="strong">Project Explorer</emphasis>,</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Data Objects</emphasis> tab to verify that all data objects required for the rules that you want to test are listed. If not, click <emphasis role="strong">New item</emphasis> to import the needed data objects from other packages, or
<link linkend="data-objects-create-proc_test-scenarios">create data objects</link>
within your package.</simpara>
</listitem>
<listitem>
<simpara>After all data objects are in place, return to the <emphasis role="strong">Model</emphasis> tab of the test scenarios designer and define the <emphasis role="strong">GIVEN</emphasis> and <emphasis role="strong">EXPECT</emphasis> data for the scenario, based on the available data objects.</simpara>
<figure>
<title>The test scenarios designer</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenario-edit.png"/>
</imageobject>
<textobject><phrase>test scenario edit</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <emphasis role="strong">GIVEN</emphasis> section defines the input facts for the test. For example, if an <literal>Underage</literal> rule in the project declines loan applications for applicants under the age of 21, then the <emphasis role="strong">GIVEN</emphasis> facts in the test scenario could be <literal>Applicant</literal> with <literal>age</literal> set to some integer less than 21.</simpara>
<simpara>The <emphasis role="strong">EXPECT</emphasis> section defines the expected results based on the <emphasis role="strong">GIVEN</emphasis> input facts. That is, <emphasis role="strong">GIVEN</emphasis> the input facts, <emphasis role="strong">EXPECT</emphasis> these other facts to be valid or entire rules to be activated. For example, with the given facts of an applicant under the age of 21 in the scenario, the <emphasis role="strong">EXPECT</emphasis> results could be <literal>LoanApplication</literal> with <literal>approved</literal> set to <literal>false</literal> (as a result of the underage applicant), or could be the activation of the <literal>Underage</literal> rule as a whole.</simpara>
</listitem>
<listitem>
<simpara>Optional: Add a <emphasis role="strong">CALL METHOD</emphasis> and any <emphasis role="strong">globals</emphasis> to the test scenario:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">CALL METHOD:</emphasis> Use this to invoke a method from another fact when the rule execution is initiated. Click <emphasis role="strong">CALL METHOD</emphasis>, select a fact, and click <inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/6187.png"/>
</imageobject>
<textobject><phrase>6187</phrase></textobject>
</inlinemediaobject> to select the method to invoke. You can invoke any Java class methods (such as methods from an ArrayList) from the Java library or from a JAR that was imported for the project (if applicable).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">globals:</emphasis> Use this to add any global variables in the project that you want to validate in the test scenario. Click <emphasis role="strong">globals</emphasis> to select the variable to be validated, and then in the test scenarios designer, click the global name and define field values to be applied to the global variable. If no global variables are available, then they must be created as new assets in Business Central. Global variables are named objects that are visible to the decision engine but are different from the objects for facts. Changes in the object of a global do not trigger the re-evaluation of rules.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">More</emphasis> at the bottom of the test scenarios designer to add other data blocks to the same scenario file as needed.</simpara>
</listitem>
<listitem>
<simpara>After you have defined all <emphasis role="strong">GIVEN</emphasis>, <emphasis role="strong">EXPECT</emphasis>, and other data for the scenario, click <emphasis role="strong">Save</emphasis> in the test scenarios designer to save your work.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Run scenario</emphasis> in the upper-right corner to run this <literal>.scenario</literal> file, or click <emphasis role="strong">Run all scenarios</emphasis> to run all saved <literal>.scenario</literal> files in the project package (if there are multiple). Although the <emphasis role="strong">Run scenario</emphasis> option does not require the individual <literal>.scenario</literal> file to be saved, the <emphasis role="strong">Run all scenarios</emphasis> option does require all <literal>.scenario</literal> files to be saved.</simpara>
<simpara>If the test fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> message at the bottom of the window, review all components in the scenario, and try again to validate the scenario until the scenario passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the test scenarios designer to save your work after all changes are complete.</simpara>
</listitem>
</orderedlist>
<section xml:id="test-scenarios-legacy-GIVEN-proc">
<title>Adding GIVEN facts in test scenarios (legacy)</title>
<simpara>The <emphasis role="strong">GIVEN</emphasis> section defines input facts for the test. For example, if an <literal>Underage</literal> rule in the project declines loan applications for applicants under the age of 21, then the <emphasis role="strong">GIVEN</emphasis> facts in the test scenario could be <literal>Applicant</literal> with <literal>age</literal> set to some integer less than 21.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your test scenario have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer, click <emphasis role="strong">GIVEN</emphasis> to open the <emphasis role="strong">New input</emphasis> window with the available facts.</simpara>
<figure>
<title>Add GIVEN input to the test scenario</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenario-facts.png"/>
</imageobject>
<textobject><phrase>Add GIVEN input to the test scenario</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes the following options, depending on the data objects available in the <emphasis role="strong">Data Objects</emphasis> tab of the test scenarios designer:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Insert a new fact:</emphasis> Use this to add a fact and modify its field values. Enter a variable for the fact as the <emphasis role="strong">Fact name</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Modify an existing fact:</emphasis> (Appears only after another fact has been added.) Use this to specify a previously inserted fact to be modified in the decision engine between executions of the scenario.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete an existing fact:</emphasis> (Appears only after another fact has been added.) Use this to specify a previously inserted fact to be deleted from the decision engine between executions of the scenario.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Activate rule flow group:</emphasis> Use this to specify a rule flow group to be activated so that all rules within that group can be tested.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose a fact for the desired input option and click <emphasis role="strong">Add</emphasis>. For example, set <emphasis role="strong">Insert a new fact:</emphasis> to <emphasis role="strong">Applicant</emphasis> and enter <literal>a</literal> or <literal>app</literal> or any other variable for the <emphasis role="strong">Fact name</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the fact in the test scenarios designer and select the field to be modified.</simpara>
<figure>
<title>Modify a fact field</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenario-field.png"/>
</imageobject>
<textobject><phrase>Modifying a condition</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click the edit icon (<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/6191.png"/>
</imageobject>
<textobject><phrase>6191</phrase></textobject>
</inlinemediaobject>) and select from the following field values:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Literal value:</emphasis> Creates an open field in which you enter a specific literal value.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Bound variable:</emphasis> Sets the value of the field to the fact bound to a selected variable. The field type must match the bound variable type.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create new fact:</emphasis> Enables you to create a new fact and assign it as a field value of the parent fact. Then you can click the child fact in the test scenarios designer and likewise assign field values or nest other facts similarly.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Continue adding any other <emphasis role="strong">GIVEN</emphasis> input data for the scenario and click <emphasis role="strong">Save</emphasis> in the test scenarios designer to save your work.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="test-scenarios-legacy-EXPECT-proc">
<title>Adding EXPECT results in test scenarios (legacy)</title>
<simpara>The <emphasis role="strong">EXPECT</emphasis> section defines the expected results based on the <emphasis role="strong">GIVEN</emphasis> input facts. That is, <emphasis role="strong">GIVEN</emphasis> the input facts, <emphasis role="strong">EXPECT</emphasis> other specified facts to be valid or entire rules to be activated. For example, with the given facts of an applicant under the age of 21 in the scenario, the <emphasis role="strong">EXPECT</emphasis> results could be <literal>LoanApplication</literal> with <literal>approved</literal> set to <literal>false</literal> (as a result of the underage applicant), or could be the activation of the <literal>Underage</literal> rule as a whole.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All data objects required for your test scenario have been created or imported and are listed in the <emphasis role="strong">Data Objects</emphasis> tab of the <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Test Scenarios (Legacy)</emphasis> designer, click <emphasis role="strong">EXPECT</emphasis> to open the <emphasis role="strong">New expectation</emphasis> window with the available facts.</simpara>
<figure>
<title>Add EXPECT results to the test scenario</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenario-expected-rules.png"/>
</imageobject>
<textobject><phrase>Add EXPECT results to the test scenario</phrase></textobject>
</mediaobject>
</figure>
<simpara>The list includes the following options, depending on the data in the <emphasis role="strong">GIVEN</emphasis> section and the data objects available in the <emphasis role="strong">Data Objects</emphasis> tab of the test scenarios designer:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rule:</emphasis> Use this to specify a particular rule in the project that is expected to be activated as a result of the <emphasis role="strong">GIVEN</emphasis> input. Type the name of a rule that is expected to be activated or select it from the list of rules, and then in the test scenarios designer, specify the number of times the rule should be activated.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fact value:</emphasis> Use this to select a fact and define values for it that are expected to be valid as a result of the facts defined in the <emphasis role="strong">GIVEN</emphasis> section. The facts are listed by the <emphasis role="strong">Fact name</emphasis> previously defined for the <emphasis role="strong">GIVEN</emphasis> input.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Any fact that matches:</emphasis> Use this to validate that at least one fact with the specified values exists as a result of the <emphasis role="strong">GIVEN</emphasis> input.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose a fact for the desired expectation (such as <emphasis role="strong">Fact value:</emphasis> <literal>application</literal>) and click <emphasis role="strong">Add</emphasis> or <emphasis role="strong">OK</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the fact in the test scenarios designer and select the field to be added and modified.</simpara>
<figure>
<title>Modify a fact field</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/project-data/test-scenario-field-value.png"/>
</imageobject>
<textobject><phrase>Modify a fact field</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Set the field values to what is expected to be valid as a result of the <emphasis role="strong">GIVEN</emphasis> input (such as <literal>approved</literal> | <literal>equals</literal> | <literal>false</literal>).</simpara>
<note>
<simpara>In the legacy test scenarios designer, you can use <literal>["value1", "value2"]</literal> string format in the <emphasis role="strong">EXPECT</emphasis> field to validate the list of strings.</simpara>
</note>
</listitem>
<listitem>
<simpara>Continue adding any other <emphasis role="strong">EXPECT</emphasis> input data for the scenario and click <emphasis role="strong">Save</emphasis> in the test scenarios designer to save your work.</simpara>
</listitem>
<listitem>
<simpara>After you have defined and saved all <emphasis role="strong">GIVEN</emphasis>, <emphasis role="strong">EXPECT</emphasis>, and other data for the scenario, click <emphasis role="strong">Run scenario</emphasis> in the upper-right corner to run this <literal>.scenario</literal> file, or click <emphasis role="strong">Run all scenarios</emphasis> to run all saved <literal>.scenario</literal> files in the project package (if there are multiple). Although the <emphasis role="strong">Run scenario</emphasis> option does not require the individual <literal>.scenario</literal> file to be saved, the <emphasis role="strong">Run all scenarios</emphasis> option does require all <literal>.scenario</literal> files to be saved.</simpara>
<simpara>If the test fails, address any problems described in the <emphasis role="strong">Alerts</emphasis> message at the bottom of the window, review all components in the scenario, and try again to validate the scenario until the scenario passes.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> in the test scenarios designer to save your work after all changes are complete.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="test-scenarios-comparison-legacy-new-ref">
<title>Feature comparison of legacy and new test scenario designer</title>
<simpara>Red Hat Decision Manager supports both the new test scenario designer and the former test scenario (Legacy) designer.</simpara>
<simpara>The default designer is the new test scenario designer, which supports testing of both rules and DMN models, and provides an enhanced overall user experience with test scenarios. You can continue to use the legacy test scenario designer, which only supports rule-based test scenarios.</simpara>
<important>
<simpara>The new test scenario designer has an improved layout and feature set and continues to be developed. However, the legacy test scenario designer is deprecated with  Red Hat Decision Manager 7.3.0 and will be removed in a future Red Hat Decision Manager release.</simpara>
</important>
<simpara>The following table highlights the main features of legacy and new test scenario designer, which are supported in Red Hat Decision Manager to help you decide a suitable test scenario designer in your project.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>+</literal> indicates that the feature is present in the test scenario designer.</simpara>
</listitem>
<listitem>
<simpara><literal>-</literal> indicates that the feature is not present in the test scenario designer.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Main features of legacy and new test scenario designer</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="17*"/>
<colspec colname="col_3" colwidth="17*"/>
<colspec colname="col_4" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Feature &amp; highlights</entry>
<entry align="left" valign="top">New designer</entry>
<entry align="left" valign="top">Legacy designer</entry>
<entry align="left" valign="top">Documentation</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Creating and running a test scenario</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can create test scenarios in Business Central to test the functionality of business rule data before deployment.</simpara>
</listitem>
<listitem>
<simpara>A basic test scenario must have at least a related data objects, <emphasis role="strong">GIVEN</emphasis> facts, and <emphasis role="strong">EXPECT</emphasis> results.</simpara>
</listitem>
<listitem>
<simpara>You can run the tests to validate your business rules and data.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about creating rule and DMN-based test scenarios, see <xref linkend="test-designer-create-test-scenario-template-con"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about running the test scenarios, see <xref linkend="test-designer-run-test-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about creating and running test scenarios (legacy), see <xref linkend="test-scenarios-legacy-create-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Adding GIVEN facts in test scenarios</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can insert and verify the <emphasis role="strong">GIVEN</emphasis> facts for the test.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about adding <emphasis role="strong">GIVEN</emphasis> facts in new test scenario designer, see <xref linkend="test-designer-create-test-scenario-template-con"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about adding <emphasis role="strong">GIVEN</emphasis> facts in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-GIVEN-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Adding EXPECT results in test scenarios</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">EXPECT</emphasis> section defines the expected results based on the <emphasis role="strong">GIVEN</emphasis> input facts.</simpara>
</listitem>
<listitem>
<simpara>It represents the objects and their fields whose exact values are checked based on the provided information.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about adding <emphasis role="strong">EXPECT</emphasis> results in new test scenario designer, see <xref linkend="test-designer-create-test-scenario-template-con"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about adding <emphasis role="strong">EXPECT</emphasis> results in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-EXPECT-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">KIE session</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can set KIE session on test scenario level settings.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NA</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">KIE base on test scenario level</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can set KIE base on test scenario level settings.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>-</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NA</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">KIE base on project level</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can set KIE base on project level settings.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NA</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Simulated date and time</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can set a simulated date and time for the legacy test scenario designer.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>-</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>NA</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Rule flow group</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can specify a rule flow group to be activated to test all the rules within that group.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about setting rule flow group in new test scenarios, see <xref linkend="test-designer-global-settings-panel-rule-based-proc"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about setting rule flow group in test scenarios (legacy), <xref linkend="test-scenarios-legacy-GIVEN-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Global variables</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Global variables are named objects that are visible to the decision engine but are different from the objects for facts.</simpara>
</listitem>
<listitem>
<simpara>Setting global variables for new test scenario is deprecated .</simpara>
</listitem>
<listitem>
<simpara>In case you want to reuse data sets for different scenarios, you can use the <emphasis role="strong">Background</emphasis> instance.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>-</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about <emphasis role="strong">Background</emphasis> instance in new test scenarios, see <xref linkend="test-scenarios-background-instance-con"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about global variables in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-create-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Call method</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can use this to invoke a method from another fact when the rule execution is initiated.</simpara>
</listitem>
<listitem>
<simpara>You can invoke any Java class methods from the Java library or from a JAR that was imported for the project.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>For more information about calling a method in new test scenarios, see <xref linkend="test-designer-expressions-syntax-intro-ref"/>.</simpara>
</listitem>
<listitem>
<simpara>For more information about calling a method in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-create-proc"/>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Modify an existing fact</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can modify a previously inserted fact in the decision engine between executions of the scenario.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>-</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>For more information about modifying an existing fact in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-GIVEN-proc"/>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Bound variable</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>You can set the value of a field to the fact bound to a selected variable.</simpara>
</listitem>
<listitem>
<simpara>In the new test scenario designer, you can not define a variable inside a test scenario grid and reuse it inside <emphasis role="strong">GIVEN</emphasis> or <emphasis role="strong">EXPECTED</emphasis> cells.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>-</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>For more information about how to set bound variables in test scenarios (legacy), see <xref linkend="test-scenarios-legacy-GIVEN-proc"/>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter xml:id="next_steps_6" remap="_next_steps_6">
<title>Next steps</title>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</chapter>
</part>
<part xml:id="assembly-decision-engine">
<title>Decision engine in Red Hat Decision Manager</title>
<partintro>
<simpara>As a business rules developer, your understanding of the decision engine in Red Hat Decision Manager can help you design more effective business assets and a more scalable decision management architecture. The decision engine is the Red Hat Decision Manager component that stores, processes, and evaluates data to execute business rules and to reach the decisions that you define. This document describes basic concepts and functions of the decision engine to consider as you create your business rule system and decision services in Red Hat Decision Manager.</simpara>
</partintro>
<chapter xml:id="decision-engine-con_decision-engine">
<title>Decision engine in Red Hat Decision Manager</title>
<simpara>The decision engine is the rules engine in Red Hat Decision Manager. The decision engine stores, processes, and evaluates data to execute the business rules or decision models that you define. The basic function of the decision engine is to match incoming data, or <emphasis>facts</emphasis>, to the conditions of rules and determine whether and how to execute the rules.</simpara>
<simpara>The decision engine operates using the following basic components:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rules:</emphasis> Business rules or DMN decisions that you define. All rules must contain at a minimum the conditions that trigger the rule and the actions that the rule dictates.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Facts:</emphasis> Data that enters or changes in the decision engine that the decision engine matches to rule conditions to execute applicable rules.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Production memory:</emphasis> Location where rules are stored in the decision engine.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Working memory:</emphasis> Location where facts are stored in the decision engine.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Agenda:</emphasis> Location where activated rules are registered and sorted (if applicable) in preparation for execution.</simpara>
</listitem>
</itemizedlist>
<simpara>When a business user or an automated system adds or updates rule-related information in Red Hat Decision Manager, that information is inserted into the working memory of the decision engine in the form of one or more facts. The decision engine matches those facts to the conditions of the rules that are stored in the production memory to determine eligible rule executions. (This process of matching facts to rules is often referred to as <emphasis>pattern matching</emphasis>.) When rule conditions are met, the decision engine activates and registers rules in the agenda, where the decision engine then sorts prioritized or conflicting rules in preparation for execution.</simpara>
<simpara>The following diagram illustrates these basic components of the decision engine:</simpara>
<figure>
<title>Overview of basic decision engine components</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/rule-engine-inkscape_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>rule engine inkscape enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>For more details and examples of rule and fact behavior in the decision engine, see <xref linkend="inference-and-truth-maintenance_decision-engine"/>.</simpara>
<simpara>These core concepts can help you to better understand other more advanced components, processes, and sub-processes of the decision engine, and as a result, to design more effective business assets in Red Hat Decision Manager.</simpara>
</chapter>
<chapter xml:id="kie-sessions-con_decision-engine">
<title>KIE sessions</title>
<simpara>In Red Hat Decision Manager, a KIE session stores and executes runtime data. The KIE session is created from a KIE base or directly from a KIE container if you have defined the KIE session in the KIE module descriptor file (<literal>kmodule.xml</literal>) for your project.</simpara>
<formalpara>
<title>Example KIE session configuration in a <literal>kmodule.xml</literal> file</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase&gt;
    ...
    &lt;ksession name="KSession2_1" type="stateless" default="true" clockType="realtime"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</para>
</formalpara>
<simpara>A KIE base is a repository that you define in the KIE module descriptor file (<literal>kmodule.xml</literal>) for your project and contains all
rules and other business assets
in Red Hat Decision Manager, but does not contain any runtime data.</simpara>
<formalpara>
<title>Example KIE base configuration in a <literal>kmodule.xml</literal> file</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" equalsBehavior="equality" declarativeAgenda="enabled" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</para>
</formalpara>
<simpara>A KIE session can be stateless or stateful. In a stateless KIE session, data from a previous invocation of the KIE session (the previous session state) is discarded between session invocations. In a stateful KIE session, that data is retained. The type of KIE session you use depends on your project requirements and how you want data from different asset invocations to be persisted.</simpara>
<section xml:id="kie-sessions-stateless-con_decision-engine">
<title>Stateless KIE sessions</title>
<simpara>A stateless KIE session is a session that does not use inference to make iterative changes to facts over time. In a stateless KIE session, data from a previous invocation of the KIE session (the previous session state) is discarded between session invocations, whereas in a stateful KIE session, that data is retained. A stateless KIE session behaves similarly to a function in that the results that it produces are determined by the contents of the KIE base and by the data that is passed into the KIE session for execution at a specific point in time. The KIE session has no memory of any data that was passed into the KIE session previously.</simpara>
<simpara>Stateless KIE sessions are commonly used for the following use cases:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Validation</emphasis>, such as validating that a person is eligible for a mortgage</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Calculation</emphasis>, such as computing a mortgage premium</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Routing and filtering</emphasis>, such as sorting incoming emails into folders or sending incoming emails to a destination</simpara>
</listitem>
</itemizedlist>
<simpara>For example, consider the following driver’s license data model and sample DRL rule:</simpara>
<formalpara>
<title>Data model for driver’s license application</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Applicant {
  private String name;
  private int age;
  private boolean valid;
  // Getter and setter methods
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample DRL rule for driver’s license application</title>
<para>
<screen>package com.company.license

rule "Is of valid age"
when
  $a : Applicant(age &lt; 18)
then
  $a.setValid(false);
end</screen>
</para>
</formalpara>
<simpara>The <literal>Is of valid age</literal> rule disqualifies any applicant younger than 18 years old. When the <literal>Applicant</literal> object is inserted into the decision engine, the decision engine evaluates the constraints for each rule and searches for a match. The <literal>"objectType"</literal> constraint is always implied, after which any number of explicit field constraints are evaluated. The variable <literal>$a</literal> is a binding variable that references the matched object in the rule consequence.</simpara>
<note>
<simpara>The dollar sign (<literal>$</literal>) is optional and helps to differentiate between variable names and field names.</simpara>
</note>
<simpara>In this example, the sample rule and all other files in the <literal>~/resources</literal> folder of the Red Hat Decision Manager project are built with the following code:</simpara>
<formalpara>
<title>Create the KIE container</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();

KieContainer kContainer = kieServices.getKieClasspathContainer();</programlisting>
</para>
</formalpara>
<simpara>This code compiles all the rule files found on the class path and adds the result of this compilation, a <literal>KieModule</literal> object, in the <literal>KieContainer</literal>.</simpara>
<simpara>Finally, the <literal>StatelessKieSession</literal> object is instantiated from the <literal>KieContainer</literal> and is executed against specified data:</simpara>
<formalpara>
<title>Instantiate the stateless KIE session and enter data</title>
<para>
<programlisting language="java" linenumbering="unnumbered">StatelessKieSession kSession = kContainer.newStatelessKieSession();

Applicant applicant = new Applicant("Mr John Smith", 16);

assertTrue(applicant.isValid());

ksession.execute(applicant);

assertFalse(applicant.isValid());</programlisting>
</para>
</formalpara>
<simpara>In a stateless KIE session configuration, the <literal>execute()</literal> call acts as a combination method that instantiates the <literal>KieSession</literal> object, adds all the user data and executes user commands, calls <literal>fireAllRules()</literal>, and then calls <literal>dispose()</literal>. Therefore, with a stateless KIE session, you do not need to call <literal>fireAllRules()</literal> or call <literal>dispose()</literal> after session invocation as you do with a stateful KIE session.</simpara>
<simpara>In this case, the specified applicant is under the age of 18, so the application is declined.</simpara>
<simpara>For a more complex use case, see the following example. This example uses a stateless KIE session and executes rules against an iterable list of objects, such as a collection.</simpara>
<formalpara>
<title>Expanded data model for driver’s license application</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Applicant {
  private String name;
  private int age;
  // Getter and setter methods
}

public class Application {
  private Date dateApplied;
  private boolean valid;
  // Getter and setter methods
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expanded DRL rule set for driver’s license application</title>
<para>
<screen>package com.company.license

rule "Is of valid age"
when
  Applicant(age &lt; 18)
  $a : Application()
then
  $a.setValid(false);
end

rule "Application was made this year"
when
  $a : Application(dateApplied &gt; "01-jan-2009")
then
  $a.setValid(false);
end</screen>
</para>
</formalpara>
<formalpara>
<title>Expanded Java source with iterable execution in a stateless KIE session</title>
<para>
<programlisting language="java" linenumbering="unnumbered">StatelessKieSession ksession = kbase.newStatelessKnowledgeSession();
Applicant applicant = new Applicant("Mr John Smith", 16);
Application application = new Application();

assertTrue(application.isValid());
ksession.execute(Arrays.asList(new Object[] { application, applicant }));  <co xml:id="CO13-1"/>
assertFalse(application.isValid());

ksession.execute
  (CommandFactory.newInsertIterable(new Object[] { application, applicant }));  <co xml:id="CO13-2"/>

List&lt;Command&gt; cmds = new ArrayList&lt;Command&gt;();  <co xml:id="CO13-3"/>
cmds.add(CommandFactory.newInsert(new Person("Mr John Smith"), "mrSmith"));
cmds.add(CommandFactory.newInsert(new Person("Mr John Doe"), "mrDoe"));

BatchExecutionResults results = ksession.execute(CommandFactory.newBatchExecution(cmds));
assertEquals(new Person("Mr John Smith"), results.getValue("mrSmith"));</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO13-1">
<para>Method for executing rules against an iterable collection of objects produced by the <literal>Arrays.asList()</literal> method. Every collection element is inserted before any matched rules are executed. The <literal>execute(Object object)</literal> and <literal>execute(Iterable objects)</literal> methods are wrappers around the <literal>execute(Command command)</literal> method that comes from the <literal>BatchExecutor</literal> interface.</para>
</callout>
<callout arearefs="CO13-2">
<para>Execution of the iterable collection of objects using the <literal>CommandFactory</literal> interface.</para>
</callout>
<callout arearefs="CO13-3">
<para><literal>BatchExecutor</literal> and <literal>CommandFactory</literal> configurations for working with many different commands or result output identifiers. The <literal>CommandFactory</literal> interface supports other commands that you can use in the <literal>BatchExecutor</literal>, such as <literal>StartProcess</literal>, <literal>Query</literal>, and <literal>SetGlobal</literal>.</para>
</callout>
</calloutlist>
<section xml:id="kie-sessions-stateless-globals-con_decision-engine">
<title>Global variables in stateless KIE sessions</title>
<simpara>The <literal>StatelessKieSession</literal> object supports global variables (globals) that you can configure to be resolved as session-scoped globals, delegate globals, or execution-scoped globals.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Session-scoped globals:</emphasis> For session-scoped globals, you can use the method <literal>getGlobals()</literal> to return a <literal>Globals</literal> instance that provides access to the KIE session globals. These globals are used for all execution calls. Use caution with mutable globals because execution calls can be executing simultaneously in different threads.</simpara>
<formalpara>
<title>Session-scoped global</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.runtime.StatelessKieSession;

StatelessKieSession ksession = kbase.newStatelessKieSession();

// Set a global `myGlobal` that can be used in the rules.
ksession.setGlobal("myGlobal", "I am a global");

// Execute while resolving the `myGlobal` identifier.
ksession.execute(collection);</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delegate globals:</emphasis> For delegate globals, you can assign a value to a global (with <literal>setGlobal(String, Object)</literal>) so that the value is stored in an internal collection that maps identifiers to values. Identifiers in this internal collection have priority over any supplied delegate. If an identifier cannot be found in this internal collection, the delegate global (if any) is used.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Execution-scoped globals:</emphasis> For execution-scoped globals, you can use the <literal>Command</literal> object to set a global that is passed to the <literal>CommandExecutor</literal> interface for execution-specific global resolution.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>CommandExecutor</literal> interface also enables you to export data using out identifiers for globals, inserted facts, and query results:</simpara>
<formalpara>
<title>Out identifiers for globals, inserted facts, and query results</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.runtime.ExecutionResults;

// Set up a list of commands.
List cmds = new ArrayList();
cmds.add(CommandFactory.newSetGlobal("list1", new ArrayList(), true));
cmds.add(CommandFactory.newInsert(new Person("jon", 102), "person"));
cmds.add(CommandFactory.newQuery("Get People" "getPeople"));

// Execute the list.
ExecutionResults results = ksession.execute(CommandFactory.newBatchExecution(cmds));

// Retrieve the `ArrayList`.
results.getValue("list1");
// Retrieve the inserted `Person` fact.
results.getValue("person");
// Retrieve the query as a `QueryResults` instance.
results.getValue("Get People");</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="kie-sessions-stateful-con_decision-engine">
<title>Stateful KIE sessions</title>
<simpara>A stateful KIE session is a session that uses inference to make iterative changes to facts over time. In a stateful KIE session, data from a previous invocation of the KIE session (the previous session state) is retained between session invocations, whereas in a stateless KIE session, that data is discarded.</simpara>
<warning>
<simpara>Ensure that you call the <literal>dispose()</literal> method after running a stateful KIE session so that no memory leaks occur between session invocations.</simpara>
</warning>
<simpara>Stateful KIE sessions are commonly used for the following use cases:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Monitoring</emphasis>, such as monitoring a stock market and automating the buying process</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Diagnostics</emphasis>, such as running fault-finding processes or medical diagnostic processes</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logistics</emphasis>, such as parcel tracking and delivery provisioning</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Ensuring compliance</emphasis>, such as verifying the legality of market trades</simpara>
</listitem>
</itemizedlist>
<simpara>For example, consider the following fire alarm data model and sample DRL rules:</simpara>
<formalpara>
<title>Data model for sprinklers and fire alarm</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Room {
  private String name;
  // Getter and setter methods
}

public class Sprinkler {
  private Room room;
  private boolean on;
  // Getter and setter methods
}

public class Fire {
  private Room room;
  // Getter and setter methods
}

public class Alarm { }</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample DRL rule set for activating sprinklers and alarm</title>
<para>
<screen>rule "When there is a fire turn on the sprinkler"
when
  Fire($room : room)
  $sprinkler : Sprinkler(room == $room, on == false)
then
  modify($sprinkler) { setOn(true) };
  System.out.println("Turn on the sprinkler for room "+$room.getName());
end

rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert( new Alarm() );
    System.out.println( "Raise the alarm" );
end

rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    delete( $alarm );
    System.out.println( "Cancel the alarm" );
end


rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler( on == true )
then
    System.out.println( "Everything is ok" );
end</screen>
</para>
</formalpara>
<simpara>For the <literal>When there is a fire turn on the sprinkler</literal> rule, when a fire occurs, the instances of the <literal>Fire</literal> class are created for that room and inserted into the KIE session. The rule adds a constraint for the specific <literal>room</literal> matched in the <literal>Fire</literal> instance so that only the sprinkler for that room is checked. When this rule is executed, the sprinkler activates. The other sample rules determine when the alarm is activated or deactivated accordingly.</simpara>
<simpara>Whereas a stateless KIE session relies on standard Java syntax to modify a field, a stateful KIE session relies on the <literal>modify</literal> statement in rules to notify the decision engine of changes. The decision engine then reasons over the changes and assesses impact on subsequent rule executions. This process is part of the decision engine ability to use <emphasis>inference</emphasis> and <emphasis>truth maintenance</emphasis> and is essential in stateful KIE sessions.</simpara>
<simpara>In this example, the sample rules and all other files in the <literal>~/resources</literal> folder of the Red Hat Decision Manager project are built with the following code:</simpara>
<formalpara>
<title>Create the KIE container</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();</programlisting>
</para>
</formalpara>
<simpara>This code compiles all the rule files found on the class path and adds the result of this compilation, a <literal>KieModule</literal> object, in the <literal>KieContainer</literal>.</simpara>
<simpara>Finally, the <literal>KieSession</literal> object is instantiated from the <literal>KieContainer</literal> and is executed against specified data:</simpara>
<formalpara>
<title>Instantiate the stateful KIE session and enter data</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSession ksession = kContainer.newKieSession();

String[] names = new String[]{"kitchen", "bedroom", "office", "livingroom"};
Map&lt;String,Room&gt; name2room = new HashMap&lt;String,Room&gt;();
for( String name: names ){
    Room room = new Room( name );
    name2room.put( name, room );
    ksession.insert( room );
    Sprinkler sprinkler = new Sprinkler( room );
    ksession.insert( sprinkler );
}

ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<formalpara>
<title>Console output</title>
<para>
<screen>&gt; Everything is ok</screen>
</para>
</formalpara>
<simpara>With the data added, the decision engine completes all pattern matching but no rules have been executed, so the configured verification message appears. As new data triggers rule conditions, the decision engine executes rules to activate the alarm and later to cancel the alarm that has been activated:</simpara>
<formalpara>
<title>Enter new data to trigger rules</title>
<para>
<programlisting language="java" linenumbering="unnumbered">Fire kitchenFire = new Fire( name2room.get( "kitchen" ) );
Fire officeFire = new Fire( name2room.get( "office" ) );

FactHandle kitchenFireHandle = ksession.insert( kitchenFire );
FactHandle officeFireHandle = ksession.insert( officeFire );

ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<formalpara>
<title>Console output</title>
<para>
<screen>&gt; Raise the alarm
&gt; Turn on the sprinkler for room kitchen
&gt; Turn on the sprinkler for room office</screen>
</para>
</formalpara>
<programlisting language="java" linenumbering="unnumbered">ksession.delete( kitchenFireHandle );
ksession.delete( officeFireHandle );

ksession.fireAllRules();</programlisting>
<formalpara>
<title>Console output</title>
<para>
<screen>&gt; Cancel the alarm
&gt; Turn off the sprinkler for room office
&gt; Turn off the sprinkler for room kitchen
&gt; Everything is ok</screen>
</para>
</formalpara>
<simpara>In this case, a reference is kept for the returned <literal>FactHandle</literal> object. A fact handle is an internal engine reference to the inserted instance and enables instances to be retracted or modified later.</simpara>
<simpara>As this example illustrates, the data and results from previous stateful KIE sessions (the activated alarm) affect the invocation of subsequent sessions (alarm cancellation).</simpara>
</section>
<section xml:id="kie-sessions-pools-con_decision-engine">
<title>KIE session pools</title>
<simpara>In use cases with large amounts of KIE runtime data and high system activity, KIE sessions might be created and disposed very frequently. A high turnover of KIE sessions is not always time consuming, but when the turnover is repeated millions of times, the process can become a bottleneck and require substantial clean-up effort.</simpara>
<simpara>For these high-volume cases, you can use KIE session pools instead of many individual KIE sessions. To use a KIE session pool, you obtain a KIE session pool from a KIE container, define the initial number of KIE sessions in the pool, and create the KIE sessions from that pool as usual:</simpara>
<formalpara>
<title>Example KIE session pool</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Obtain a KIE session pool from the KIE container
KieContainerSessionsPool pool = kContainer.newKieSessionsPool(10);

// Create KIE sessions from the KIE session pool
KieSession kSession = pool.newKieSession();</programlisting>
</para>
</formalpara>
<simpara>In this example, the KIE session pool starts with 10 KIE sessions in it, but you can specify the number of KIE sessions that you need. This integer value is the number of KIE sessions that are only initially created in the pool. If required by the running application, the number of KIE sessions in the pool can dynamically grow beyond that value.</simpara>
<simpara>After you define a KIE session pool, the next time you use the KIE session as usual and call <literal>dispose()</literal> on it, the KIE session is reset and pushed back into the pool instead of being destroyed.</simpara>
<simpara>KIE session pools typically apply to stateful KIE sessions, but KIE session pools can also affect stateless KIE sessions that you reuse with multiple <literal>execute()</literal> calls. When you create a stateless KIE session directly from a KIE container, the KIE session continues to internally create a new KIE session for each <literal>execute()</literal> invocation. Conversely, when you create a stateless KIE session from a KIE session pool, the KIE session internally uses only the specific KIE sessions provided by the pool.</simpara>
<simpara>When you finish using a KIE session pool, you can call the <literal>shutdown()</literal> method on it to avoid memory leaks. Alternatively, you can call <literal>dispose()</literal> on the KIE container to shut down all the pools created from the KIE container.</simpara>
</section>
</chapter>
<chapter xml:id="inference-and-truth-maintenance_decision-engine">
<title>Inference and truth maintenance in the decision engine</title>
<simpara>The basic function of the decision engine is to match data to business rules and determine whether and how to execute rules. To ensure that relevant data is applied to the appropriate rules, the decision engine makes <emphasis>inferences</emphasis> based on existing knowledge and performs the actions based on the inferred information.</simpara>
<simpara>For example, the following DRL rule determines the age requirements for adults, such as in a bus pass policy:</simpara>
<formalpara>
<title>Rule to define age requirement</title>
<para>
<screen>rule "Infer Adult"
when
  $p : Person(age &gt;= 18)
then
  insert(new IsAdult($p))
end</screen>
</para>
</formalpara>
<simpara>Based on this rule, the decision engine infers whether a person is an adult or a child and performs the specified action (the <literal>then</literal> consequence). Every person who is 18 years old or older has an instance of <literal>IsAdult</literal> inserted for them in the working memory. This inferred relation of age and bus pass can then be invoked in any rule, such as in the following rule segment:</simpara>
<screen>$p : Person()
IsAdult(person == $p)</screen>
<simpara>In many cases, new data in a rule system is the result of other rule executions, and this new data can affect the execution of other rules. If the decision engine asserts data as a result of executing a rule, the decision engine uses truth maintenance to justify the assertion and enforce truthfulness when applying inferred information to other rules. Truth maintenance also helps to identify inconsistencies and to handle contradictions. For example, if two rules are executed and result in a contradictory action, the decision engine chooses the action based on assumptions from previously calculated conclusions.</simpara>
<simpara>The decision engine inserts facts using either stated or logical insertions:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Stated insertions:</emphasis> Defined with <literal>insert()</literal>. After stated insertions, facts are generally retracted explicitly. (The term <emphasis>insertion</emphasis>, when used generically, refers to <emphasis>stated insertion</emphasis>.)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Logical insertions:</emphasis> Defined with <literal>insertLogical()</literal>. After logical insertions, the facts that were inserted are automatically retracted when the conditions in the rules that inserted the facts are no longer true. The facts are retracted when no condition supports the logical insertion. A fact that is logically inserted is considered to be <emphasis>justified</emphasis> by the decision engine.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following sample DRL rules use stated fact insertion to determine the age requirements for issuing a child bus pass or an adult bus pass:</simpara>
<formalpara>
<title>Rules to issue bus pass, stated insertion</title>
<para>
<screen>rule "Issue Child Bus Pass"
when
  $p : Person(age &lt; 18)
then
  insert(new ChildBusPass($p));
end

rule "Issue Adult Bus Pass"
when
  $p : Person(age &gt;= 18)
then
  insert(new AdultBusPass($p));
end</screen>
</para>
</formalpara>
<simpara>These rules are not easily maintained in the decision engine as bus riders increase in age and move from child to adult bus pass. As an alternative, these rules can be separated into rules for bus rider age and rules for bus pass type using logical fact insertion. The logical insertion of the fact makes the fact dependent on the truth of the <literal>when</literal> clause.</simpara>
<simpara>The following DRL rules use logical insertion to determine the age requirements for children and adults:</simpara>
<formalpara>
<title>Children and adult age requirements, logical insertion</title>
<para>
<screen>rule "Infer Child"
when
  $p : Person(age &lt; 18)
then
  insertLogical(new IsChild($p))
end

rule "Infer Adult"
when
  $p : Person(age &gt;= 18)
then
  insertLogical(new IsAdult($p))
end</screen>
</para>
</formalpara>
<important>
<simpara>For logical insertions, your fact objects must override the <literal>equals</literal> and <literal>hashCode</literal> methods from the <literal>java.lang.Object</literal> object according to the Java standard. Two objects are equal if their <literal>equals</literal> methods return <literal>true</literal> for each other and if their <literal>hashCode</literal> methods return the same values. For more information, see the Java API documentation for your Java version.</simpara>
</important>
<simpara>When the condition in the rule is false, the fact is automatically retracted. This behavior is helpful in this example because the two rules are mutually exclusive. In this example, if the person is younger than 18 years old, the rule logically inserts an <literal>IsChild</literal> fact. After the person is 18 years old or older, the <literal>IsChild</literal> fact is automatically retracted and the <literal>IsAdult</literal> fact is inserted.</simpara>
<simpara>The following DRL rules then determine whether to issue a child bus pass or an adult bus pass and logically insert the <literal>ChildBusPass</literal> and <literal>AdultBusPass</literal> facts. This rule configuration is possible because the truth maintenance system in the decision engine supports chaining of logical insertions for a cascading set of retracts.</simpara>
<formalpara>
<title>Rules to issue bus pass, logical insertion</title>
<para>
<screen>rule "Issue Child Bus Pass"
when
  $p : Person()
    IsChild(person == $p)
then
  insertLogical(new ChildBusPass($p));
end

rule "Issue Adult Bus Pass"
when
  $p : Person()
    IsAdult(person =$p)
then
  insertLogical(new AdultBusPass($p));
end</screen>
</para>
</formalpara>
<simpara>When a person turns 18 years old, the <literal>IsChild</literal> fact and the person’s <literal>ChildBusPass</literal> fact is retracted. To these set of conditions, you can relate another rule that states that a person must return the child pass after turning 18 years old. When the decision engine automatically retracts the <literal>ChildBusPass</literal> object, the following rule is executed to send a request to the person:</simpara>
<formalpara>
<title>Rule to notify bus pass holder of new pass</title>
<para>
<screen>rule "Return ChildBusPass Request"
when
  $p : Person()
    not(ChildBusPass(person == $p))
then
  requestChildBusPass($p);
end</screen>
</para>
</formalpara>
<simpara>The following flowcharts illustrate the life cycle of stated and logical insertions:</simpara>
<figure>
<title>Stated insertion</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/Stated_Assertion_enterprise.png"/>
</imageobject>
<textobject><phrase>Stated Assertion enterprise</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Logical insertion</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/Logical_Assertion_enterprise.png"/>
</imageobject>
<textobject><phrase>Logical Assertion enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>When the decision engine logically inserts an object during a rule execution, the decision engine <emphasis>justifies</emphasis> the object by executing the rule. For each logical insertion, only one equal object can exist, and each subsequent equal logical insertion increases the justification counter for that logical insertion. A justification is removed when the conditions of the rule become untrue. When no more justifications exist, the logical object is automatically retracted.</simpara>
<section xml:id="fact-equality-modes-con_decision-engine">
<title>Fact equality modes in the decision engine</title>
<simpara>The decision engine supports the following fact equality modes that determine how the decision engine stores and compares inserted facts:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>identity</literal>: (Default) The decision engine uses an <literal>IdentityHashMap</literal> to store all inserted facts. For every new fact insertion, the decision engine returns a new <literal>FactHandle</literal> object. If a fact is inserted again, the decision engine returns the original <literal>FactHandle</literal> object, ignoring repeated insertions for the same fact. In this mode, two facts are the same for the decision engine only if they are the very same object with the same identity.</simpara>
</listitem>
<listitem>
<simpara><literal>equality</literal>: The decision engine uses a <literal>HashMap</literal> to store all inserted facts. The decision engine returns a new <literal>FactHandle</literal> object only if the inserted fact is not equal to an existing fact, according to the <literal>equals()</literal> method of the inserted fact. In this mode, two facts are the same for the decision engine if they are composed the same way, regardless of identity. Use this mode when you want objects to be assessed based on feature equality instead of explicit identity.</simpara>
</listitem>
</itemizedlist>
<simpara>As an illustration of fact equality modes, consider the following example facts:</simpara>
<formalpara>
<title>Example facts</title>
<para>
<screen>Person p1 = new Person("John", 45);
Person p2 = new Person("John", 45);</screen>
</para>
</formalpara>
<simpara>In <literal>identity</literal> mode, facts <literal>p1</literal> and <literal>p2</literal> are different instances of a <literal>Person</literal> class and are treated as separate objects because they have separate identities. In <literal>equality</literal> mode, facts <literal>p1</literal> and <literal>p2</literal> are treated as the same object because they are composed the same way. This difference in behavior affects how you can interact with fact handles.</simpara>
<simpara>For example, assume that you insert facts <literal>p1</literal> and <literal>p2</literal> into the decision engine and later you want to retrieve the fact handle for <literal>p1</literal>. In <literal>identity</literal> mode, you must specify <literal>p1</literal> to return the fact handle for that exact object, whereas in <literal>equality</literal> mode, you can specify <literal>p1</literal>, <literal>p2</literal>, or <literal>new Person("John", 45)</literal> to return the fact handle.</simpara>
<formalpara>
<title>Example code to insert a fact and return the fact handle in <literal>identity</literal> mode</title>
<para>
<screen>ksession.insert(p1);

ksession.getFactHandle(p1);</screen>
</para>
</formalpara>
<formalpara>
<title>Example code to insert a fact and return the fact handle in <literal>equality</literal> mode</title>
<para>
<screen>ksession.insert(p1);

ksession.getFactHandle(p1);

// Alternate option:
ksession.getFactHandle(new Person("John", 45));</screen>
</para>
</formalpara>
<simpara>To set the fact equality mode, use one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the system property <literal>drools.equalityBehavior</literal> to <literal>identity</literal> (default) or <literal>equality</literal>.</simpara>
</listitem>
<listitem>
<simpara>Set the equality mode while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration();
kieBaseConf.setOption(EqualityBehaviorOption.EQUALITY);
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
<listitem>
<simpara>Set the equality mode in the KIE module descriptor file (<literal>kmodule.xml</literal>) for a specific Red Hat Decision Manager project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" equalsBehavior="equality" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="execution-control-con_decision-engine">
<title>Execution control in the decision engine</title>
<simpara>When new rule data enters the working memory of the decision engine, rules may become fully matched and eligible for execution. A single working memory action can result in multiple eligible rule executions. When a rule is fully matched, the decision engine creates an activation instance, referencing the rule and the matched facts, and adds the activation onto the decision engine agenda. The agenda controls the execution order of these rule activations using a conflict resolution strategy.</simpara>
<simpara>After the first call of <literal>fireAllRules()</literal> in the Java application, the decision engine cycles repeatedly through two phases:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Agenda evaluation.</emphasis> In this phase, the decision engine selects all rules that can be executed. If no executable rules exist, the execution cycle ends. If an executable rule is found, the decision engine registers the activation in the agenda and then moves on to the working memory actions phase to perform rule consequence actions.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Working memory actions.</emphasis> In this phase, the decision engine performs the rule consequence actions (the <literal>then</literal> portion of each rule) for all activated rules previously registered in the agenda. After all the consequence actions are complete or the main Java application process calls <literal>fireAllRules()</literal> again, the decision engine returns to the agenda evaluation phase to reassess rules.</simpara>
</listitem>
</itemizedlist>
<figure>
<title>Two-phase execution process in the decision engine</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/Two_Phase_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>Two Phase enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>When multiple rules exist on the agenda, the execution of one rule may cause another rule to be removed from the agenda. To avoid this, you can define how and when rules are executed in the decision engine. Some common methods for defining rule execution order are by using rule salience, agenda groups, activation groups, or rule units for DRL rule sets.</simpara>
<section xml:id="salience_for_rules" remap="_salience_for_rules">
<title>Salience for rules</title>
<simpara>Each rule has an integer <literal>salience</literal> attribute that determines the order of execution. Rules with a higher salience value are given higher priority when ordered in the activation queue. The default salience value for rules is zero, but the salience can be negative or positive.</simpara>
<simpara>For example, the following sample DRL rules are listed in the decision engine stack in the order shown:</simpara>
<screen>rule "RuleA"
salience 95
when
    $fact : MyFact( field1 == true )
then
    System.out.println("Rule2 : " + $fact);
    update($fact);
end

rule "RuleB"
salience 100
when
   $fact : MyFact( field1 == false )
then
   System.out.println("Rule1 : " + $fact);
   $fact.setField1(true);
   update($fact);
end</screen>
<simpara>The <literal>RuleB</literal> rule is listed second, but it has a higher salience value than the <literal>RuleA</literal> rule and is therefore executed first.</simpara>
</section>
<section xml:id="agenda_groups_for_rules" remap="_agenda_groups_for_rules">
<title>Agenda groups for rules</title>
<simpara>An agenda group is a set of rules bound together by the same <literal>agenda-group</literal> rule attribute. Agenda groups partition rules on the decision engine agenda. At any one time, only one group has a <emphasis>focus</emphasis> that gives that group of rules priority for execution before rules in other agenda groups. You determine the focus with a <literal>setFocus()</literal> call for the agenda group. You can also define rules with an <literal>auto-focus</literal> attribute so that the next time the rule is activated, the focus is automatically given to the entire agenda group to which the rule is assigned.</simpara>
<simpara>Each time the <literal>setFocus()</literal> call is made in a Java application, the decision engine adds the specified agenda group to the top of the rule stack. The default agenda group <literal>"MAIN"</literal> contains all rules that do not belong to a specified agenda group and is executed first in the stack unless another group has the focus.</simpara>
<simpara>For example, the following sample DRL rules belong to specified agenda groups and are listed in the decision engine stack in the order shown:</simpara>
<formalpara>
<title>Sample DRL rules for banking application</title>
<para>
<screen>rule "Increase balance for credits"
  agenda-group "calculation"
when
  ap : AccountPeriod()
  acc : Account( $accountNo : accountNo )
  CashFlow( type == CREDIT,
            accountNo == $accountNo,
            date &gt;= ap.start &amp;&amp; &lt;= ap.end,
            $amount : amount )
then
  acc.balance  += $amount;
end</screen>
</para>
</formalpara>
<screen>rule "Print balance for AccountPeriod"
  agenda-group "report"
when
  ap : AccountPeriod()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );
end</screen>
<simpara>For this example, the rules in the <literal>"report"</literal> agenda group must always be executed first and the rules in the <literal>"calculation"</literal> agenda group must always be executed second. Any remaining rules in other agenda groups can then be executed. Therefore, the <literal>"report"</literal> and <literal>"calculation"</literal> groups must receive the focus to be executed in that order, before other rules can be executed:</simpara>
<formalpara>
<title>Set the focus for the order of agenda group execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">Agenda agenda = ksession.getAgenda();
agenda.getAgendaGroup( "report" ).setFocus();
agenda.getAgendaGroup( "calculation" ).setFocus();
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>You can also use the <literal>clear()</literal> method to cancel all the activations generated by the rules belonging to a given agenda group before each has had a chance to be executed:</simpara>
<formalpara>
<title>Cancel all other rule activations</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.getAgenda().getAgendaGroup( "Group A" ).clear();</programlisting>
</para>
</formalpara>
</section>
<section xml:id="activation_groups_for_rules" remap="_activation_groups_for_rules">
<title>Activation groups for rules</title>
<simpara>An activation group is a set of rules bound together by the same <literal>activation-group</literal> rule attribute. In this group, only one rule can be executed. After conditions are met for a rule in that group to be executed, all other pending rule executions from that activation group are removed from the agenda.</simpara>
<simpara>For example, the following sample DRL rules belong to the specified activation group and are listed in the decision engine stack in the order shown:</simpara>
<formalpara>
<title>Sample DRL rules for banking</title>
<para>
<screen>rule "Print balance for AccountPeriod1"
  activation-group "report"
when
  ap : AccountPeriod1()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );
end</screen>
</para>
</formalpara>
<screen>rule "Print balance for AccountPeriod2"
  activation-group "report"
when
  ap : AccountPeriod2()
  acc : Account()
then
  System.out.println( acc.accountNo +
                      " : " + acc.balance );
end</screen>
<simpara>For this example, if the first rule in the <literal>"report"</literal> activation group is executed, the second rule in the group and all other executable rules on the agenda are removed from the agenda.</simpara>
</section>
<section xml:id="rule-execution-modes-con_decision-engine">
<title>Rule execution modes and thread safety in the decision engine</title>
<simpara>The decision engine supports the following rule execution modes that determine how and when the decision engine executes rules:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Passive mode</emphasis>: (Default) The decision engine evaluates rules when a user or an application explicitly calls <literal>fireAllRules()</literal>. Passive mode in the decision engine is best for applications that require direct control over rule evaluation and execution, or for complex event processing (CEP) applications that use the pseudo clock implementation in the decision engine.</simpara>
<formalpara>
<title>Example CEP application code with the decision engine in passive mode</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("pseudo") );
KieSession session = kbase.newKieSession( conf, null );
SessionPseudoClock clock = session.getSessionClock();

session.insert( tick1 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick2 );
session.fireAllRules();

clock.advanceTime(1, TimeUnit.SECONDS);
session.insert( tick3 );
session.fireAllRules();

session.dispose();</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Active mode</emphasis>: If a user or application calls <literal>fireUntilHalt()</literal>, the decision engine starts in active mode and evaluates rules continually until the user or application explicitly calls <literal>halt()</literal>. Active mode in the decision engine is best for applications that delegate control of rule evaluation and execution to the decision engine, or for complex event processing (CEP) applications that use the real-time clock implementation in the decision engine. Active mode is also optimal for CEP applications that use active queries.</simpara>
<formalpara>
<title>Example CEP application code with the decision engine in active mode</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();
config.setOption( ClockTypeOption.get("realtime") );
KieSession session = kbase.newKieSession( conf, null );

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

session.insert( tick1 );

... Thread.sleep( 1000L ); ...

session.insert( tick2 );

... Thread.sleep( 1000L ); ...

session.insert( tick3 );

session.halt();
session.dispose();</programlisting>
</para>
</formalpara>
<simpara>This example calls <literal>fireUntilHalt()</literal> from a dedicated execution thread to prevent the current thread from being blocked indefinitely while the decision engine continues evaluating rules. The dedicated thread also enables you to call <literal>halt()</literal> at a later stage in the application code.</simpara>
</listitem>
</itemizedlist>
<simpara>Although you should avoid using both <literal>fireAllRules()</literal> and <literal>fireUntilHalt()</literal> calls, especially from different threads, the decision engine can handle such situations safely using thread-safety logic and an internal state machine. If a <literal>fireAllRules()</literal> call is in progress and you call <literal>fireUntilHalt()</literal>, the decision engine continues to run in passive mode until the <literal>fireAllRules()</literal> operation is complete and then starts in active mode in response to the <literal>fireUntilHalt()</literal> call. However, if the decision engine is running in active mode following a <literal>fireUntilHalt()</literal> call and you call <literal>fireAllRules()</literal>, the <literal>fireAllRules()</literal> call is ignored and the decision engine continues to run in active mode until you call <literal>halt()</literal>.</simpara>
<simpara>For added thread safety in active mode, the decision engine supports a <literal>submit()</literal> method that you can use to group and perform operations on a KIE session in a thread-safe, atomic action:</simpara>
<formalpara>
<title>Example application code with <literal>submit()</literal> method to perform atomic operations in active mode</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSession session = ...;

new Thread( new Runnable() {
  @Override
  public void run() {
      session.fireUntilHalt();
  }
} ).start();

final FactHandle fh = session.insert( fact_a );

... Thread.sleep( 1000L ); ...

session.submit( new KieSession.AtomicAction() {
  @Override
  public void execute( KieSession kieSession ) {
    fact_a.setField("value");
    kieSession.update( fh, fact_a );
    kieSession.insert( fact_1 );
    kieSession.insert( fact_2 );
    kieSession.insert( fact_3 );
  }
} );

... Thread.sleep( 1000L ); ...

session.insert( fact_z );

session.halt();
session.dispose();</programlisting>
</para>
</formalpara>
<simpara>Thread safety and atomic operations are also helpful from a client-side perspective. For example, you might need to insert more than one fact at a given time, but require the decision engine to consider the insertions as an atomic operation and to wait until all the insertions are complete before evaluating the rules again.</simpara>
</section>
<section xml:id="fact-propagation-modes-con_decision-engine">
<title>Fact propagation modes in the decision engine</title>
<simpara>The decision engine supports the following fact propagation modes that determine how the decision engine progresses inserted facts through the engine network in preparation for rule execution:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Lazy</emphasis>: (Default) Facts are propagated in batch collections at rule execution, not in real time as the facts are individually inserted by a user or application. As a result, the order in which the facts are ultimately propagated through the decision engine may be different from the order in which the facts were individually inserted.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Immediate</emphasis>: Facts are propagated immediately in the order that they are inserted by a user or application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Eager</emphasis>: Facts are propagated lazily (in batch collections), but before rule execution. The decision engine uses this propagation behavior for rules that have the <literal>no-loop</literal> or <literal>lock-on-active</literal> attribute.</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the Phreak rule algorithm in the decision engine uses lazy fact propagation for improved rule evaluation overall. However, in few cases, this lazy propagation behavior can alter the expected result of certain rule executions that may require immediate or eager propagation.</simpara>
<simpara>For example, the following rule uses a specified query with a <literal>?</literal> prefix to invoke the query in pull-only or passive fashion:</simpara>
<formalpara>
<title>Example rule with a passive query</title>
<para>
<screen>query Q (Integer i)
    String( this == i.toString() )
end

rule "Rule"
  when
    $i : Integer()
    ?Q( $i; )
  then
    System.out.println( $i );
end</screen>
</para>
</formalpara>
<simpara>For this example, the rule should be executed only when a <literal>String</literal> that satisfies the query is inserted before the <literal>Integer</literal>, such as in the following example commands:</simpara>
<formalpara>
<title>Example commands that should trigger the rule execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieSession ksession = ...
ksession.insert("1");
ksession.insert(1);
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>However, due to the default lazy propagation behavior in Phreak, the decision engine does not detect the insertion sequence of the two facts in this case, so this rule is executed regardless of <literal>String</literal> and <literal>Integer</literal> insertion order. For this example, immediate propagation is required for the expected rule evaluation.</simpara>
<simpara>To alter the decision engine propagation mode to achieve the expected rule evaluation in this case, you can add the <literal>@Propagation(&lt;type&gt;)</literal> tag to your rule and set <literal>&lt;type&gt;</literal> to <literal>LAZY</literal>, <literal>IMMEDIATE</literal>, or <literal>EAGER</literal>.</simpara>
<simpara>In the same example rule, the immediate propagation annotation enables the rule to be evaluated only when a <literal>String</literal> that satisfies the query is inserted before the <literal>Integer</literal>, as expected:</simpara>
<formalpara>
<title>Example rule with a passive query and specified propagation mode</title>
<para>
<screen>query Q (Integer i)
    String( this == i.toString() )
end

rule "Rule" @Propagation(IMMEDIATE)
  when
    $i : Integer()
    ?Q( $i; )
  then
    System.out.println( $i );
end</screen>
</para>
</formalpara>
</section>
<section xml:id="agenda-filters-con_decision-engine">
<title>Agenda evaluation filters</title>
<simpara>The decision engine supports an <literal>AgendaFilter</literal> object in the filter interface that you can use to allow or deny the evaluation of specified rules during agenda evaluation. You can specify an agenda filter as part of a <literal>fireAllRules()</literal> call.</simpara>
<simpara>The following example code permits only rules ending with the string <literal>"Test"</literal> to be evaluated and executed. All other rules are filtered out of the decision engine agenda.</simpara>
<formalpara>
<title>Example agenda filter definition</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.fireAllRules( new RuleNameEndsWithAgendaFilter( "Test" ) );</programlisting>
</para>
</formalpara>
</section>
<section xml:id="drl-rule-units-con_decision-engine">
<title>Rule units in DRL rule sets</title>
<simpara>Rule units are groups of data sources, global variables, and DRL rules that function together for a specific purpose. You can use rule units to partition a rule set into smaller units, bind different data sources to those units, and then execute the individual unit. Rule units are an enhanced alternative to rule-grouping DRL attributes such as rule agenda groups or activation groups for execution control.</simpara>
<simpara>Rule units are helpful when you want to coordinate rule execution so that the complete execution of one rule unit triggers the start of another rule unit and so on. For example, assume that you have a set of rules for data enrichment, another set of rules that processes that data, and another set of rules that extract the output from the processed data. If you add these rule sets into three distinct rule units, you can coordinate those rule units so that complete execution of the first unit triggers the start of the second unit and the complete execution of the second unit triggers the start of third unit.</simpara>
<simpara>To define a rule unit, implement the <literal>RuleUnit</literal> interface as shown in the following example:</simpara>
<formalpara>
<title>Example rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.mypackage.myunit;

public static class AdultUnit implements RuleUnit {
    private int adultAge;
    private DataSource&lt;Person&gt; persons;

    public AdultUnit( ) { }

    public AdultUnit( DataSource&lt;Person&gt; persons, int age ) {
        this.persons = persons;
        this.age = age;
    }

    // A data source of `Persons` in this rule unit:
    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    // A global variable in this rule unit:
    public int getAdultAge() {
        return adultAge;
    }

    // Life-cycle methods:
    @Override
    public void onStart() {
        System.out.println("AdultUnit started.");
    }

    @Override
    public void onEnd() {
        System.out.println("AdultUnit ended.");
    }
}</programlisting>
</para>
</formalpara>
<simpara>In this example, <literal>persons</literal> is a source of facts of type <literal>Person</literal>. A rule unit data source is a source of the data processed by a given rule unit and represents the entry point that the decision engine uses to evaluate the rule unit. The <literal>adultAge</literal> global variable is accessible from all the rules belonging to this rule unit. The last two methods are part of the rule unit life cycle and are invoked by the decision engine.</simpara>
<simpara>The decision engine supports the following optional life-cycle methods for rule units:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Rule unit life-cycle methods</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Method</entry>
<entry align="left" valign="top">Invoked when</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>onStart()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution starts</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onEnd()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution ends</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onSuspend()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution is suspended (used only with <literal>runUntilHalt()</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onResume()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rule unit execution is resumed (used only with <literal>runUntilHalt()</literal>)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>onYield(RuleUnit other)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The consequence of a rule in the rule unit triggers the execution of a different rule unit</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can add one or more rules to a rule unit. By default, all the rules in a DRL file are automatically associated with a rule unit that follows the naming convention of the DRL file name. If the DRL file is in the same package and has the same name as a class that implements the <literal>RuleUnit</literal> interface, then all of the rules in that DRL file implicitly belong to that rule unit. For example, all the rules in the <literal>AdultUnit.drl</literal> file in the <literal>org.mypackage.myunit</literal> package are automatically part of the rule unit <literal>org.mypackage.myunit.AdultUnit</literal>.</simpara>
<simpara>To override this naming convention and explicitly declare the rule unit that the rules in a DRL file belong to, use the <literal>unit</literal> keyword in the DRL file. The <literal>unit</literal> declaration must immediately follow the package declaration and contain the name of the class in that package that the rules in the DRL file are part of.</simpara>
<formalpara>
<title>Example rule unit declaration in a DRL file</title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    $p : Person(age &gt;= adultAge) from persons
  then
    System.out.println($p.getName() + " is adult and greater than " + adultAge);
end</screen>
</para>
</formalpara>
<warning>
<simpara>Do not mix rules with and without a rule unit in the same KIE base. Mixing two rule paradigms in a KIE base results in a compilation error.</simpara>
</warning>
<simpara>You can also rewrite the same pattern in a more convenient way using OOPath notation, as shown in the following example:</simpara>
<formalpara>
<title>Example rule unit declaration in a DRL file that uses OOPath notation</title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    $p : /persons[age &gt;= adultAge]
  then
    System.out.println($p.getName() + " is adult and greater than " + adultAge);
end</screen>
</para>
</formalpara>
<note>
<simpara>OOPath is an object-oriented syntax extension of XPath that is designed for browsing graphs of objects in DRL rule condition constraints. OOPath uses the compact notation from XPath for navigating through related elements while handling collections and filtering constraints, and is specifically useful for graphs of objects.</simpara>
</note>
<simpara>In this example, any matching facts in the rule conditions are retrieved from the <literal>persons</literal> data source defined in the <literal>DataSource</literal> definition in the rule unit class. The rule condition and action use the <literal>adultAge</literal> variable in the same way that a global variable is defined at the DRL file level.</simpara>
<simpara>To execute one or more rule units defined in a KIE base, create a new <literal>RuleUnitExecutor</literal> class bound to the KIE base, create the rule unit from the relevant data source, and run the rule unit executer:</simpara>
<formalpara>
<title>Example rule unit execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Create a `RuleUnitExecutor` class and bind it to the KIE base:
KieBase kbase = kieContainer.getKieBase();
RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );

// Create the `AdultUnit` rule unit using the `persons` data source and run the executor:
RuleUnit adultUnit = new AdultUnit(persons, 18);
executor.run( adultUnit );</programlisting>
</para>
</formalpara>
<simpara>Rules are executed by the <literal>RuleUnitExecutor</literal> class. The <literal>RuleUnitExecutor</literal> class creates KIE sessions and adds the required <literal>DataSource</literal> objects to those sessions, and then executes the rules based on the <literal>RuleUnit</literal> that is passed as a parameter to the <literal>run()</literal> method.</simpara>
<simpara>The example execution code produces the following output when the relevant <literal>Person</literal> facts are inserted in the <literal>persons</literal> data source:</simpara>
<formalpara>
<title>Example rule unit execution output</title>
<para>
<screen>org.mypackage.myunit.AdultUnit started.
Jane is adult and greater than 18
John is adult and greater than 18
org.mypackage.myunit.AdultUnit ended.</screen>
</para>
</formalpara>
<simpara>Instead of explicitly creating the rule unit instance, you can register the rule unit variables in the executor and pass to the executor the rule unit class that you want to run, and then the executor creates an instance of the rule unit. You can then set the <literal>DataSource</literal> definition and other variables as needed before running the rule unit.</simpara>
<formalpara>
<title>Alternate rule unit execution option with registered variables</title>
<para>
<programlisting language="java" linenumbering="unnumbered">executor.bindVariable( "persons", persons );
        .bindVariable( "adultAge", 18 );
executor.run( AdultUnit.class );</programlisting>
</para>
</formalpara>
<simpara>The name that you pass to the <literal>RuleUnitExecutor.bindVariable()</literal> method is used at run time to bind the variable to the field of the rule unit class with the same name. In the previous example, the <literal>RuleUnitExecutor</literal> inserts into the new rule unit the data source bound to the <literal>"persons"</literal> name and inserts the value <literal>18</literal> bound to the String <literal>"adultAge"</literal> into the fields with the corresponding names inside the <literal>AdultUnit</literal> class.</simpara>
<simpara>To override this default variable-binding behavior, use the <literal>@UnitVar</literal> annotation to explicitly define a logical binding name for each field of the rule unit class. For example, the field bindings in the following class are redefined with alternative names:</simpara>
<formalpara>
<title>Example code to modify variable binding names with <literal>@UnitVar</literal></title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.mypackage.myunit;

public static class AdultUnit implements RuleUnit {
    @UnitVar("minAge")
    private int adultAge = 18;

    @UnitVar("data")
    private DataSource&lt;Person&gt; persons;
}</programlisting>
</para>
</formalpara>
<simpara>You can then bind the variables to the executor using those alternative names and run the rule unit:</simpara>
<formalpara>
<title>Example rule unit execution with modified variable names</title>
<para>
<programlisting language="java" linenumbering="unnumbered">executor.bindVariable( "data", persons );
        .bindVariable( "minAge", 18 );
executor.run( AdultUnit.class );</programlisting>
</para>
</formalpara>
<simpara>You can execute a rule unit in <emphasis>passive mode</emphasis> by using the <literal>run()</literal> method (equivalent to invoking <literal>fireAllRules()</literal> on a KIE session)
or in <emphasis>active mode</emphasis> using the <literal>runUntilHalt()</literal> method (equivalent to invoking <literal>fireUntilHalt()</literal> on a KIE session). By default, the decision engine runs in <emphasis>passive mode</emphasis> and evaluates rule units only when a user or an application explicitly calls <literal>run()</literal> (or <literal>fireAllRules()</literal> for standard rules). If a user or application calls <literal>runUntilHalt()</literal> for rule units (or <literal>fireUntilHalt()</literal> for standard rules), the decision engine starts in <emphasis>active mode</emphasis> and evaluates rule units continually until the user or application explicitly calls <literal>halt()</literal>.</simpara>
<simpara>If you use the <literal>runUntilHalt()</literal> method, invoke the method on a separate execution thread to avoid blocking the main thread:</simpara>
<formalpara>
<title>Example rule unit execution with <literal>runUntilHalt()</literal> on a separate thread</title>
<para>
<programlisting language="java" linenumbering="unnumbered">new Thread( () -&gt; executor.runUntilHalt( adultUnit ) ).start();</programlisting>
</para>
</formalpara>
<section xml:id="data_sources_for_rule_units_2" remap="_data_sources_for_rule_units_2">
<title>Data sources for rule units</title>
<simpara>A rule unit data source is a source of the data processed by a given rule unit and represents the entry point that the decision engine uses to evaluate the rule unit. A rule unit can have zero or more data sources and each <literal>DataSource</literal> definition declared inside a rule unit can correspond to a different entry point into the rule unit executor. Multiple rule units can share a single data source, but each rule unit must use different entry points through which the same objects are inserted.</simpara>
<simpara>You can create a <literal>DataSource</literal> definition with a fixed set of data in a rule unit class, as shown in the following example:</simpara>
<formalpara>
<title>Example data source definition</title>
<para>
<programlisting language="java" linenumbering="unnumbered">DataSource&lt;Person&gt; persons = DataSource.create( new Person( "John", 42 ),
                                                new Person( "Jane", 44 ),
                                                new Person( "Sally", 4 ) );</programlisting>
</para>
</formalpara>
<simpara>Because a data source represents the entry point of the rule unit, you can insert, update, or delete facts in a rule unit:</simpara>
<formalpara>
<title>Example code to insert, modify, and delete a fact in a rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Insert a fact:
Person john = new Person( "John", 42 );
FactHandle johnFh = persons.insert( john );

// Modify the fact and optionally specify modified properties (for property reactivity):
john.setAge( 43 );
persons.update( johnFh, john, "age" );

// Delete the fact:
persons.delete( johnFh );</programlisting>
</para>
</formalpara>
</section>
<section xml:id="rule_unit_execution_control_2" remap="_rule_unit_execution_control_2">
<title>Rule unit execution control</title>
<simpara>Rule units are helpful when you want to coordinate rule execution so that the execution of one rule unit triggers the start of another rule unit and so on.</simpara>
<simpara>To facilitate rule unit execution control, the decision engine supports the following rule unit methods that you can use in DRL rule actions to coordinate the execution of rule units:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>drools.run()</literal>: Triggers the execution of a specified rule unit class. This method imperatively interrupts the execution of the rule unit and activates the other specified rule unit.</simpara>
</listitem>
<listitem>
<simpara><literal>drools.guard()</literal>: Prevents (guards) a specified rule unit class from being executed until the associated rule condition is met. This method declaratively schedules the execution of the other specified rule unit. When the decision engine produces at least one match for the condition in the guarding rule, the guarded rule unit is considered active. A rule unit can contain multiple guarding rules.</simpara>
</listitem>
</itemizedlist>
<simpara>As an example of the <literal>drools.run()</literal> method, consider the following DRL rules that each belong to a specified rule unit. The <literal>NotAdult</literal> rule uses the <literal>drools.run( AdultUnit.class )</literal> method to trigger the execution of the <literal>AdultUnit</literal> rule unit:</simpara>
<formalpara>
<title>Example DRL rules with controlled execution using <literal>drools.run()</literal></title>
<para>
<screen>package org.mypackage.myunit
unit AdultUnit

rule Adult
  when
    Person(age &gt;= 18, $name : name) from persons
  then
    System.out.println($name + " is adult");
end</screen>
</para>
</formalpara>
<screen>package org.mypackage.myunit
unit NotAdultUnit

rule NotAdult
  when
    $p : Person(age &lt; 18, $name : name) from persons
  then
    System.out.println($name + " is NOT adult");
    modify($p) { setAge(18); }
    drools.run( AdultUnit.class );
end</screen>
<simpara>The example also uses a <literal>RuleUnitExecutor</literal> class created from the KIE base that was built from these rules and a <literal>DataSource</literal> definition of <literal>persons</literal> bound to it:</simpara>
<formalpara>
<title>Example rule executor and data source definitions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );
DataSource&lt;Person&gt; persons = executor.newDataSource( "persons",
                                                     new Person( "John", 42 ),
                                                     new Person( "Jane", 44 ),
                                                     new Person( "Sally", 4 ) );</programlisting>
</para>
</formalpara>
<simpara>In this case, the example creates the <literal>DataSource</literal> definition directly from the <literal>RuleUnitExecutor</literal> class and binds it to the <literal>"persons"</literal> variable in a single statement.</simpara>
<simpara>The example execution code produces the following output when the relevant <literal>Person</literal> facts are inserted in the <literal>persons</literal> data source:</simpara>
<formalpara>
<title>Example rule unit execution output</title>
<para>
<screen>Sally is NOT adult
John is adult
Jane is adult
Sally is adult</screen>
</para>
</formalpara>
<simpara>The <literal>NotAdult</literal> rule detects a match when evaluating the person <literal>"Sally"</literal>, who is under 18 years old. The rule then modifies
her age to <literal>18</literal> and uses the <literal>drools.run( AdultUnit.class )</literal> method to trigger the execution of the <literal>AdultUnit</literal> rule unit. The <literal>AdultUnit</literal> rule unit contains a rule that can now be executed for all of the 3 <literal>persons</literal> in the <literal>DataSource</literal> definition.</simpara>
<simpara>As an example of the <literal>drools.guard()</literal> method, consider the following <literal>BoxOffice</literal> class and <literal>BoxOfficeUnit</literal> rule unit class:</simpara>
<formalpara>
<title>Example <literal>BoxOffice</literal> class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class BoxOffice {
    private boolean open;

    public BoxOffice( boolean open ) {
        this.open = open;
    }

    public boolean isOpen() {
        return open;
    }

    public void setOpen( boolean open ) {
        this.open = open;
    }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>BoxOfficeUnit</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class BoxOfficeUnit implements RuleUnit {
    private DataSource&lt;BoxOffice&gt; boxOffices;

    public DataSource&lt;BoxOffice&gt; getBoxOffices() {
        return boxOffices;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The example also uses the following <literal>TicketIssuerUnit</literal> rule unit class to keep selling box office tickets for the event as long as at least one box office is open. This rule unit uses <literal>DataSource</literal> definitions of <literal>persons</literal> and <literal>tickets</literal>:</simpara>
<formalpara>
<title>Example <literal>TicketIssuerUnit</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class TicketIssuerUnit implements RuleUnit {
    private DataSource&lt;Person&gt; persons;
    private DataSource&lt;AdultTicket&gt; tickets;

    private List&lt;String&gt; results;

    public TicketIssuerUnit() { }

    public TicketIssuerUnit( DataSource&lt;Person&gt; persons, DataSource&lt;AdultTicket&gt; tickets ) {
        this.persons = persons;
        this.tickets = tickets;
    }

    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    public DataSource&lt;AdultTicket&gt; getTickets() {
        return tickets;
    }

    public List&lt;String&gt; getResults() {
        return results;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>BoxOfficeUnit</literal> rule unit contains a <literal>BoxOfficeIsOpen</literal> DRL rule that uses the <literal>drools.guard( TicketIssuerUnit.class )</literal> method to guard the execution of the <literal>TicketIssuerUnit</literal> rule unit that distributes the event tickets, as shown in the following DRL rule examples:</simpara>
<formalpara>
<title>Example DRL rules with controlled execution using <literal>drools.guard()</literal></title>
<para>
<screen>package org.mypackage.myunit;
unit TicketIssuerUnit;

rule IssueAdultTicket when
    $p: /persons[ age &gt;= 18 ]
then
    tickets.insert(new AdultTicket($p));
end
rule RegisterAdultTicket when
    $t: /tickets
then
    results.add( $t.getPerson().getName() );
end</screen>
</para>
</formalpara>
<screen>package org.mypackage.myunit;
unit BoxOfficeUnit;

rule BoxOfficeIsOpen
  when
    $box: /boxOffices[ open ]
  then
    drools.guard( TicketIssuerUnit.class );
end</screen>
<simpara>In this example, so long as at least one box office is <literal>open</literal>, the guarded <literal>TicketIssuerUnit</literal> rule unit is active and distributes event tickets. When no more box offices are in <literal>open</literal> state, the guarded <literal>TicketIssuerUnit</literal> rule unit is prevented from being executed.</simpara>
<simpara>The following example class illustrates a more complete box office scenario:</simpara>
<formalpara>
<title>Example class for the box office scenario</title>
<para>
<programlisting language="java" linenumbering="unnumbered">DataSource&lt;Person&gt; persons = executor.newDataSource( "persons" );
DataSource&lt;BoxOffice&gt; boxOffices = executor.newDataSource( "boxOffices" );
DataSource&lt;AdultTicket&gt; tickets = executor.newDataSource( "tickets" );

List&lt;String&gt; list = new ArrayList&lt;&gt;();
executor.bindVariable( "results", list );

// Two box offices are open:
BoxOffice office1 = new BoxOffice(true);
FactHandle officeFH1 = boxOffices.insert( office1 );
BoxOffice office2 = new BoxOffice(true);
FactHandle officeFH2 = boxOffices.insert( office2 );

persons.insert(new Person("John", 40));

// Execute `BoxOfficeIsOpen` rule, run `TicketIssuerUnit` rule unit, and execute `RegisterAdultTicket` rule:
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "John", list.get(0) );
list.clear();

persons.insert(new Person("Matteo", 30));

// Execute `RegisterAdultTicket` rule:
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "Matteo", list.get(0) );
list.clear();

// One box office is closed, the other is open:
office1.setOpen(false);
boxOffices.update(officeFH1, office1);
persons.insert(new Person("Mark", 35));
executor.run(BoxOfficeUnit.class);

assertEquals( 1, list.size() );
assertEquals( "Mark", list.get(0) );
list.clear();

// All box offices are closed:
office2.setOpen(false);
boxOffices.update(officeFH2, office2); // Guarding rule is no longer true.
persons.insert(new Person("Edson", 35));
executor.run(BoxOfficeUnit.class); // No execution

assertEquals( 0, list.size() );</programlisting>
</para>
</formalpara>
</section>
<section xml:id="rule_unit_identity_conflicts_2" remap="_rule_unit_identity_conflicts_2">
<title>Rule unit identity conflicts</title>
<simpara>In rule unit execution scenarios with guarded rule units, a rule can guard multiple rule units and at the same time a rule unit can be guarded and then activated by multiple rules. For these two-way guarding scenarios, rule units must have a clearly defined identity to avoid identity conflicts.</simpara>
<simpara>By default, the identity of a rule unit is the rule unit class name and is treated as a singleton class by the <literal>RuleUnitExecutor</literal>. This identification behavior is encoded in the <literal>getUnitIdentity()</literal> default method of the <literal>RuleUnit</literal> interface:</simpara>
<formalpara>
<title>Default identity method in the <literal>RuleUnit</literal> interface</title>
<para>
<programlisting language="java" linenumbering="unnumbered">default Identity getUnitIdentity() {
    return new Identity( getClass() );
}</programlisting>
</para>
</formalpara>
<simpara>In some cases, you may need to override this default identification behavior to avoid conflicting identities between rule units.</simpara>
<simpara>For example, the following <literal>RuleUnit</literal> class contains a <literal>DataSource</literal> definition that accepts any kind of object:</simpara>
<formalpara>
<title>Example <literal>Unit0</literal> rule unit class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Unit0 implements RuleUnit {
    private DataSource&lt;Object&gt; input;

    public DataSource&lt;Object&gt; getInput() {
        return input;
    }
}</programlisting>
</para>
</formalpara>
<simpara>This rule unit contains the following DRL rule that guards another rule unit based on two conditions (in OOPath notation):</simpara>
<formalpara>
<title>Example <literal>GuardAgeCheck</literal> DRL rule in the rule unit</title>
<para>
<screen>package org.mypackage.myunit
unit Unit0

rule GuardAgeCheck
  when
    $i: /input#Integer
    $s: /input#String
  then
    drools.guard( new AgeCheckUnit($i) );
    drools.guard( new AgeCheckUnit($s.length()) );
end</screen>
</para>
</formalpara>
<simpara>The guarded <literal>AgeCheckUnit</literal> rule unit verifies the age of a set of <literal>persons</literal>. The <literal>AgeCheckUnit</literal> contains a <literal>DataSource</literal> definition of the <literal>persons</literal> to check, a <literal>minAge</literal> variable that it verifies against, and a <literal>List</literal> for gathering the results:</simpara>
<formalpara>
<title>Example <literal>AgeCheckUnit</literal> rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class AgeCheckUnit implements RuleUnit {
    private final int minAge;
    private DataSource&lt;Person&gt; persons;
    private List&lt;String&gt; results;

    public AgeCheckUnit( int minAge ) {
        this.minAge = minAge;
    }

    public DataSource&lt;Person&gt; getPersons() {
        return persons;
    }

    public int getMinAge() {
        return minAge;
    }

    public List&lt;String&gt; getResults() {
        return results;
    }
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>AgeCheckUnit</literal> rule unit contains the following DRL rule that performs the verification of the <literal>persons</literal> in the data source:</simpara>
<formalpara>
<title>Example <literal>CheckAge</literal> DRL rule in the rule unit</title>
<para>
<screen>package org.mypackage.myunit
unit AgeCheckUnit

rule CheckAge
  when
    $p : /persons{ age &gt; minAge }
  then
    results.add($p.getName() + "&gt;" + minAge);
end</screen>
</para>
</formalpara>
<simpara>This example creates a <literal>RuleUnitExecutor</literal> class, binds the class to the KIE base that contains these two rule units, and creates
the two <literal>DataSource</literal> definitions for the same rule units:</simpara>
<formalpara>
<title>Example executor and data source definitions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">RuleUnitExecutor executor = RuleUnitExecutor.create().bind( kbase );

DataSource&lt;Object&gt; input = executor.newDataSource( "input" );
DataSource&lt;Person&gt; persons = executor.newDataSource( "persons",
                                                     new Person( "John", 42 ),
                                                     new Person( "Sally", 4 ) );

List&lt;String&gt; results = new ArrayList&lt;&gt;();
executor.bindVariable( "results", results );</programlisting>
</para>
</formalpara>
<simpara>You can now insert some objects into the input data source and execute the <literal>Unit0</literal> rule unit:</simpara>
<formalpara>
<title>Example rule unit execution with inserted objects</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ds.insert("test");
ds.insert(3);
ds.insert(4);
executor.run(Unit0.class);</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example results list from the execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">[Sally&gt;3, John&gt;3]</programlisting>
</para>
</formalpara>
<simpara>In this example, the rule unit named <literal>AgeCheckUnit</literal> is considered a singleton class and then executed only once, with the <literal>minAge</literal>
variable set to <literal>3</literal>. Both the String <literal>"test"</literal> and the Integer <literal>4</literal> inserted into the input data source can also trigger a second execution with the <literal>minAge</literal> variable set to <literal>4</literal>. However, the second execution does not occur because another rule unit with the same identity has already been evaluated.</simpara>
<simpara>To resolve this rule unit identity conflict, override the <literal>getUnitIdentity()</literal> method in the <literal>AgeCheckUnit</literal> class to include also the <literal>minAge</literal> variable in the rule unit identity:</simpara>
<formalpara>
<title>Modified <literal>AgeCheckUnit</literal> rule unit to override the <literal>getUnitIdentity()</literal> method</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class AgeCheckUnit implements RuleUnit {

    ...

    @Override
    public Identity getUnitIdentity() {
        return new Identity(getClass(), minAge);
    }
}</programlisting>
</para>
</formalpara>
<simpara>With this override in place, the previous example rule unit execution produces the following output:</simpara>
<formalpara>
<title>Example results list from executing the modified rule unit</title>
<para>
<programlisting language="java" linenumbering="unnumbered">[John&gt;4, Sally&gt;3, John&gt;3]</programlisting>
</para>
</formalpara>
<simpara>The rule units with <literal>minAge</literal> set to <literal>3</literal> and <literal>4</literal> are now considered two different rule units and both are executed.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="phreak-algorithm-con_decision-engine">
<title>Phreak rule algorithm in the decision engine</title>
<simpara>The decision engine in Red Hat Decision Manager uses the Phreak algorithm for rule evaluation. Phreak evolved from the Rete algorithm, including the enhanced Rete algorithm ReteOO that was introduced in previous versions of Red Hat Decision Manager for object-oriented systems. Overall, Phreak is more scalable than Rete and ReteOO, and is faster in large systems.</simpara>
<simpara>While Rete is considered eager (immediate rule evaluation) and data oriented, Phreak is considered lazy (delayed rule evaluation) and goal oriented. The Rete algorithm performs many actions during the insert, update, and delete actions in order to find partial matches for all rules. This eagerness of the Rete algorithm during rule matching requires a lot of time before eventually executing rules, especially in large systems. With Phreak, this partial matching of rules is delayed deliberately to handle large amounts of data more efficiently.</simpara>
<simpara>The Phreak algorithm adds the following set of enhancements to previous Rete algorithms:</simpara>
<itemizedlist>
<listitem>
<simpara>Three layers of contextual memory: Node, segment, and rule memory types</simpara>
</listitem>
<listitem>
<simpara>Rule-based, segment-based, and node-based linking</simpara>
</listitem>
<listitem>
<simpara>Lazy (delayed) rule evaluation</simpara>
</listitem>
<listitem>
<simpara>Stack-based evaluations with pause and resume</simpara>
</listitem>
<listitem>
<simpara>Isolated rule evaluation</simpara>
</listitem>
<listitem>
<simpara>Set-oriented propagations</simpara>
</listitem>
</itemizedlist>
<section xml:id="phreak-rule-evaluation-con_decision-engine">
<title>Rule evaluation in Phreak</title>
<simpara>When the decision engine starts, all rules are considered to be <emphasis>unlinked</emphasis> from pattern-matching data that can trigger the rules. At this stage, the Phreak algorithm in the decision engine does not evaluate the rules. The <literal>insert</literal>, <literal>update</literal>, and <literal>delete</literal> actions are queued, and Phreak uses a heuristic, based on the rule most likely to result in execution, to calculate and select the next rule for evaluation. When all the required input values are populated for a rule, the rule is considered to be <emphasis>linked</emphasis> to the relevant pattern-matching data. Phreak then creates a goal that represents this rule and places the goal into a priority queue that is ordered by rule salience. Only the rule for which the goal was created is evaluated, and other potential rule evaluations are delayed. While individual rules are evaluated, node sharing is still achieved through the process of segmentation.</simpara>
<simpara>Unlike the tuple-oriented Rete, the Phreak propagation is collection oriented. For the rule that is being evaluated, the decision engine accesses the first node and processes all queued insert, update, and delete actions. The results are added to a set, and the set is propagated to the child node. In the child node, all queued insert, update, and delete actions are processed, adding the results to the same set. The set is then propagated to the next child node and the same process repeats until it reaches the terminal node. This cycle creates a batch process effect that can provide performance advantages for certain rule constructs.</simpara>
<simpara>The linking and unlinking of rules happens through a layered bit-mask system, based on network segmentation. When the rule network is built, segments are created for rule network nodes that are shared by the same set of rules. A rule is composed of a path of segments. In case a rule does not share any node with any other rule, it becomes a single segment.</simpara>
<simpara>A bit-mask offset is assigned to each node in the segment. Another bit mask is assigned to each segment in the path of the rule according to these requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>If at least one input for a node exists, the node bit is set to the <literal>on</literal> state.</simpara>
</listitem>
<listitem>
<simpara>If each node in a segment has the bit set to the <literal>on</literal> state, the segment bit is also set to the <literal>on</literal> state.</simpara>
</listitem>
<listitem>
<simpara>If any node bit is set to the <literal>off</literal> state, the segment is also set to the <literal>off</literal> state.</simpara>
</listitem>
<listitem>
<simpara>If each segment in the path of the rule is set to the <literal>on</literal> state, the rule is considered linked, and a goal is created to schedule the rule for evaluation.</simpara>
</listitem>
</itemizedlist>
<simpara>The same bit-mask technique is used to track modified nodes, segments, and rules. This tracking ability enables an already linked rule to be unscheduled from evaluation if it has been modified since the evaluation goal for it was created. As a result, no rules can ever evaluate partial matches.</simpara>
<simpara>This process of rule evaluation is possible in Phreak because, as opposed to a single unit of memory in Rete, Phreak has three layers of contextual memory with node, segment, and rule memory types. This layering enables much more contextual understanding during the evaluation of a rule.</simpara>
<figure>
<title>Phreak three-layered memory system</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/LayeredMemory_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>LayeredMemory enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following examples illustrate how rules are organized and evaluated in this three-layered memory system in Phreak.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis> A single rule (R1) with three patterns: A, B and C. The rule forms a single segment, with bits 1, 2, and 4 for the nodes. The single segment has a bit offset of 1.</simpara>
<figure>
<title>Example 1: Single rule</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/segment1_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>segment1 enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara><emphasis role="strong">Example 2:</emphasis> Rule R2 is added and shares pattern A.</simpara>
<figure>
<title>Example 2: Two rules with pattern sharing</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/segment2_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>segment2 enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>Pattern A is placed in its own segment, resulting in two segments for each rule. Those two segments form a path for their respective rules. The first segment is shared by both paths. When pattern A is linked, the segment becomes linked. The segment then iterates over each path that the segment is shared by, setting the bit 1 to <literal>on</literal>. If patterns B and C are later turned on, the second segment for path R1 is linked, and this causes bit 2 to be turned on for R1. With bit 1 and bit 2 turned on for R1, the rule is now linked and a goal is created to schedule the rule for later evaluation and execution.</simpara>
<simpara>When a rule is evaluated, the segments enable the results of the matching to be shared. Each segment has a staging memory to queue all inserts, updates, and deletes for that segment. When R1 is evaluated, the rule processes pattern A, and this results in a set of tuples. The algorithm detects a segmentation split, creates peered tuples for each insert, update, and delete in the set, and adds them to the R2 staging memory. Those tuples are then merged with any existing staged tuples and are executed when R2 is eventually evaluated.</simpara>
<simpara><emphasis role="strong">Example 3:</emphasis> Rules R3 and R4 are added and share patterns A and B.</simpara>
<figure>
<title>Example 3: Three rules with pattern sharing</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/segment3_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>segment3 enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>Rules R3 and R4 have three segments and R1 has two segments. Patterns A and B are shared by R1, R3, and R4, while pattern D is shared by R3 and R4.</simpara>
<simpara><emphasis role="strong">Example 4:</emphasis> A single rule (R1) with a subnetwork and no pattern sharing.</simpara>
<figure>
<title>Example 4: Single rule with a subnetwork and no pattern sharing</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/segment4_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>segment4 enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>Subnetworks are formed when a <literal>Not</literal>, <literal>Exists</literal>, or <literal>Accumulate</literal> node contains more than one element. In this example, the element <literal>B not( C )</literal> forms the subnetwork. The element <literal>not( C )</literal> is a single element that does not require a subnetwork and is therefore merged inside of the <literal>Not</literal> node. The subnetwork uses a dedicated segment. Rule R1 still has a path of two segments and the subnetwork forms another inner path. When the subnetwork is linked, it is also linked in the outer segment.</simpara>
<simpara><emphasis role="strong">Example 5:</emphasis> Rule R1 with a subnetwork that is shared by rule R2.</simpara>
<figure>
<title>Example 5: Two rules, one with a subnetwork and pattern sharing</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/HybridReasoning/segment5_enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>segment5 enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>The subnetwork nodes in a rule can be shared by another rule that does not have a subnetwork. This sharing causes the subnetwork segment to be split into two segments.</simpara>
<simpara>Constrained <literal>Not</literal> nodes and <literal>Accumulate</literal> nodes can never unlink a segment, and are always considered to have their bits turned on.</simpara>
<simpara>The Phreak evaluation algorithm is stack based instead of method-recursion based. Rule evaluation can be paused and resumed at any time when a <literal>StackEntry</literal> is used to represent the node currently being evaluated.</simpara>
<simpara>When a rule evaluation reaches a subnetwork, a <literal>StackEntry</literal> object is created for the outer path segment and the subnetwork segment. The subnetwork segment is evaluated first, and when the set reaches the end of the subnetwork path, the segment is merged into a staging list for the outer node that the segment feeds into. The previous <literal>StackEntry</literal> object is then resumed and can now process the results of the subnetwork. This process has the added benefit, especially for <literal>Accumulate</literal> nodes, that all work is completed in a batch, before propagating to the child node.</simpara>
<simpara>The same stack system is used for efficient backward chaining. When a rule evaluation reaches a query node, the evaluation is paused and the query is added to the stack. The query is then evaluated to produce a result set, which is saved in a memory location for the resumed <literal>StackEntry</literal> object to pick up and propagate to the child node. If the query itself called other queries, the process repeats, while the current query is paused and a new evaluation is set up for the current query node.</simpara>
<section xml:id="forward-and-backward-chaining-con_decision-engine">
<title>Rule evaluation with forward and backward chaining</title>
<simpara>The decision engine in Red Hat Decision Manager is a hybrid reasoning system that uses both forward chaining and backward chaining to evaluate rules. A forward-chaining rule system is a data-driven system that starts with a fact in the working memory of the decision engine and reacts to changes to that fact. When objects are inserted into working memory, any rule conditions that become true as a result of the change are scheduled for execution by the agenda.</simpara>
<simpara>In contrast, a backward-chaining rule system is a goal-driven system that starts with a conclusion that the decision engine attempts to satisfy, often using recursion. If the system cannot reach the conclusion or goal, it searches for subgoals, which are conclusions that complete part of the current goal. The system continues this process until either the initial conclusion is satisfied or all subgoals are satisfied.</simpara>
<simpara>The following diagram illustrates how the decision engine evaluates rules using forward chaining overall with a backward-chaining segment in the logic flow:</simpara>
<figure>
<title>Rule evaluation logic using forward and backward chaining</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/RuleEvaluation_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>RuleEvaluation Enterprise</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="rule-base-configuration-con_decision-engine">
<title>Rule base configuration</title>
<simpara>Red Hat Decision Manager contains a <literal>RuleBaseConfiguration.java</literal> object that you can use to configure exception handler settings, multithreaded execution, and sequential mode in the decision engine.</simpara>
<simpara>For the rule base configuration options,
download the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> ZIP file from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> and navigate to <literal>~/rhdm-7.10.0-sources/src/drools-$VERSION/drools-core/src/main/java/org/drools/core/RuleBaseConfiguration.java</literal>.</simpara>
<simpara>The following rule base configuration options are available for the decision engine:</simpara>
<variablelist>
<varlistentry>
<term>drools.consequenceExceptionHandler</term>
<listitem>
<simpara>When configured, this system property defines the class that manages the exceptions thrown by rule consequences. You can use this property to specify a custom exception handler for rule evaluation in the decision engine.</simpara>
<simpara>Default value: <literal>org.drools.core.runtime.rule.impl.DefaultConsequenceExceptionHandler</literal></simpara>
<simpara>You can specify the custom exception handler using one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify the exception handler in a system property:</simpara>
<screen>drools.consequenceExceptionHandler=org.drools.core.runtime.rule.impl.MyCustomConsequenceExceptionHandler</screen>
</listitem>
<listitem>
<simpara>Specify the exception handler while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration(); kieBaseConf.setOption(ConsequenceExceptionHandlerOption.get(MyCustomConsequenceExceptionHandler.class));
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>drools.multithreadEvaluation</term>
<listitem>
<simpara>When enabled, this system property enables the decision engine to evaluate rules in parallel by dividing the Phreak rule network into independent partitions. You can use this property to increase the speed of rule evaluation for specific rule bases.</simpara>
<simpara>Default value: <literal>false</literal></simpara>
<simpara>You can enable multithreaded evaluation using one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Enable the multithreaded evaluation system property:</simpara>
<screen>drools.multithreadEvaluation=true</screen>
</listitem>
<listitem>
<simpara>Enable multithreaded evaluation while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration();
kieBaseConf.setOption(MultithreadEvaluationOption.YES);
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
</itemizedlist>
<warning>
<simpara>Rules that use queries, salience, or agenda groups are currently not supported by the parallel decision engine. If these rule elements are present in the KIE base, the compiler emits a warning and automatically switches back to single-threaded evaluation. However, in some cases, the decision engine might not detect the unsupported rule elements and rules might be evaluated incorrectly. For example, the decision engine might not detect when rules rely on implicit salience given by rule ordering inside the DRL file, resulting in incorrect evaluation due to the unsupported salience attribute.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>drools.sequential</term>
<listitem>
<simpara>When enabled, this system property enables sequential mode in the decision engine. In sequential mode, the decision engine evaluates rules one time in the order that they are listed in the decision engine agenda without regard to changes in the working memory. This means that the decision engine ignores any <literal>insert</literal>, <literal>modify</literal>, or <literal>update</literal> statements in rules and executes rules in a single sequence. As a result, rule execution may be faster in sequential mode, but important updates may not be applied to your rules. You can use this property if you use stateless KIE sessions and you do not want the execution of rules to influence subsequent rules in the agenda. Sequential mode applies to stateless KIE sessions only.</simpara>
<simpara>Default value: <literal>false</literal></simpara>
<simpara>You can enable sequential mode using one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Enable the sequential mode system property:</simpara>
<screen>drools.sequential=true</screen>
</listitem>
<listitem>
<simpara>Enable sequential mode while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration();
kieBaseConf.setOption(SequentialOption.YES);
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
<listitem>
<simpara>Enable sequential mode in the KIE module descriptor file (<literal>kmodule.xml</literal>) for a specific Red Hat Decision Manager project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" sequential="true" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="phreak-sequential-mode-con_decision-engine">
<title>Sequential mode in Phreak</title>
<simpara>Sequential mode is an advanced rule base configuration in the decision engine, supported by Phreak, that enables the decision engine to evaluate rules one time in the order that they are listed in the decision engine agenda without regard to changes in the working memory. In sequential mode, the decision engine ignores any <literal>insert</literal>, <literal>modify</literal>, or <literal>update</literal> statements in rules and executes rules in a single sequence. As a result, rule execution may be faster in sequential mode, but important updates may not be applied to your rules.</simpara>
<simpara>Sequential mode applies to only stateless KIE sessions because stateful KIE sessions inherently use data from previously invoked KIE sessions. If you use a stateless KIE session and you want the execution of rules to influence subsequent rules in the agenda, then do not enable sequential mode. Sequential mode is disabled by default in the decision engine.</simpara>
<simpara>To enable sequential mode, use one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the system property <literal>drools.sequential</literal> to <literal>true</literal>.</simpara>
</listitem>
<listitem>
<simpara>Enable sequential mode while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration();
kieBaseConf.setOption(SequentialOption.YES);
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
<listitem>
<simpara>Enable sequential mode in the KIE module descriptor file (<literal>kmodule.xml</literal>) for a specific Red Hat Decision Manager project:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" sequential="true" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>To configure sequential mode to use a dynamic agenda, use one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the system property <literal>drools.sequential.agenda</literal> to <literal>dynamic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Set the sequential agenda option while creating the KIE base programmatically:</simpara>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get();
KieBaseConfiguration kieBaseConf = ks.newKieBaseConfiguration();
kieBaseConf.setOption(SequentialAgendaOption.DYNAMIC);
KieBase kieBase = kieContainer.newKieBase(kieBaseConf);</programlisting>
</listitem>
</itemizedlist>
<simpara>When you enable sequential mode, the decision engine evaluates rules in the following way:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Rules are ordered by salience and position in the rule set.</simpara>
</listitem>
<listitem>
<simpara>An element for each possible rule match is created. The element position indicates the execution order.</simpara>
</listitem>
<listitem>
<simpara>Node memory is disabled, with the exception of the right-input object memory.</simpara>
</listitem>
<listitem>
<simpara>The left-input adapter node propagation is disconnected and the object with the node is referenced in a <literal>Command</literal> object. The <literal>Command</literal> object is added to a list in the working memory for later execution.</simpara>
</listitem>
<listitem>
<simpara>All objects are asserted, and then the list of <literal>Command</literal> objects is checked and executed.</simpara>
</listitem>
<listitem>
<simpara>All matches that result from executing the list are added to elements based on the sequence number of the rule.</simpara>
</listitem>
<listitem>
<simpara>The elements that contain matches are executed in a sequence. If you set a maximum number of rule executions, the decision engine activates no more than that number of rules in the agenda for execution.</simpara>
</listitem>
</orderedlist>
<simpara>In sequential mode, the <literal>LeftInputAdapterNode</literal> node creates a <literal>Command</literal> object and adds it to a list in the working memory of the decision engine. This <literal>Command</literal> object contains references to the <literal>LeftInputAdapterNode</literal> node and the propagated object. These references stop any left-input propagations at insertion time so that the right-input propagation never needs to attempt to join the left inputs. The references also avoid the need for the left-input memory.</simpara>
<simpara>All nodes have their memory turned off, including the left-input tuple memory, but excluding the right-input object memory. After all the assertions are finished and the right-input memory of all the objects is populated, the decision engine iterates over the list of <literal>LeftInputAdatperNode</literal> <literal>Command</literal> objects. The objects propagate down the network, attempting to join the right-input objects, but they are not retained in the left input.</simpara>
<simpara>The agenda with a priority queue to schedule the tuples is replaced by an element for each rule. The sequence number of the <literal>RuleTerminalNode</literal> node indicates the element where to place the match. After all <literal>Command</literal> objects have finished, the elements are checked and existing matches are executed. To improve performance, the first and the last populated cell in the elements are retained.</simpara>
<simpara>When the network is constructed, each <literal>RuleTerminalNode</literal> node receives a sequence number based on its salience number and the order in which it was added to the network.</simpara>
<simpara>The right-input node memories are typically hash maps for fast object deletion. Because object deletions are not supported, Phreak uses an object list when the values of the object are not indexed. For a large number of objects, indexed hash maps provide a performance increase. If an object has only a few instances, Phreak uses an object list instead of an index.</simpara>
</section>
</chapter>
<chapter xml:id="cep-con_decision-engine">
<title>Complex event processing (CEP)</title>
<simpara>In Red Hat Decision Manager, an event is a record of a significant change of state in the application domain at a point in time. Depending on how the domain is modeled, the change of state may be represented by a single event, multiple atomic events, or hierarchies of correlated events. From a complex event processing (CEP) perspective, an event is a type of fact or object that occurs at a specific point in time, and a business rule is a definition of how to react to the data from that fact or object. For example, in a stock broker application, a change in security prices, a change in ownership from seller to buyer, or a change in an account holder’s balance are all considered to be events because a change has occurred in the state of the application domain at a given time.</simpara>
<simpara>The decision engine in Red Hat Decision Manager uses complex event processing (CEP) to detect and process multiple events within a collection of events, to uncover relationships that exist between events, and to infer new data from the events and their relationships.</simpara>
<simpara>CEP use cases share several requirements and goals with business rule use cases.</simpara>
<simpara>From a business perspective, business rule definitions are often defined based on the occurrence of scenarios triggered by events. In the following examples, events form the basis of business rules:</simpara>
<itemizedlist>
<listitem>
<simpara>In an algorithmic trading application, a rule performs an action if the security price increases by X percent above the day opening price. The price increases are denoted by events on a stock trading application.</simpara>
</listitem>
<listitem>
<simpara>In a monitoring application, a rule performs an action if the temperature in the server room increases X degrees in Y minutes. The sensor readings are denoted by events.</simpara>
</listitem>
</itemizedlist>
<simpara>From a technical perspective, business rule evaluation and CEP have the following key similarities:</simpara>
<itemizedlist>
<listitem>
<simpara>Both business rule evaluation and CEP require seamless integration with the enterprise infrastructure and applications. This is particularly important with life-cycle management, auditing, and security.</simpara>
</listitem>
<listitem>
<simpara>Both business rule evaluation and CEP have functional requirements such as pattern matching, and non-functional requirements such as response time limits and query-rule explanations.</simpara>
</listitem>
</itemizedlist>
<simpara>CEP scenarios have the following key characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>Scenarios usually process large numbers of events, but only a small percentage of the events are relevant.</simpara>
</listitem>
<listitem>
<simpara>Events are usually immutable and represent a record of change in state.</simpara>
</listitem>
<listitem>
<simpara>Rules and queries run against events and must react to detected event patterns.</simpara>
</listitem>
<listitem>
<simpara>Related events usually have a strong temporal relationship.</simpara>
</listitem>
<listitem>
<simpara>Individual events are not prioritized. The CEP system prioritizes patterns of related events and the relationships between them.</simpara>
</listitem>
<listitem>
<simpara>Events usually need to be composed and aggregated.</simpara>
</listitem>
</itemizedlist>
<simpara>Given these common CEP scenario characteristics, the CEP system in Red Hat Decision Manager supports the following features and functions to optimize event processing:</simpara>
<itemizedlist>
<listitem>
<simpara>Event processing with proper semantics</simpara>
</listitem>
<listitem>
<simpara>Event detection, correlation, aggregation, and composition</simpara>
</listitem>
<listitem>
<simpara>Event stream processing</simpara>
</listitem>
<listitem>
<simpara>Temporal constraints to model the temporal relationships between events</simpara>
</listitem>
<listitem>
<simpara>Sliding windows of significant events</simpara>
</listitem>
<listitem>
<simpara>Session-scoped unified clock</simpara>
</listitem>
<listitem>
<simpara>Required volumes of events for CEP use cases</simpara>
</listitem>
<listitem>
<simpara>Reactive rules</simpara>
</listitem>
<listitem>
<simpara>Adapters for event input into the decision engine (pipeline)</simpara>
</listitem>
</itemizedlist>
<section xml:id="cep-events-con_decision-engine">
<title>Events in complex event processing</title>
<simpara>In Red Hat Decision Manager, an event is a record of a significant change of state in the application domain at a point in time. Depending on how the domain is modeled, the change of state may be represented by a single event, multiple atomic events, or hierarchies of correlated events. From a complex event processing (CEP) perspective, an event is a type of fact or object that occurs at a specific point in time, and a business rule is a definition of how to react to the data from that fact or object. For example, in a stock broker application, a change in security prices, a change in ownership from seller to buyer, or a change in an account holder’s balance are all considered to be events because a change has occurred in the state of the application domain at a given time.</simpara>
<simpara>Events have the following key characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Are immutable:</emphasis> An event is a record of change that has occurred at some time in the past and cannot be changed.</simpara>
<note>
<simpara>The decision engine does not enforce immutability on the Java objects that represent events. This behavior makes event data enrichment possible. Your application should be able to populate unpopulated event attributes, and these attributes are used by the decision engine to enrich the event with inferred data. However, you should not change event attributes that have already been populated.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">Have strong temporal constraints:</emphasis> Rules involving events usually require the correlation of multiple events that occur at different points in time relative to each other.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Have managed life cycles:</emphasis> Because events are immutable and have temporal constraints, they are usually only relevant for a specified period of time. This means that the decision engine can automatically manage the life cycle of events.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Can use sliding windows:</emphasis> You can define sliding windows of time or length with events. A sliding time window is a specified period of time during which events can be processed. A sliding length window is a specified number of events that can be processed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cep-events-proc_decision-engine">
<title>Declaring facts as events</title>
<simpara>You can declare facts as events in your Java class or DRL rule file so that the decision engine handles the facts as events during complex event processing. You can declare the facts as interval-based events or point-in-time events. Interval-based events have a duration time and persist in the working memory of the decision engine until their duration time has lapsed. Point-in-time events have no duration and are essentially interval-based events with a duration of zero.</simpara>
<formalpara>
<title>Procedure</title>
<para>For the relevant fact type in your Java class or DRL rule file, enter the <literal>@role( event )</literal> metadata tag and parameter. The <literal>@role</literal> metadata tag accepts the following two values:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>fact</literal>: (Default) Declares the type as a regular fact</simpara>
</listitem>
<listitem>
<simpara><literal>event</literal>: Declares the type as an event</simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following snippet declares that the <literal>StockPoint</literal> fact type in a stock broker application must be handled as an event:</simpara>
<formalpara>
<title>Declare fact type as an event</title>
<para>
<screen>import some.package.StockPoint

declare StockPoint
  @role( event )
end</screen>
</para>
</formalpara>
<simpara>If <literal>StockPoint</literal> is a fact type declared in the DRL rule file instead of in a pre-existing class, you can declare the event in-line in your application code:</simpara>
<formalpara>
<title>Declare fact type in-line and assign it to event role</title>
<para>
<screen>declare StockPoint
  @role( event )

  datetime : java.util.Date
  symbol : String
  price : double
end</screen>
</para>
</formalpara>
</section>
<section xml:id="drl-declarations-metadata-tags-ref_decision-engine">
<title>Metadata tags for events</title>
<simpara>The decision engine uses the following metadata tags for events that are inserted into the working memory of the decision engine. You can change the default metadata tag values in your Java class or DRL rule file as needed.</simpara>
<note>
<simpara>The examples in this section that refer to the <literal>VoiceCall</literal> class assume that the sample application domain model includes the following class details:</simpara>
<formalpara>
<title>VoiceCall fact class in an example Telecom domain model</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class VoiceCall {
  private String  originNumber;
  private String  destinationNumber;
  private Date    callDateTime;
  private long    callDuration;  // in milliseconds

  // Constructors, getters, and setters
}</programlisting>
</para>
</formalpara>
</note>
<variablelist>
<varlistentry>
<term>@role</term>
<listitem>
<simpara>This tag determines whether a given fact type is handled as a regular fact or an event in the decision engine during complex event processing.</simpara>
<simpara>Default parameter: <literal>fact</literal></simpara>
<simpara>Supported parameters: <literal>fact</literal>, <literal>event</literal></simpara>
<screen>@role( fact | event )</screen>
<formalpara>
<title>Example: Declare VoiceCall as event type</title>
<para>
<screen>declare VoiceCall
  @role( event )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@timestamp</term>
<listitem>
<simpara>This tag is automatically assigned to every event in the decision engine. By default, the time is provided by the session clock and assigned to the event when it is inserted into the working memory of the decision engine. You can specify a custom time stamp attribute instead of the default time stamp added by the session clock.</simpara>
<simpara>Default parameter: The time added by the decision engine session clock</simpara>
<simpara>Supported parameters: Session clock time or custom time stamp attribute</simpara>
<screen>@timestamp( &lt;attributeName&gt; )</screen>
<formalpara>
<title>Example: Declare VoiceCall timestamp attribute</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@duration</term>
<listitem>
<simpara>This tag determines the duration time for events in the decision engine. Events can be interval-based events or point-in-time events. Interval-based events have a duration time and persist in the working memory of the decision engine until their duration time has lapsed. Point-in-time events have no duration and are essentially interval-based events with a duration of zero. By default, every event in the decision engine has a duration of zero. You can specify a custom duration attribute instead of the default.</simpara>
<simpara>Default parameter: Null (zero)</simpara>
<simpara>Supported parameters: Custom duration attribute</simpara>
<screen>@duration( &lt;attributeName&gt; )</screen>
<formalpara>
<title>Example: Declare VoiceCall duration attribute</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
  @duration( callDuration )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@expires</term>
<listitem>
<simpara>This tag determines the time duration before an event expires in the working memory of the decision engine. By default, an event expires when the event can no longer match and activate any of the current rules. You can define an amount of time after which an event should expire. This tag definition also overrides the implicit expiration offset calculated from temporal constraints and sliding windows in the KIE base. This tag is available only when the decision engine is running in stream mode.</simpara>
<simpara>Default parameter: Null (event expires after event can no longer match and activate rules)</simpara>
<simpara>Supported parameters: Custom <literal>timeOffset</literal> attribute in the format <literal>[<emphasis role="marked">#d][#h][#m][#s][</emphasis>[ms]]</literal></simpara>
<screen>@expires( &lt;timeOffset&gt; )</screen>
<formalpara>
<title>Example: Declare expiration offset for VoiceCall events</title>
<para>
<screen>declare VoiceCall
  @role( event )
  @timestamp( callDateTime )
  @duration( callDuration )
  @expires( 1h35m )
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="cep-modes-con_decision-engine">
<title>Event processing modes in the decision engine</title>
<simpara>The decision engine runs in either cloud mode or stream mode. In cloud mode, the decision engine processes facts as facts with no temporal constraints, independent of time, and in no particular order. In stream mode, the decision engine processes facts as events with strong temporal constraints, in real time or near real time. Stream mode uses synchronization to make event processing possible in Red Hat Decision Manager.</simpara>
<variablelist>
<varlistentry>
<term>Cloud mode</term>
<listitem>
<simpara>Cloud mode is the default operating mode of the decision engine. In cloud mode, the decision engine treats events as an unordered cloud. Events still have time stamps, but the decision engine running in cloud mode cannot draw relevance from the time stamp because cloud mode ignores the present time. This mode uses the rule constraints to find the matching tuples to activate and execute rules.</simpara>
<simpara>Cloud mode does not impose any kind of additional requirements on facts. However, because the decision engine in this mode has no concept of time, it cannot use temporal features such as sliding windows or automatic life-cycle management. In cloud mode, events must be explicitly retracted when they are no longer needed.</simpara>
<simpara>The following requirements are not imposed in cloud mode:</simpara>
<itemizedlist>
<listitem>
<simpara>No clock synchronization because the decision engine has no notion of time</simpara>
</listitem>
<listitem>
<simpara>No ordering of events because the decision engine processes events as an unordered cloud, against which the decision engine match rules</simpara>
</listitem>
</itemizedlist>
<simpara>You can specify cloud mode either by setting the system property in the relevant configuration files or by using the Java client API:</simpara>
<formalpara>
<title>Set cloud mode using system property</title>
<para>
<screen>drools.eventProcessingMode=cloud</screen>
</para>
</formalpara>
<formalpara>
<title>Set cloud mode using Java client API</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.conf.EventProcessingOption;
import org.kie.api.KieBaseConfiguration;
import org.kie.api.KieServices.Factory;

KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();

config.setOption(EventProcessingOption.CLOUD);</programlisting>
</para>
</formalpara>
<simpara>You can also specify cloud mode using the <literal>eventProcessingMode="&lt;mode&gt;"</literal> KIE base attribute in the KIE module descriptor file (<literal>kmodule.xml</literal>) for a specific Red Hat Decision Manager project:</simpara>
<formalpara>
<title>Set cloud mode using project <literal>kmodule.xml</literal> file</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" eventProcessingMode="cloud" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Stream mode</term>
<listitem>
<simpara>Stream mode enables the decision engine to process events chronologically and in real time as they are inserted into the decision engine. In stream mode, the decision engine synchronizes streams of events (so that events in different streams can be processed in chronological order), implements sliding windows of time or length, and enables automatic life-cycle management.</simpara>
<simpara>The following requirements apply to stream mode:</simpara>
<itemizedlist>
<listitem>
<simpara>Events in each stream must be ordered chronologically.</simpara>
</listitem>
<listitem>
<simpara>A session clock must be present to synchronize event streams.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Your application does not need to enforce ordering events between streams, but using event streams that have not been synchronized may cause unexpected results.</simpara>
</note>
<simpara>You can specify stream mode either by setting the system property in the relevant configuration files or by using the Java client API:</simpara>
<formalpara>
<title>Set stream mode using system property</title>
<para>
<screen>drools.eventProcessingMode=stream</screen>
</para>
</formalpara>
<formalpara>
<title>Set stream mode using Java client API</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.conf.EventProcessingOption;
import org.kie.api.KieBaseConfiguration;
import org.kie.api.KieServices.Factory;

KieBaseConfiguration config = KieServices.Factory.get().newKieBaseConfiguration();

config.setOption(EventProcessingOption.STREAM);</programlisting>
</para>
</formalpara>
<simpara>You can also specify stream mode using the <literal>eventProcessingMode="&lt;mode&gt;"</literal> KIE base attribute in the KIE module descriptor file (<literal>kmodule.xml</literal>) for a specific Red Hat Decision Manager project:</simpara>
<formalpara>
<title>Set stream mode using project <literal>kmodule.xml</literal> file</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule&gt;
  ...
  &lt;kbase name="KBase2" default="false" eventProcessingMode="stream" packages="org.domain.pkg2, org.domain.pkg3" includes="KBase1"&gt;
    ...
  &lt;/kbase&gt;
  ...
&lt;/kmodule&gt;</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="cep-negative-patterns_decision-engine">
<title>Negative patterns in decision engine stream mode</title>
<simpara>A negative pattern is a pattern for conditions that are not met. For example, the following DRL rule activates a fire alarm if a fire is detected and the sprinkler is not activated:</simpara>
<formalpara>
<title>Fire alarm rule with a negative pattern</title>
<para>
<screen>rule "Sound the alarm"
when
  $f : FireDetected()
  not(SprinklerActivated())
then
  // Sound the alarm.
end</screen>
</para>
</formalpara>
<simpara>In cloud mode, the decision engine assumes all facts (regular facts and events) are known in advance and evaluates negative patterns immediately. In stream mode, the decision engine can support temporal constraints on facts to wait for a set time before activating a rule.</simpara>
<simpara>The same example rule in stream mode activates the fire alarm as usual, but applies a 10-second delay.</simpara>
<formalpara>
<title>Fire alarm rule with a negative pattern and time delay (stream mode only)</title>
<para>
<screen>rule "Sound the alarm"
when
  $f : FireDetected()
  not(SprinklerActivated(this after[0s,10s] $f))
then
  // Sound the alarm.
end</screen>
</para>
</formalpara>
<simpara>The following modified fire alarm rule expects one <literal>Heartbeat</literal> event to occur every 10 seconds. If the expected event does not occur, the rule is executed. This rule uses the same type of object in both the first pattern and in the negative pattern. The negative pattern has the temporal constraint to wait 0 to 10 seconds before executing and excludes the <literal>Heartbeat</literal> event bound to <literal>$h</literal> so that the rule can be executed. The bound event <literal>$h</literal> must be explicitly excluded in order for the rule to be executed because the temporal constraint <literal>[0s, …​]</literal> does not inherently exclude that event from being matched again.</simpara>
<formalpara>
<title>Fire alarm rule excluding a bound event in a negative pattern (stream mode only)</title>
<para>
<screen>rule "Sound the alarm"
when
  $h: Heartbeat() from entry-point "MonitoringStream"
  not(Heartbeat(this != $h, this after[0s,10s] $h) from entry-point "MonitoringStream")
then
  // Sound the alarm.
end</screen>
</para>
</formalpara>
</section>
</section>
<section xml:id="property-change-listeners-con_decision-engine">
<title>Property-change settings and listeners for fact types</title>
<simpara>By default, the decision engine does not re-evaluate all fact patterns for fact types each time a rule is triggered, but instead reacts only to modified properties that are constrained or bound inside a given pattern. For example, if a rule calls <literal>modify()</literal> as part of the rule actions but the action does not generate new data in the KIE base, the decision engine does not automatically re-evaluate all fact patterns because no data was modified. This property reactivity behavior prevents unwanted recursions in the KIE base and results in more efficient rule evaluation. This behavior also means that you do not always need to use the <literal>no-loop</literal> rule attribute to avoid infinite recursion.</simpara>
<simpara>You can modify or disable this property reactivity behavior with the following <literal>KnowledgeBuilderConfiguration</literal> options, and then use a property-change setting in your Java class or DRL files to fine-tune property reactivity as needed:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ALWAYS</literal>: (Default) All types are property reactive, but you can disable property reactivity for a specific type by using the <literal>@classReactive</literal> property-change setting.</simpara>
</listitem>
<listitem>
<simpara><literal>ALLOWED</literal>: No types are property reactive, but you can enable property reactivity for a specific type by using the <literal>@propertyReactive</literal> property-change setting.</simpara>
</listitem>
<listitem>
<simpara><literal>DISABLED</literal>: No types are property reactive. All property-change listeners are ignored.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example property reactivity setting in KnowledgeBuilderConfiguration</title>
<para>
<screen>KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
config.setOption(PropertySpecificOption.ALLOWED);
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);</screen>
</para>
</formalpara>
<simpara>Alternatively, you can update the <literal>drools.propertySpecific</literal> system property in the <literal>standalone.xml</literal> file of your Red Hat Decision Manager distribution:</simpara>
<formalpara>
<title>Example property reactivity setting in system properties</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;system-properties&gt;
  ...
  &lt;property name="drools.propertySpecific" value="ALLOWED"/&gt;
  ...
&lt;/system-properties&gt;</programlisting>
</para>
</formalpara>
<simpara>The decision engine supports the following property-change settings and listeners for fact classes or declared DRL fact types:</simpara>
<variablelist>
<varlistentry>
<term>@classReactive</term>
<listitem>
<simpara>If property reactivity is set to <literal>ALWAYS</literal> in the decision engine (all types are property reactive), this tag disables the default property reactivity behavior for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to re-evaluate all fact patterns for the specified fact type each time the rule is triggered, instead of reacting only to modified properties that are constrained or bound inside a given pattern.</simpara>
<formalpara>
<title>Example: Disable default property reactivity in a DRL type declaration</title>
<para>
<screen>declare Person
  @classReactive
    firstName : String
    lastName : String
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example: Disable default property reactivity in a Java class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@classReactive
public static class Person {
    private String firstName;
    private String lastName;
}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@propertyReactive</term>
<listitem>
<simpara>If property reactivity is set to <literal>ALLOWED</literal> in the decision engine (no types are property reactive unless specified), this tag enables property reactivity for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to react only to modified properties that are constrained or bound inside a given pattern for the specified fact type, instead of re-evaluating all fact patterns for the fact each time the rule is triggered.</simpara>
<formalpara>
<title>Example: Enable property reactivity in a DRL type declaration (when reactivity is disabled globally)</title>
<para>
<screen>declare Person
  @propertyReactive
    firstName : String
    lastName : String
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example: Enable property reactivity in a Java class (when reactivity is disabled globally)</title>
<para>
<programlisting language="java" linenumbering="unnumbered">@propertyReactive
public static class Person {
    private String firstName;
    private String lastName;
}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@watch</term>
<listitem>
<simpara>This tag enables property reactivity for additional properties that you specify in-line in fact patterns in DRL rules. This tag is supported only if property reactivity is set to <literal>ALWAYS</literal> in the decision engine, or if property reactivity is set to <literal>ALLOWED</literal> and the relevant fact type uses the <literal>@propertyReactive</literal> tag. You can use this tag in DRL rules to add or exclude specific properties in fact property reactivity logic.</simpara>
<simpara>Default parameter: None</simpara>
<simpara>Supported parameters: Property name, <literal>*</literal> (all), <literal>!</literal> (not), <literal>!*</literal> (no properties)</simpara>
<screen>&lt;factPattern&gt; @watch ( &lt;property&gt; )</screen>
<formalpara>
<title>Example: Enable or disable property reactivity in fact patterns</title>
<para>
<screen>// Listens for changes in both `firstName` (inferred) and `lastName`:
Person(firstName == $expectedFirstName) @watch( lastName )

// Listens for changes in all properties of the `Person` fact:
Person(firstName == $expectedFirstName) @watch( * )

// Listens for changes in `lastName` and explicitly excludes changes in `firstName`:
Person(firstName == $expectedFirstName) @watch( lastName, !firstName )

// Listens for changes in all properties of the `Person` fact except `age`:
Person(firstName == $expectedFirstName) @watch( *, !age )

// Excludes changes in all properties of the `Person` fact (equivalent to using `@classReactivity` tag):
Person(firstName == $expectedFirstName) @watch( !* )</screen>
</para>
</formalpara>
<simpara>The decision engine generates a compilation error if you use the <literal>@watch</literal> tag for properties in a fact type that uses the <literal>@classReactive</literal> tag (disables property reactivity) or when property reactivity is set to <literal>ALLOWED</literal> in the decision engine and the relevant fact type does not use the <literal>@propertyReactive</literal> tag. Compilation errors also arise if you duplicate properties in listener annotations, such as <literal>@watch( firstName, ! firstName )</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>@propertyChangeSupport</term>
<listitem>
<simpara>For facts that implement support for property changes as defined in the <link xlink:href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/">JavaBeans Specification</link>, this tag enables the decision engine to monitor changes in the fact properties.</simpara>
<formalpara>
<title>Example: Declare property change support in JavaBeans object</title>
<para>
<screen>declare Person
    @propertyChangeSupport
end</screen>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="cep-temporal-operators_decision-engine">
<title>Temporal operators for events</title>
<simpara>In stream mode, the decision engine supports the following temporal operators for events that are inserted into the working memory of the decision engine. You can use these operators to define the temporal reasoning behavior of the events that you declare in your Java class or DRL rule file. Temporal operators are not supported when the decision engine is running in cloud mode.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>after</literal></simpara>
</listitem>
<listitem>
<simpara><literal>before</literal></simpara>
</listitem>
<listitem>
<simpara><literal>coincides</literal></simpara>
</listitem>
<listitem>
<simpara><literal>during</literal></simpara>
</listitem>
<listitem>
<simpara><literal>includes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>finishes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>finished by</literal></simpara>
</listitem>
<listitem>
<simpara><literal>meets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>met by</literal></simpara>
</listitem>
<listitem>
<simpara><literal>overlaps</literal></simpara>
</listitem>
<listitem>
<simpara><literal>overlapped by</literal></simpara>
</listitem>
<listitem>
<simpara><literal>starts</literal></simpara>
</listitem>
<listitem>
<simpara><literal>started by</literal></simpara>
<variablelist>
<varlistentry>
<term>after</term>
<listitem>
<simpara>This operator specifies if the current event occurs after the correlated event. This operator can also define an amount of time after which the current event can follow the correlated event, or a delimiting time range during which the current event can follow the correlated event.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> starts between 3 minutes and 30 seconds and 4 minutes after <literal>$eventB</literal> finishes. If <literal>$eventA</literal> starts earlier than 3 minutes and 30 seconds after <literal>$eventB</literal> finishes, or later than 4 minutes after <literal>$eventB</literal> finishes, then the pattern is not matched.</simpara>
<screen>$eventA : EventA(this after[3m30s, 4m] $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>3m30s &lt;= $eventA.startTimestamp - $eventB.endTimeStamp &lt;= 4m</screen>
<simpara>The <literal>after</literal> operator supports up to two parameter values:</simpara>
<itemizedlist>
<listitem>
<simpara>If two values are defined, the interval starts on the first value (3 minutes and 30 seconds in the example) and ends on the second value (4 minutes in the example).</simpara>
</listitem>
<listitem>
<simpara>If only one value is defined, the interval starts on the provided value and runs indefinitely with no end time.</simpara>
</listitem>
<listitem>
<simpara>If no value is defined, the interval starts at 1 millisecond and runs indefinitely with no end time.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>after</literal> operator also supports negative time ranges:</simpara>
<screen>$eventA : EventA(this after[-3m30s, -2m] $eventB)</screen>
<simpara>If the first value is greater than the second value, the decision engine automatically reverses them. For example, the following two patterns are interpreted by the decision engine in the same way:</simpara>
<screen>$eventA : EventA(this after[-3m30s, -2m] $eventB)
$eventA : EventA(this after[-2m, -3m30s] $eventB)</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>before</term>
<listitem>
<simpara>This operator specifies if the current event occurs before the correlated event. This operator can also define an amount of time before which the current event can precede the correlated event, or a delimiting time range during which the current event can precede the correlated event.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> finishes between 3 minutes and 30 seconds and 4 minutes before <literal>$eventB</literal> starts. If <literal>$eventA</literal> finishes earlier than 3 minutes and 30 seconds before <literal>$eventB</literal> starts, or later than 4 minutes before <literal>$eventB</literal> starts, then the pattern is not matched.</simpara>
<screen>$eventA : EventA(this before[3m30s, 4m] $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>3m30s &lt;= $eventB.startTimestamp - $eventA.endTimeStamp &lt;= 4m</screen>
<simpara>The <literal>before</literal> operator supports up to two parameter values:</simpara>
<itemizedlist>
<listitem>
<simpara>If two values are defined, the interval starts on the first value (3 minutes and 30 seconds in the example) and ends on the second value (4 minutes in the example).</simpara>
</listitem>
<listitem>
<simpara>If only one value is defined, the interval starts on the provided value and runs indefinitely with no end time.</simpara>
</listitem>
<listitem>
<simpara>If no value is defined, the interval starts at 1 millisecond and runs indefinitely with no end time.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>before</literal> operator also supports negative time ranges:</simpara>
<screen>$eventA : EventA(this before[-3m30s, -2m] $eventB)</screen>
<simpara>If the first value is greater than the second value, the decision engine automatically reverses them. For example, the following two patterns are interpreted by the decision engine in the same way:</simpara>
<screen>$eventA : EventA(this before[-3m30s, -2m] $eventB)
$eventA : EventA(this before[-2m, -3m30s] $eventB)</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>coincides</term>
<listitem>
<simpara>This operator specifies if the two events occur at the same time, with the same start and end times.</simpara>
<simpara>For example, the following pattern matches if both the start and end time stamps of <literal>$eventA</literal> and <literal>$eventB</literal> are identical:</simpara>
<screen>$eventA : EventA(this coincides $eventB)</screen>
<simpara>The <literal>coincides</literal> operator supports up to two parameter values for the distance between the event start and end times, if they are not identical:</simpara>
<itemizedlist>
<listitem>
<simpara>If only one parameter is given, the parameter is used to set the threshold for both the start and end times of both events.</simpara>
</listitem>
<listitem>
<simpara>If two parameters are given, the first is used as a threshold for the start time and the second is used as a threshold for the end time.</simpara>
</listitem>
</itemizedlist>
<simpara>The following pattern uses start and end time thresholds:</simpara>
<screen>$eventA : EventA(this coincides[15s, 10s] $eventB)</screen>
<simpara>The pattern matches if the following conditions are met:</simpara>
<screen>abs($eventA.startTimestamp - $eventB.startTimestamp) &lt;= 15s
&amp;&amp;
abs($eventA.endTimestamp - $eventB.endTimestamp) &lt;= 10s</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>coincides</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>during</term>
<listitem>
<simpara>This operator specifies if the current event occurs within the time frame of when the correlated event starts and ends. The current event must start after the correlated event starts and must end before the correlated event ends. (With the <literal>coincides</literal> operator, the start and end times are the same or nearly the same.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> starts after <literal>$eventB</literal> starts and ends before <literal>$eventB</literal> ends:</simpara>
<screen>$eventA : EventA(this during $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventB.startTimestamp &lt; $eventA.startTimestamp &lt;= $eventA.endTimestamp &lt; $eventB.endTimestamp</screen>
<simpara>The <literal>during</literal> operator supports one, two, or four optional parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>If one value is defined, this value is the maximum distance between the start times of the two events and the maximum distance between the end times of the two events.</simpara>
</listitem>
<listitem>
<simpara>If two values are defined, these values are a threshold between which the current event start time and end time must occur in relation to the correlated event start and end times.</simpara>
<simpara>For example, if the values are <literal>5s</literal> and <literal>10s</literal>, the current event must start between 5 and 10 seconds after the correlated event starts and must end between 5 and 10 seconds before the correlated event ends.</simpara>
</listitem>
<listitem>
<simpara>If four values are defined, the first and second values are the minimum and maximum distances between the start times of the events, and the third and fourth values are the minimum and maximum distances between the end times of the two events.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>includes</term>
<listitem>
<simpara>This operator specifies if the correlated event occurs within the time frame of when the current event occurs. The correlated event must start after the current event starts and must end before the current event ends. (The behavior of this operator is the reverse of the <literal>during</literal> operator behavior.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventB</literal> starts after <literal>$eventA</literal> starts and ends before <literal>$eventA</literal> ends:</simpara>
<screen>$eventA : EventA(this includes $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventA.startTimestamp &lt; $eventB.startTimestamp &lt;= $eventB.endTimestamp &lt; $eventA.endTimestamp</screen>
<simpara>The <literal>includes</literal> operator supports one, two, or four optional parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>If one value is defined, this value is the maximum distance between the start times of the two events and the maximum distance between the end times of the two events.</simpara>
</listitem>
<listitem>
<simpara>If two values are defined, these values are a threshold between which the correlated event start time and end time must occur in relation to the current event start and end times.</simpara>
<simpara>For example, if the values are <literal>5s</literal> and <literal>10s</literal>, the correlated event must start between 5 and 10 seconds after the current event starts and must end between 5 and 10 seconds before the current event ends.</simpara>
</listitem>
<listitem>
<simpara>If four values are defined, the first and second values are the minimum and maximum distances between the start times of the events, and the third and fourth values are the minimum and maximum distances between the end times of the two events.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>finishes</term>
<listitem>
<simpara>This operator specifies if the current event starts after the correlated event but both events end at the same time.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> starts after <literal>$eventB</literal> starts and ends at the same time when <literal>$eventB</literal> ends:</simpara>
<screen>$eventA : EventA(this finishes $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventB.startTimestamp &lt; $eventA.startTimestamp
&amp;&amp;
$eventA.endTimestamp == $eventB.endTimestamp</screen>
<simpara>The <literal>finishes</literal> operator supports one optional parameter that sets the maximum time allowed between the end times of the two events:</simpara>
<screen>$eventA : EventA(this finishes[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>$eventB.startTimestamp &lt; $eventA.startTimestamp
&amp;&amp;
abs($eventA.endTimestamp - $eventB.endTimestamp) &lt;= 5s</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>finishes</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>finished by</term>
<listitem>
<simpara>This operator specifies if the correlated event starts after the current event but both events end at the same time. (The behavior of this operator is the reverse of the <literal>finishes</literal> operator behavior.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventB</literal> starts after <literal>$eventA</literal> starts and ends at the same time when <literal>$eventA</literal> ends:</simpara>
<screen>$eventA : EventA(this finishedby $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventA.startTimestamp &lt; $eventB.startTimestamp
&amp;&amp;
$eventA.endTimestamp == $eventB.endTimestamp</screen>
<simpara>The <literal>finished by</literal> operator supports one optional parameter that sets the maximum time allowed between the end times of the two events:</simpara>
<screen>$eventA : EventA(this finishedby[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>$eventA.startTimestamp &lt; $eventB.startTimestamp
&amp;&amp;
abs($eventA.endTimestamp - $eventB.endTimestamp) &lt;= 5s</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>finished by</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>meets</term>
<listitem>
<simpara>This operator specifies if the current event ends at the same time when the correlated event starts.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> ends at the same time when <literal>$eventB</literal> starts:</simpara>
<screen>$eventA : EventA(this meets $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>abs($eventB.startTimestamp - $eventA.endTimestamp) == 0</screen>
<simpara>The <literal>meets</literal> operator supports one optional parameter that sets the maximum time allowed between the end time of the current event and the start time of the correlated event:</simpara>
<screen>$eventA : EventA(this meets[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>abs($eventB.startTimestamp - $eventA.endTimestamp) &lt;= 5s</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>meets</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>met by</term>
<listitem>
<simpara>This operator specifies if the correlated event ends at the same time when the current event starts. (The behavior of this operator is the reverse of the <literal>meets</literal> operator behavior.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventB</literal> ends at the same time when <literal>$eventA</literal> starts:</simpara>
<screen>$eventA : EventA(this metby $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>abs($eventA.startTimestamp - $eventB.endTimestamp) == 0</screen>
<simpara>The <literal>met by</literal> operator supports one optional parameter that sets the maximum distance between the end time of the correlated event and the start time of the current event:</simpara>
<screen>$eventA : EventA(this metby[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>abs($eventA.startTimestamp - $eventB.endTimestamp) &lt;= 5s</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>met by</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>overlaps</term>
<listitem>
<simpara>This operator specifies if the current event starts before the correlated event starts and it ends during the time frame that the correlated event occurs. The current event must end between the start and end times of the correlated event.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> starts before <literal>$eventB</literal> starts and then ends while <literal>$eventB</literal> occurs, before <literal>$eventB</literal> ends:</simpara>
<screen>$eventA : EventA(this overlaps $eventB)</screen>
<simpara>The <literal>overlaps</literal> operator supports up to two parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>If one parameter is defined, the value is the maximum distance between the start time of the correlated event and the end time of the current event.</simpara>
</listitem>
<listitem>
<simpara>If two parameters are defined, the values are the minimum distance (first value) and the maximum distance (second value) between the start time of the correlated event and the end time of the current event.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>overlapped by</term>
<listitem>
<simpara>This operator specifies if the correlated event starts before the current event starts and it ends during the time frame that the current event occurs. The correlated event must end between the start and end times of the current event. (The behavior of this operator is the reverse of the <literal>overlaps</literal> operator behavior.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventB</literal> starts before <literal>$eventA</literal> starts and then ends while <literal>$eventA</literal> occurs, before <literal>$eventA</literal> ends:</simpara>
<screen>$eventA : EventA(this overlappedby $eventB)</screen>
<simpara>The <literal>overlapped by</literal> operator supports up to two parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>If one parameter is defined, the value is the maximum distance between the start time of the current event and the end time of the correlated event.</simpara>
</listitem>
<listitem>
<simpara>If two parameters are defined, the values are the minimum distance (first value) and the maximum distance (second value) between the start time of the current event and the end time of the correlated event.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>starts</term>
<listitem>
<simpara>This operator specifies if the two events start at the same time but the current event ends before the correlated event ends.</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> and <literal>$eventB</literal> start at the same time, and <literal>$eventA</literal> ends before <literal>$eventB</literal> ends:</simpara>
<screen>$eventA : EventA(this starts $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventA.startTimestamp == $eventB.startTimestamp
&amp;&amp;
$eventA.endTimestamp &lt; $eventB.endTimestamp</screen>
<simpara>The <literal>starts</literal> operator supports one optional parameter that sets the maximum distance between the start times of the two events:</simpara>
<screen>$eventA : EventA(this starts[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>abs($eventA.startTimestamp - $eventB.startTimestamp) &lt;= 5s
&amp;&amp;
$eventA.endTimestamp &lt; $eventB.endTimestamp</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>starts</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
<varlistentry>
<term>started by</term>
<listitem>
<simpara>This operator specifies if the two events start at the same time but the correlated event ends before the current event ends. (The behavior of this operator is the reverse of the <literal>starts</literal> operator behavior.)</simpara>
<simpara>For example, the following pattern matches if <literal>$eventA</literal> and <literal>$eventB</literal> start at the same time, and <literal>$eventB</literal> ends before <literal>$eventA</literal> ends:</simpara>
<screen>$eventA : EventA(this startedby $eventB)</screen>
<simpara>You can also express this operator in the following way:</simpara>
<screen>$eventA.startTimestamp == $eventB.startTimestamp
&amp;&amp;
$eventA.endTimestamp &gt; $eventB.endTimestamp</screen>
<simpara>The <literal>started by</literal> operator supports one optional parameter that sets the maximum distance between the start times of the two events:</simpara>
<screen>$eventA : EventA( this starts[5s] $eventB)</screen>
<simpara>This pattern matches if these conditions are met:</simpara>
<screen>abs( $eventA.startTimestamp - $eventB.startTimestamp ) &lt;= 5s
&amp;&amp;
$eventA.endTimestamp &gt; $eventB.endTimestamp</screen>
<warning>
<simpara>The decision engine does not support negative intervals for the <literal>started by</literal> operator. If you use negative intervals, the decision engine generates an error.</simpara>
</warning>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cep-clock-ref_decision-engine">
<title>Session clock implementations in the decision engine</title>
<simpara>During complex event processing, events in the decision engine may have temporal constraints and therefore require a session clock that provides the current time. For example, if a rule needs to determine the average price of a given stock over the last 60 minutes, the decision engine must be able to compare the stock price event time stamp with the current time in the session clock.</simpara>
<simpara>The decision engine supports a real-time clock and a pseudo clock. You can use one or both clock types depending on the scenario:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Rules testing:</emphasis> Testing requires a controlled environment, and when the tests include rules with temporal constraints, you must be able to control the input rules and facts and the flow of time.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Regular execution:</emphasis> The decision engine reacts to events in real time and therefore requires a real-time clock.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Special environments:</emphasis> Specific environments may have specific time control requirements. For example, clustered environments may require clock synchronization or Java Enterprise Edition (JEE) environments may require a clock provided by the application server.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rules replay or simulation:</emphasis> In order to replay or simulate scenarios, the application must be able to control the flow of time.</simpara>
</listitem>
</itemizedlist>
<simpara>Consider your environment requirements as you decide whether to use a real-time clock or pseudo clock in the decision engine.</simpara>
<variablelist>
<varlistentry>
<term>Real-time clock</term>
<listitem>
<simpara>The real-time clock is the default clock implementation in the decision engine and uses the system clock to determine the current time for time stamps. To configure the decision engine to use the real-time clock, set the KIE session configuration parameter to <literal>realtime</literal>:</simpara>
<formalpara>
<title>Configure real-time clock in KIE session</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.KieServices.Factory;
import org.kie.api.runtime.conf.ClockTypeOption;
import org.kie.api.runtime.KieSessionConfiguration;

KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();

config.setOption(ClockTypeOption.get("realtime"));</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Pseudo clock</term>
<listitem>
<simpara>The pseudo clock implementation in the decision engine is helpful for testing temporal rules and it can be controlled by the application. To configure the decision engine to use the pseudo clock, set the KIE session configuration parameter to <literal>pseudo</literal>:</simpara>
<formalpara>
<title>Configure pseudo clock in KIE session</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.runtime.conf.ClockTypeOption;
import org.kie.api.runtime.KieSessionConfiguration;
import org.kie.api.KieServices.Factory;

KieSessionConfiguration config = KieServices.Factory.get().newKieSessionConfiguration();

config.setOption(ClockTypeOption.get("pseudo"));</programlisting>
</para>
</formalpara>
<simpara>You can also use additional configurations and fact handlers to control the pseudo clock:</simpara>
<formalpara>
<title>Control pseudo clock behavior in KIE session</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import java.util.concurrent.TimeUnit;

import org.kie.api.runtime.KieSessionConfiguration;
import org.kie.api.KieServices.Factory;
import org.kie.api.runtime.KieSession;
import org.drools.core.time.SessionPseudoClock;
import org.kie.api.runtime.rule.FactHandle;
import org.kie.api.runtime.conf.ClockTypeOption;

KieSessionConfiguration conf = KieServices.Factory.get().newKieSessionConfiguration();

conf.setOption( ClockTypeOption.get("pseudo"));
KieSession session = kbase.newKieSession(conf, null);

SessionPseudoClock clock = session.getSessionClock();

// While inserting facts, advance the clock as necessary.
FactHandle handle1 = session.insert(tick1);
clock.advanceTime(10, TimeUnit.SECONDS);

FactHandle handle2 = session.insert(tick2);
clock.advanceTime(30, TimeUnit.SECONDS);

FactHandle handle3 = session.insert(tick3);</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="cep-event-streams-con_decision-engine">
<title>Event streams and entry points</title>
<simpara>The decision engine can process high volumes of events in the form of event streams. In DRL rule declarations, a stream is also known as an <emphasis>entry point</emphasis>. When you declare an entry point in a DRL rule or Java application, the decision engine, at compile time, identifies and creates the proper internal structures to use data from only that entry point to evaluate that rule.</simpara>
<simpara>Facts from one entry point, or stream, can join facts from any other entry point in addition to facts already in the working memory of the decision engine. Facts always remain associated with the entry point through which they entered the decision engine. Facts of the same type can enter the decision engine through several entry points, but facts that enter the decision engine through entry point A can never match a pattern from entry point B.</simpara>
<simpara>Event streams have the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>Events in the stream are ordered by time stamp. The time stamps may have different semantics for different streams, but they are always ordered internally.</simpara>
</listitem>
<listitem>
<simpara>Event streams usually have a high volume of events.</simpara>
</listitem>
<listitem>
<simpara>Atomic events in streams are usually not useful individually, only collectively in a stream.</simpara>
</listitem>
<listitem>
<simpara>Event streams can be homogeneous and contain a single type of event, or heterogeneous and contain events of different types.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cep-event-streams-proc_decision-engine">
<title>Declaring entry points for rule data</title>
<simpara>You can declare an entry point (event stream) for events so that the decision engine uses data from only that entry point to evaluate the rules. You can declare an entry point either implicitly by referencing it in DRL rules or explicitly in your Java application.</simpara>
<formalpara>
<title>Procedure</title>
<para>Use one of the following methods to declare the entry point:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>In the DRL rule file, specify <literal>from entry-point "&lt;name&gt;"</literal> for the inserted fact:</simpara>
<formalpara>
<title>Authorize withdrawal rule with "ATM Stream" entry point</title>
<para>
<screen>rule "Authorize withdrawal"
when
  WithdrawRequest($ai : accountId, $am : amount) from entry-point "ATM Stream"
  CheckingAccount(accountId == $ai, balance &gt; $am)
then
  // Authorize withdrawal.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Apply fee rule with "Branch Stream" entry point</title>
<para>
<screen>rule "Apply fee on withdraws on branches"
when
  WithdrawRequest($ai : accountId, processed == true) from entry-point "Branch Stream"
  CheckingAccount(accountId == $ai)
then
  // Apply a $2 fee on the account.
end</screen>
</para>
</formalpara>
<simpara>Both example DRL rules from a banking application insert the event <literal>WithdrawalRequest</literal> with the fact <literal>CheckingAccount</literal>, but from different entry points. At run time, the decision engine evaluates the <literal>Authorize withdrawal</literal> rule using data from only the <literal>"ATM Stream"</literal> entry point, and evaluates the <literal>Apply fee</literal> rule using data from only the <literal>"Branch Stream"</literal> entry point. Any events inserted into the <literal>"ATM Stream"</literal> can never match patterns for the <literal>"Apply fee"</literal> rule, and any events inserted into the <literal>"Branch Stream"</literal> can never match patterns for the <literal>"Authorize withdrawal rule"</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the Java application code, use the <literal>getEntryPoint()</literal> method to specify and obtain an <literal>EntryPoint</literal> object and insert facts into that entry point accordingly:</simpara>
<formalpara>
<title>Java application code with EntryPoint object and inserted facts</title>
<para>
<programlisting language="java" linenumbering="unnumbered">import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.rule.EntryPoint;

// Create your KIE base and KIE session as usual.
KieSession session = ...

// Create a reference to the entry point.
EntryPoint atmStream = session.getEntryPoint("ATM Stream");

// Start inserting your facts into the entry point.
atmStream.insert(aWithdrawRequest);</programlisting>
</para>
</formalpara>
<simpara>Any DRL rules that specify <literal>from entry-point "ATM Stream"</literal> are then evaluated based on the data in this entry point only.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cep-sliding-windows-con_decision-engine">
<title>Sliding windows of time or length</title>
<simpara>In stream mode, the decision engine can process events from a specified sliding window of time or length. A sliding time window is a specified period of time during which events can be processed. A sliding length window is a specified number of events that can be processed. When you declare a sliding window in a DRL rule or Java application, the decision engine, at compile time, identifies and creates the proper internal structures to use data from only that sliding window to evaluate that rule.</simpara>
<simpara>For example, the following DRL rule snippets instruct the decision engine to process only the stock points from the last 2 minutes (sliding time window) or to process only the last 10 stock points (sliding length window):</simpara>
<formalpara>
<title>Process stock points from the last 2 minutes (sliding time window)</title>
<para>
<screen>StockPoint() over window:time(2m)</screen>
</para>
</formalpara>
<formalpara>
<title>Process the last 10 stock points (sliding length window)</title>
<para>
<screen>StockPoint() over window:length(10)</screen>
</para>
</formalpara>
<section xml:id="cep-sliding-windows-proc_decision-engine">
<title>Declaring sliding windows for rule data</title>
<simpara>You can declare a sliding window of time (flow of time) or length (number of occurrences) for events so that the decision engine uses data from only that window to evaluate the rules.</simpara>
<formalpara>
<title>Procedure</title>
<para>In the DRL rule file, specify <literal>over window:&lt;time_or_length&gt;(&lt;value&gt;)</literal> for the inserted fact.</para>
</formalpara>
<simpara>For example, the following two DRL rules activate a fire alarm based on an average temperature. However, the first rule uses a sliding time window to calculate the average over the last 10 minutes while the second rule uses a sliding length window to calculate the average over the last one hundred temperature readings.</simpara>
<formalpara>
<title>Average temperature over sliding time window</title>
<para>
<screen>rule "Sound the alarm if temperature rises above threshold"
when
  TemperatureThreshold($max : max)
  Number(doubleValue &gt; $max) from accumulate(
    SensorReading($temp : temperature) over window:time(10m),
    average($temp))
then
  // Sound the alarm.
end</screen>
</para>
</formalpara>
<formalpara>
<title>Average temperature over sliding length window</title>
<para>
<screen>rule "Sound the alarm if temperature rises above threshold"
when
  TemperatureThreshold($max : max)
  Number(doubleValue &gt; $max) from accumulate(
    SensorReading($temp : temperature) over window:length(100),
    average($temp))
then
  // Sound the alarm.
end</screen>
</para>
</formalpara>
<simpara>The decision engine discards any <literal>SensorReading</literal> events that are more than 10 minutes old or that are not part of the last one hundred readings, and continues recalculating the average as the minutes or readings "slide" forward in real time.</simpara>
<simpara>The decision engine does not automatically remove outdated events from the KIE session because other rules without sliding window declarations might depend on those events. The decision engine stores events in the KIE session until the events expire either by explicit rule declarations or by implicit reasoning within the decision engine based on inferred data in the KIE base.</simpara>
</section>
</section>
<section xml:id="cep-memory-management-con_decision-engine">
<title>Memory management for events</title>
<simpara>In stream mode, the decision engine uses automatic memory management to maintain events that are stored in KIE sessions. The decision engine can retract from a KIE session any events that no longer match any rule due to their temporal constraints and release any resources held by the retracted events.</simpara>
<simpara>The decision engine uses either explicit or inferred expiration to retract outdated events:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Explicit expiration:</emphasis> The decision engine removes events that are explicitly set to expire in rules that declare the <literal>@expires</literal> tag:</simpara>
<formalpara>
<title>DRL rule snippet with explicit expiration</title>
<para>
<screen>declare StockPoint
  @expires( 30m )
end</screen>
</para>
</formalpara>
<simpara>This example rule sets any <literal>StockPoint</literal> events to expire after 30 minutes and to be removed from the KIE session if no other rules use the events.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Inferred expiration:</emphasis> The decision engine can calculate the expiration offset for a given event implicitly by analyzing the temporal constraints in the rules:</simpara>
<formalpara>
<title>DRL rule with temporal constraints</title>
<para>
<screen>rule "Correlate orders"
when
  $bo : BuyOrder($id : id)
  $ae : AckOrder(id == $id, this after[0,10s] $bo)
then
  // Perform an action.
end</screen>
</para>
</formalpara>
<simpara>For this example rule, the decision engine automatically calculates that whenever a <literal>BuyOrder</literal> event occurs, the decision engine needs to store the event for up to 10 seconds and wait for the matching <literal>AckOrder</literal> event. After 10 seconds, the decision engine infers the expiration and removes the event from the KIE session. An <literal>AckOrder</literal> event can only match an existing <literal>BuyOrder</literal> event, so the decision engine infers the expiration if no match occurs and removes the event immediately.</simpara>
<simpara>The decision engine analyzes the entire KIE base to find the offset for every event type and to ensure that no other rules use the events that are pending removal. Whenever an implicit expiration clashes with an explicit expiration value, the decision engine uses the greater time frame of the two to store the event longer.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="engine-queries-con_decision-engine">
<title>Decision engine queries and live queries</title>
<simpara>You can use queries with the decision engine to retrieve fact sets based on fact patterns as they are used in rules. The patterns might also use optional parameters.</simpara>
<simpara>To use queries with the decision engine, you add the query definitions in DRL files and then obtain the matching results in your application code. While a query iterates over a result collection, you can use any identifier that is bound to the query to access the corresponding fact or fact field by calling the <literal>get()</literal> method with the binding variable name as the argument. If the binding refers to a fact object, you can retrieve the fact handle by calling <literal>getFactHandle()</literal> with the variable name as the parameter.</simpara>
<formalpara>
<title>Example query definition in a DRL file</title>
<para>
<screen>query "people under the age of 21"
    $person : Person( age &lt; 21 )
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example application code to obtain and iterate over query results</title>
<para>
<programlisting language="java" linenumbering="unnumbered">QueryResults results = ksession.getQueryResults( "people under the age of 21" );
System.out.println( "we have " + results.size() + " people under the age of 21" );

System.out.println( "These people are under the age of 21:" );

for ( QueryResultsRow row : results ) {
    Person person = ( Person ) row.get( "person" );
    System.out.println( person.getName() + "\n" );
}</programlisting>
</para>
</formalpara>
<simpara>Invoking queries and processing the results by iterating over the returned set can be difficult when you are monitoring changes over time. To alleviate this difficulty with ongoing queries, Red Hat Decision Manager provides <emphasis>live queries</emphasis>, which use an attached listener for change events instead of returning an iterable result set. Live queries remain open by creating a view and publishing change events for the contents of this view.</simpara>
<simpara>To activate a live query, start your query with parameters and monitor changes in the resulting view. You can use the <literal>dispose()</literal> method to terminate the query and discontinue this reactive scenario.</simpara>
<formalpara>
<title>Example query definition in a DRL file</title>
<para>
<screen>query colors(String $color1, String $color2)
    TShirt(mainColor = $color1, secondColor = $color2, $price: manufactureCost)
end</screen>
</para>
</formalpara>
<formalpara>
<title>Example application code with an event listener and a live query</title>
<para>
<programlisting language="java" linenumbering="unnumbered">final List updated = new ArrayList();
final List removed = new ArrayList();
final List added = new ArrayList();

ViewChangedEventListener listener = new ViewChangedEventListener() {
 public void rowUpdated(Row row) {
  updated.add( row.get( "$price" ) );
 }

 public void rowRemoved(Row row) {
  removed.add( row.get( "$price" ) );
 }

 public void rowAdded(Row row) {
  added.add( row.get( "$price" ) );
 }
};

// Open the live query:
LiveQuery query = ksession.openLiveQuery( "colors",
                                          new Object[] { "red", "blue" },
                                          listener );
...
...

// Terminate the live query:
query.dispose()</programlisting>
</para>
</formalpara>
</chapter>
<chapter xml:id="engine-event-listeners-con_decision-engine">
<title>Decision engine event listeners and debug logging</title>
<simpara>In Red Hat Decision Manager, you can add or remove listeners for decision engine events, such as fact insertions and rule executions. With decision engine event listeners, you can be notified of decision engine activity and separate your logging and auditing work from the core of your application.</simpara>
<simpara>The decision engine supports the following default event listeners for the agenda and working memory:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>AgendaEventListener</literal></simpara>
</listitem>
<listitem>
<simpara><literal>WorkingMemoryEventListener</literal></simpara>
</listitem>
</itemizedlist>
<simpara>For each event listener, the decision engine also supports the following specific events that you can specify to be monitored:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>MatchCreatedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MatchCancelledEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>BeforeMatchFiredEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>AfterMatchFiredEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>AgendaGroupPushedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>AgendaGroupPoppedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ObjectInsertEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ObjectDeletedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ObjectUpdatedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ProcessCompletedEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ProcessNodeLeftEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ProcessNodeTriggeredEvent</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ProcessStartEvent</literal></simpara>
</listitem>
</itemizedlist>
<simpara>For example, the following code uses a <literal>DefaultAgendaEventListener</literal> listener attached to a KIE session and specifies the <literal>AfterMatchFiredEvent</literal> event to be monitored. The code prints pattern matches after the rules are executed (fired):</simpara>
<formalpara>
<title>Example code to monitor and print <literal>AfterMatchFiredEvent</literal> events in the agenda</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.addEventListener( new DefaultAgendaEventListener() {
   public void afterMatchFired(AfterMatchFiredEvent event) {
       super.afterMatchFired( event );
       System.out.println( event );
   }
});</programlisting>
</para>
</formalpara>
<simpara>The decision engine also supports the following agenda and working memory event listeners for debug logging:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DebugAgendaEventListener</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DebugRuleRuntimeEventListener</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These event listeners implement the same supported event-listener methods and include a debug print statement by default. You can add a specific supported event to be monitored and documented, or monitor all agenda or working memory activity.</simpara>
<simpara>For example, the following code uses the <literal>DebugRuleRuntimeEventListener</literal> event listener to monitor and print all working memory events:</simpara>
<formalpara>
<title>Example code to monitor and print all working memory events</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.addEventListener( new DebugRuleRuntimeEventListener() );</programlisting>
</para>
</formalpara>
<section xml:id="logging-proc_decision-engine">
<title>Configuring a logging utility in the decision engine</title>
<simpara>The decision engine uses the Java logging API SLF4J for system logging. You can use one of the following logging utilities with the decision engine to investigate decision engine activity, such as for troubleshooting or data gathering:</simpara>
<itemizedlist>
<listitem>
<simpara>Logback</simpara>
</listitem>
<listitem>
<simpara>Apache Commons Logging</simpara>
</listitem>
<listitem>
<simpara>Apache Log4j</simpara>
</listitem>
<listitem>
<simpara><literal>java.util.logging</literal> package</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>For the logging utility that you want to use, add the relevant dependency to your Maven project or save the relevant XML configuration file in the <literal>org.drools</literal> package of your Red Hat Decision Manager distribution:</para>
</formalpara>
<formalpara>
<title>Example Maven dependency for Logback</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;dependency&gt;
  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
  &lt;version&gt;${logback.version}&lt;/version&gt;
&lt;/dependency&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example logback.xml configuration file in org.drools package</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;configuration&gt;
  &lt;logger name="org.drools" level="debug"/&gt;
  ...
&lt;configuration&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example log4j.xml configuration file in org.drools package</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;
  &lt;category name="org.drools"&gt;
    &lt;priority value="debug" /&gt;
  &lt;/category&gt;
  ...
&lt;/log4j:configuration&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>If you are developing for an ultra light environment, use the <literal>slf4j-nop</literal> or <literal>slf4j-simple</literal> logger.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="decision-examples-IDE-con_decision-engine">
<title>Example decisions in Red Hat Decision Manager for an IDE</title>
<simpara>Red Hat Decision Manager provides example decisions distributed as Java classes that you can import into your integrated development environment (IDE). You can use these examples to better understand decision engine capabilities or use them as a reference for the decisions that you define in your own Red Hat Decision Manager projects.</simpara>
<simpara>The following example decision sets are some of the examples available in Red Hat Decision Manager:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Hello World example</emphasis>: Demonstrates basic rule execution and use of debug output</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">State example</emphasis>: Demonstrates forward chaining and conflict resolution through rule salience and agenda groups</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fibonacci example</emphasis>: Demonstrates recursion and conflict resolution through rule salience</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Banking example</emphasis>: Demonstrates pattern matching, basic sorting, and calculation</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pet Store example</emphasis>: Demonstrates rule agenda groups, global variables, callbacks, and GUI integration</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Sudoku example</emphasis>: Demonstrates complex pattern matching, problem solving, callbacks, and GUI integration</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">House of Doom example</emphasis>: Demonstrates backward chaining and recursion</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For optimization examples provided with Red Hat Business Optimizer, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#examples-con"><emphasis>Getting started with Red Hat Business Optimizer</emphasis></link>.</simpara>
</note>
<section xml:id="decision-examples-IDE-proc_decision-engine">
<title>Importing and executing Red Hat Decision Manager example decisions in an IDE</title>
<simpara>You can import Red Hat Decision Manager example decisions into your integrated development environment (IDE) and execute them to explore how the rules and code function. You can use these examples to better understand decision engine capabilities or use them as a reference for the decisions that you define in your own Red Hat Decision Manager projects.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Java 8 or later is installed.</simpara>
</listitem>
<listitem>
<simpara>Maven 3.5.x or later is installed.</simpara>
</listitem>
<listitem>
<simpara>An IDE is installed, such as
Red Hat CodeReady Studio.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Download and unzip the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link> to a temporary directory, such as <literal>/rhdm-7.10.0-sources</literal>.</simpara>
</listitem>
<listitem>
<simpara>Open your IDE and select <emphasis role="strong">File</emphasis> → <emphasis role="strong">Import</emphasis> → <emphasis role="strong">Maven</emphasis> → <emphasis role="strong">Existing Maven Projects</emphasis>, or the equivalent option for importing a Maven project.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Browse</emphasis>, navigate to
<literal>~/rhdm-7.10.0-sources/src/drools-$VERSION/drools-examples</literal> (or, for the Conway’s Game of Life example, <literal>~/rhdm-7.10.0-sources/src/droolsjbpm-integration-$VERSION/droolsjbpm-integration-examples</literal>),
and import the project.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the example package that you want to run and find the Java class with the <literal>main</literal> method.</simpara>
</listitem>
<listitem>
<simpara>Right-click the Java class and select <emphasis role="strong">Run As</emphasis> → <emphasis role="strong">Java Application</emphasis> to run the example.</simpara>
<simpara>To run all examples through a basic user interface, run the <literal>DroolsExamplesApp.java</literal> class (or, for Conway’s Game of Life, the <literal>DroolsJbpmIntegrationExamplesApp.java</literal> class) in the <literal>org.drools.examples</literal> main class.</simpara>
<figure>
<title>Interface for all examples in drools-examples (DroolsExamplesApp.java)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/All/drools-examples-run-all.png" align="center"/>
</imageobject>
<textobject><phrase>drools examples run all</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Interface for all examples in droolsjbpm-integration-examples (DroolsJbpmIntegrationExamplesApp.java)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/All/droolsjbpm-examples-run-all.png" align="center"/>
</imageobject>
<textobject><phrase>droolsjbpm examples run all</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
</section>
<section xml:id="decision-examples-helloworld-ref_decision-engine">
<title>Hello World example decisions (basic rules and debugging)</title>
<simpara>The Hello World example decision set demonstrates how to insert objects into the decision engine working memory, how to match the objects using rules, and how to configure logging to trace the internal activity of the decision engine.</simpara>
<simpara>The following is an overview of the Hello World example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>helloworld</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.helloworld.HelloWorldExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.helloworld.HelloWorld.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates basic rule execution and use of debug output</simpara>
</listitem>
</itemizedlist>
<simpara>In the Hello World example, a KIE session is generated to enable rule execution. All rules require a KIE session for execution.</simpara>
<formalpara>
<title>KIE session for rule execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">KieServices ks = KieServices.Factory.get(); <co xml:id="CO14-1"/>
KieContainer kc = ks.getKieClasspathContainer(); <co xml:id="CO14-2"/>
KieSession ksession = kc.newKieSession("HelloWorldKS"); <co xml:id="CO14-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO14-1">
<para>Obtains the <literal>KieServices</literal> factory. This is the main interface that applications use to interact with the decision engine.</para>
</callout>
<callout arearefs="CO14-2">
<para>Creates a <literal>KieContainer</literal> from the project class path. This detects a <emphasis role="strong">/META-INF/kmodule.xml</emphasis> file from which it configures and instantiates a <literal>KieContainer</literal> with a <literal>KieModule</literal>.</para>
</callout>
<callout arearefs="CO14-3">
<para>Creates a <literal>KieSession</literal> based on the <literal>"HelloWorldKS"</literal> KIE session configuration defined in the <emphasis role="strong">/META-INF/kmodule.xml</emphasis> file.</para>
</callout>
</calloutlist>
<note>
<simpara>For more information about Red Hat Decision Manager project packaging, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link>.</simpara>
</note>
<simpara>Red Hat Decision Manager has an event model that exposes internal engine activity. Two default debug listeners, <literal>DebugAgendaEventListener</literal> and <literal>DebugRuleRuntimeEventListener</literal>, print debug event information to the <literal>System.err</literal> output. The <literal>KieRuntimeLogger</literal> provides execution auditing, the result of which you can view in a graphical viewer.</simpara>
<formalpara>
<title>Debug listeners and audit loggers</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Set up listeners.
ksession.addEventListener( new DebugAgendaEventListener() );
ksession.addEventListener( new DebugRuleRuntimeEventListener() );

// Set up a file-based audit logger.
KieRuntimeLogger logger = KieServices.get().getLoggers().newFileLogger( ksession, "./target/helloworld" );

// Set up a ThreadedFileLogger so that the audit view reflects events while debugging.
KieRuntimeLogger logger = ks.getLoggers().newThreadedFileLogger( ksession, "./target/helloworld", 1000 );</programlisting>
</para>
</formalpara>
<simpara>The logger is a specialized implementation built on the <literal>Agenda</literal> and <literal>RuleRuntime</literal> listeners. When the decision engine has finished executing, <literal>logger.close()</literal> is called.</simpara>
<simpara>The example creates a single <literal>Message</literal> object with the message <literal>"Hello World"</literal>, inserts the status <literal>HELLO</literal> into the <literal>KieSession</literal>, executes rules with <literal>fireAllRules()</literal>.</simpara>
<formalpara>
<title>Data insertion and execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// Insert facts into the KIE session.
final Message message = new Message();
message.setMessage( "Hello World" );
message.setStatus( Message.HELLO );
ksession.insert( message );

// Fire the rules.
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>Rule execution uses a data model to pass data as inputs and outputs to the <literal>KieSession</literal>. The data model in this example has two fields: the <literal>message</literal>, which is a <literal>String</literal>, and the <literal>status</literal>, which can be <literal>HELLO</literal> or <literal>GOODBYE</literal>.</simpara>
<formalpara>
<title>Data model class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static class Message {
    public static final int HELLO   = 0;
    public static final int GOODBYE = 1;

    private String          message;
    private int             status;
    ...
}</programlisting>
</para>
</formalpara>
<simpara>The two rules are located in the file <literal>src/main/resources/org/drools/examples/helloworld/HelloWorld.drl</literal>.</simpara>
<simpara>The <literal>when</literal> condition of the <literal>"Hello World"</literal> rule states that the rule is activated for each <literal>Message</literal> object inserted into the KIE session that has the status <literal>Message.HELLO</literal>. Additionally, two variable bindings are created: the variable <literal>message</literal> is bound to the <literal>message</literal> attribute and the variable <literal>m</literal> is bound to the matched <literal>Message</literal> object itself.</simpara>
<simpara>The <literal>then</literal> action of the rule specifies to print the content of the bound variable <literal>message</literal> to <literal>System.out</literal>, and then changes the values of the <literal>message</literal> and <literal>status</literal> attributes of the <literal>Message</literal> object bound to <literal>m</literal>. The rule uses the <literal>modify</literal> statement to apply a block of assignments in one statement and to notify the decision engine of the changes at the end of the block.</simpara>
<formalpara>
<title>"Hello World" rule</title>
<para>
<screen>rule "Hello World"
  when
    m : Message( status == Message.HELLO, message : message )
  then
    System.out.println( message );
    modify ( m ) { message = "Goodbye cruel world",
                   status = Message.GOODBYE };
end</screen>
</para>
</formalpara>
<simpara>The <literal>"Good Bye"</literal> rule is similar to the <literal>"Hello World"</literal> rule except that it matches <literal>Message</literal> objects that have the status <literal>Message.GOODBYE</literal>.</simpara>
<formalpara>
<title>"Good Bye" rule</title>
<para>
<screen>rule "Good Bye"
  when
    Message( status == Message.GOODBYE, message : message )
  then
    System.out.println( message );
end</screen>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.helloworld.HelloWorldExample</literal> class as a Java application in your IDE. The rule writes to <literal>System.out</literal>, the debug listener writes to <literal>System.err</literal>, and the audit logger creates a log file in <literal>target/helloworld.log</literal>.</simpara>
<formalpara>
<title>System.out output in the IDE console</title>
<para>
<screen>Hello World
Goodbye cruel world</screen>
</para>
</formalpara>
<formalpara>
<title>System.err output in the IDE console</title>
<para>
<screen>==&gt;[ActivationCreated(0): rule=Hello World;
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectInserted: handle=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                 object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[BeforeActivationFired: rule=Hello World;
                   tuple=[fid:1:1:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
==&gt;[ActivationCreated(4): rule=Good Bye;
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[ObjectUpdated: handle=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96];
                old_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96;
                new_object=org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]
[AfterActivationFired(0): rule=Hello World]
[BeforeActivationFired: rule=Good Bye;
                   tuple=[fid:1:2:org.drools.examples.helloworld.HelloWorldExample$Message@17cec96]]
[AfterActivationFired(4): rule=Good Bye]</screen>
</para>
</formalpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/helloworld.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit view</emphasis> shows that the object is inserted, which creates an activation for the <literal>"Hello World"</literal> rule. The activation is then executed, which updates the <literal>Message</literal> object and causes the <literal>"Good Bye"</literal> rule to activate. Finally, the <literal>"Good Bye"</literal> rule is executed. When you select an event in the <emphasis role="strong">Audit View</emphasis>, the origin event, which is the <literal>"Activation created"</literal> event in this example, is highlighted in green.</simpara>
<figure>
<title>Hello World example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/HelloWorldExample/helloworld_auditview1.png" align="center"/>
</imageobject>
<textobject><phrase>helloworld auditview1</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="decision-examples-state-ref_decision-engine">
<title>State example decisions (forward chaining and conflict resolution)</title>
<simpara>The State example decision set demonstrates how the decision engine uses forward chaining and any changes to facts in the working memory to resolve execution conflicts for rules in a sequence. The example focuses on resolving conflicts through salience values or through agenda groups that you can define in rules.</simpara>
<simpara>The following is an overview of the State example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>state</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main classes</emphasis>: <literal>org.drools.examples.state.StateExampleUsingSalience</literal>, <literal>org.drools.examples.state.StateExampleUsingAgendaGroup</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.state.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates forward chaining and conflict resolution through rule salience and agenda groups</simpara>
</listitem>
</itemizedlist>
<simpara>A forward-chaining rule system is a data-driven system that starts with a fact in the working memory of the decision engine and reacts to changes to that fact. When objects are inserted into working memory, any rule conditions that become true as a result of the change are scheduled for execution by the agenda.</simpara>
<simpara>In contrast, a backward-chaining rule system is a goal-driven system that starts with a conclusion that the decision engine attempts to satisfy, often using recursion. If the system cannot reach the conclusion or goal, it searches for subgoals, which are conclusions that complete part of the current goal. The system continues this process until either the initial conclusion is satisfied or all subgoals are satisfied.</simpara>
<simpara>The decision engine in Red Hat Decision Manager uses both forward and backward chaining to evaluate rules.</simpara>
<simpara>The following diagram illustrates how the decision engine evaluates rules using forward chaining overall with a backward-chaining segment in the logic flow:</simpara>
<figure>
<title>Rule evaluation logic using forward and backward chaining</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/RuleEvaluation_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>RuleEvaluation Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>In the State example, each <literal>State</literal> class has fields for its name and its current state (see the class <literal>org.drools.examples.state.State</literal>). The following states are the two possible states for each object:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NOTRUN</literal></simpara>
</listitem>
<listitem>
<simpara><literal>FINISHED</literal></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>State class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class State {
    public static final int NOTRUN   = 0;
    public static final int FINISHED = 1;

    private final PropertyChangeSupport changes =
        new PropertyChangeSupport( this );

    private String name;
    private int    state;

    ... setters and getters go here...
}</programlisting>
</para>
</formalpara>
<simpara>The State example contains two versions of the same example to resolve rule execution conflicts:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>StateExampleUsingSalience</literal> version that resolves conflicts by using rule salience</simpara>
</listitem>
<listitem>
<simpara>A <literal>StateExampleUsingAgendaGroups</literal> version that resolves conflicts by using rule agenda groups</simpara>
</listitem>
</itemizedlist>
<simpara>Both versions of the state example involve four <literal>State</literal> objects: <literal>A</literal>, <literal>B</literal>, <literal>C</literal>, and <literal>D</literal>. Initially, their states are set to <literal>NOTRUN</literal>, which is the default value for the constructor that the example uses.</simpara>
<bridgehead xml:id="state_example_using_salience_2" renderas="sect3" remap="_state_example_using_salience_2">State example using salience</bridgehead>
<simpara>The <literal>StateExampleUsingSalience</literal> version of the State example uses salience values in rules to resolve rule execution conflicts. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara>
<simpara>The example inserts each <literal>State</literal> instance into the KIE session and then calls <literal>fireAllRules()</literal>.</simpara>
<formalpara>
<title>Salience State example execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">final State a = new State( "A" );
final State b = new State( "B" );
final State c = new State( "C" );
final State d = new State( "D" );

ksession.insert( a );
ksession.insert( b );
ksession.insert( c );
ksession.insert( d );

ksession.fireAllRules();

// Dispose KIE session if stateful (not required if stateless).
ksession.dispose();</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.state.StateExampleUsingSalience</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Salience State example output in the IDE console</title>
<para>
<screen>A finished
B finished
C finished
D finished</screen>
</para>
</formalpara>
<simpara>Four rules are present.</simpara>
<simpara>First, the <literal>"Bootstrap"</literal> rule fires, setting <literal>A</literal> to state <literal>FINISHED</literal>, which then causes <literal>B</literal> to change its state to <literal>FINISHED</literal>. Objects <literal>C</literal> and <literal>D</literal> are both dependent on <literal>B</literal>, causing a conflict that is resolved by the salience values.</simpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/state.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows that the assertion of the object <literal>A</literal> in the state <literal>NOTRUN</literal> activates the <literal>"Bootstrap"</literal> rule, while the assertions of the other objects have no immediate effect.</simpara>
<figure>
<title>Salience State example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/StateExample/state_example_audit1.png" align="center"/>
</imageobject>
<textobject><phrase>state example audit1</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Rule "Bootstrap" in salience State example</title>
<para>
<screen>rule "Bootstrap"
  when
    a : State(name == "A", state == State.NOTRUN )
  then
    System.out.println(a.getName() + " finished" );
    a.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>The execution of the <literal>"Bootstrap"</literal> rule changes the state of <literal>A</literal> to <literal>FINISHED</literal>, which activates rule <literal>"A to B"</literal>.</simpara>
<formalpara>
<title>Rule "A to B" in salience State example</title>
<para>
<screen>rule "A to B"
  when
    State(name == "A", state == State.FINISHED )
    b : State(name == "B", state == State.NOTRUN )
  then
    System.out.println(b.getName() + " finished" );
    b.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>The execution of rule <literal>"A to B"</literal> changes the state of <literal>B</literal> to <literal>FINISHED</literal>, which activates both rules <literal>"B to C"</literal> and <literal>"B to D"</literal>, placing their activations onto the decision engine agenda.</simpara>
<formalpara>
<title>Rules "B to C" and "B to D" in salience State example</title>
<para>
<screen>rule "B to C"
    salience 10
  when
    State(name == "B", state == State.FINISHED )
    c : State(name == "C", state == State.NOTRUN )
  then
    System.out.println(c.getName() + " finished" );
    c.setState( State.FINISHED );
end

rule "B to D"
  when
    State(name == "B", state == State.FINISHED )
    d : State(name == "D", state == State.NOTRUN )
  then
    System.out.println(d.getName() + " finished" );
    d.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>From this point on, both rules may fire and, therefore, the rules are in conflict. The conflict resolution strategy enables the decision engine agenda to decide which rule to fire. Rule <literal>"B to C"</literal> has the higher salience value (<literal>10</literal> versus the default salience value of <literal>0</literal>), so it fires first, modifying object <literal>C</literal> to state <literal>FINISHED</literal>.</simpara>
<simpara>The <emphasis role="strong">Audit View</emphasis> in your IDE shows the modification of the <literal>State</literal> object in the rule <literal>"A to B"</literal>, which results in two activations being in conflict.</simpara>
<simpara>You can also use the <emphasis role="strong">Agenda View</emphasis> in your IDE to investigate the state of the decision engine agenda. In this example, the <emphasis role="strong">Agenda View</emphasis> shows the breakpoint in the rule <literal>"A to B"</literal> and the state of the agenda with the two conflicting rules. Rule <literal>"B to D"</literal> fires last, modifying object <literal>D</literal> to state <literal>FINISHED</literal>.</simpara>
<figure>
<title>Salience State example Agenda View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/StateExample/state_example_agenda1.png" align="center"/>
</imageobject>
<textobject><phrase>state example agenda1</phrase></textobject>
</mediaobject>
</figure>
<bridgehead xml:id="state_example_using_agenda_groups_2" renderas="sect3" remap="_state_example_using_agenda_groups_2">State example using agenda groups</bridgehead>
<simpara>The <literal>StateExampleUsingAgendaGroups</literal> version of the State example uses agenda groups in rules to resolve rule execution conflicts. Agenda groups enable you to partition the decision engine agenda to provide more execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>Initially, a working memory has its focus on the agenda group <literal>MAIN</literal>. Rules in an agenda group only fire when the group receives the focus. You can set the focus either by using the method <literal>setFocus()</literal> or the rule attribute <literal>auto-focus</literal>. The <literal>auto-focus</literal> attribute enables the rule to be given a focus automatically for its agenda group when the rule is matched and activated.</simpara>
<simpara>In this example, the <literal>auto-focus</literal> attribute enables rule <literal>"B to C"</literal> to fire before <literal>"B to D"</literal>.</simpara>
<formalpara>
<title>Rule "B to C" in agenda group State example</title>
<para>
<screen>rule "B to C"
    agenda-group "B to C"
    auto-focus true
  when
    State(name == "B", state == State.FINISHED )
    c : State(name == "C", state == State.NOTRUN )
  then
    System.out.println(c.getName() + " finished" );
    c.setState( State.FINISHED );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "B to D" ).setFocus();
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"B to C"</literal> calls <literal>setFocus()</literal> on the agenda group <literal>"B to D"</literal>, enabling its active rules to fire, which then enables the rule <literal>"B to D"</literal> to fire.</simpara>
<formalpara>
<title>Rule "B to D" in agenda group State example</title>
<para>
<screen>rule "B to D"
    agenda-group "B to D"
  when
    State(name == "B", state == State.FINISHED )
    d : State(name == "D", state == State.NOTRUN )
  then
    System.out.println(d.getName() + " finished" );
    d.setState( State.FINISHED );
end</screen>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.state.StateExampleUsingAgendaGroups</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window (same as the salience version of the State example):</simpara>
<formalpara>
<title>Agenda group State example output in the IDE console</title>
<para>
<screen>A finished
B finished
C finished
D finished</screen>
</para>
</formalpara>
<bridgehead xml:id="dynamic_facts_in_the_state_example_2" renderas="sect3" remap="_dynamic_facts_in_the_state_example_2">Dynamic facts in the State example</bridgehead>
<simpara>Another notable concept in this State example is the use of <emphasis>dynamic facts</emphasis>, based on objects that implement a <literal>PropertyChangeListener</literal> object. In order for the decision engine to see and react to changes of fact properties, the application must notify the decision engine that changes occurred. You can configure this communication explicitly in the rules by using the <literal>modify</literal> statement, or implicitly by specifying that the facts implement the <literal>PropertyChangeSupport</literal> interface as defined by the JavaBeans specification.</simpara>
<simpara>This example demonstrates how to use the <literal>PropertyChangeSupport</literal> interface to avoid the need for explicit <literal>modify</literal> statements in the rules. To make use of this interface, ensure that your facts implement <literal>PropertyChangeSupport</literal> in the same way that the class <literal>org.drools.example.State</literal> implements it, and then use the following code in the DRL rule file to configure the decision engine to listen for property changes on those facts:</simpara>
<formalpara>
<title>Declaring a dynamic fact</title>
<para>
<screen>declare type State
  @propertyChangeSupport
end</screen>
</para>
</formalpara>
<simpara>When you use <literal>PropertyChangeListener</literal> objects, each setter must implement additional code for the notification. For example, the following setter for <literal>state</literal> is in the class <literal>org.drools.examples</literal>:</simpara>
<formalpara>
<title>Setter example with PropertyChangeSupport</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public void setState(final int newState) {
    int oldState = this.state;
    this.state = newState;
    this.changes.firePropertyChange( "state",
                                     oldState,
                                     newState );
}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-fibonacci-ref_decision-engine">
<title>Fibonacci example decisions (recursion and conflict resolution)</title>
<simpara>The Fibonacci example decision set demonstrates how the decision engine uses recursion to resolve execution conflicts for rules in a sequence. The example focuses on resolving conflicts through salience values that you can define in rules.</simpara>
<simpara>The following is an overview of the Fibonacci example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>fibonacci</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.fibonacci.FibonacciExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.fibonacci.Fibonacci.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates recursion and conflict resolution through rule salience</simpara>
</listitem>
</itemizedlist>
<simpara>The Fibonacci Numbers form a sequence starting with 0 and 1. The next Fibonacci number is obtained by adding the two preceding Fibonacci numbers: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, and so on.</simpara>
<simpara>The Fibonacci example uses the single fact class <literal>Fibonacci</literal> with the following two fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>sequence</literal></simpara>
</listitem>
<listitem>
<simpara><literal>value</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>sequence</literal> field indicates the position of the object in the Fibonacci number sequence. The <literal>value</literal> field shows the value of that Fibonacci object for that sequence position, where <literal>-1</literal> indicates a value that still needs to be computed.</simpara>
<formalpara>
<title>Fibonacci class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static class Fibonacci {
    private int  sequence;
    private long value;

    public Fibonacci( final int sequence ) {
        this.sequence = sequence;
        this.value = -1;
    }

    ... setters and getters go here...
}</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.fibonacci.FibonacciExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Fibonacci example output in the IDE console</title>
<para>
<screen>recurse for 50
recurse for 49
recurse for 48
recurse for 47
...
recurse for 5
recurse for 4
recurse for 3
recurse for 2
1 == 1
2 == 1
3 == 2
4 == 3
5 == 5
6 == 8
...
47 == 2971215073
48 == 4807526976
49 == 7778742049
50 == 12586269025</screen>
</para>
</formalpara>
<simpara>To achieve this behavior in Java, the example inserts a single <literal>Fibonacci</literal> object with a sequence field of <literal>50</literal>. The example then uses a recursive rule to insert the other 49 <literal>Fibonacci</literal> objects.</simpara>
<simpara>Instead of implementing the <literal>PropertyChangeSupport</literal> interface to use dynamic facts, this example uses the MVEL dialect <literal>modify</literal> keyword to enable a block setter action and notify the decision engine of changes.</simpara>
<formalpara>
<title>Fibonacci example execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.insert( new Fibonacci( 50 ) );
ksession.fireAllRules();</programlisting>
</para>
</formalpara>
<simpara>This example uses the following three rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"Recurse"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Bootstrap"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"Calculate"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The rule <literal>"Recurse"</literal> matches each asserted <literal>Fibonacci</literal> object with a value of <literal>-1</literal>, creating and asserting a new <literal>Fibonacci</literal> object with a sequence of one less than the currently matched object. Each time a Fibonacci object is added while the one with a sequence field equal to <literal>1</literal> does not exist, the rule re-matches and fires again. The <literal>not</literal> conditional element is used to stop the rule matching once you have all 50 Fibonacci objects in memory. The rule also has a <literal>salience</literal> value because you need to have all 50 <literal>Fibonacci</literal> objects asserted before you execute the <literal>"Bootstrap"</literal> rule.</simpara>
<formalpara>
<title>Rule "Recurse"</title>
<para>
<screen>rule "Recurse"
    salience 10
  when
    f : Fibonacci ( value == -1 )
    not ( Fibonacci ( sequence == 1 ) )
  then
    insert( new Fibonacci( f.sequence - 1 ) );
    System.out.println( "recurse for " + f.sequence );
end</screen>
</para>
</formalpara>
<simpara>To better understand the execution flow of this example, you can load the audit log file from <literal>target/fibonacci.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows the original assertion of the <literal>Fibonacci</literal> object with a <literal>sequence</literal> field of <literal>50</literal>, done from Java code. From there on, the <emphasis role="strong">Audit View</emphasis> shows the continual recursion of the rule, where each asserted <literal>Fibonacci</literal> object causes the <literal>"Recurse"</literal> rule to become activated and to fire again.</simpara>
<figure>
<title>Rule "Recurse" in Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci1.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When a <literal>Fibonacci</literal> object with a <literal>sequence</literal> field of <literal>2</literal> is asserted, the <literal>"Bootstrap"</literal> rule is matched and activated along with the <literal>"Recurse"</literal> rule. Notice the multiple restrictions on field <literal>sequence</literal> that test for equality with <literal>1</literal> or <literal>2</literal>:</simpara>
<formalpara>
<title>Rule "Bootstrap"</title>
<para>
<screen>rule "Bootstrap"
  when
    f : Fibonacci( sequence == 1 || == 2, value == -1 ) // multi-restriction
  then
    modify ( f ){ value = 1 };
    System.out.println( f.sequence + " == " + f.value );
end</screen>
</para>
</formalpara>
<simpara>You can also use the <emphasis role="strong">Agenda View</emphasis> in your IDE to investigate the state of the decision engine agenda. The <literal>"Bootstrap"</literal> rule does not fire yet because the <literal>"Recurse"</literal> rule has a higher salience value.</simpara>
<figure>
<title>Rules "Recurse" and "Bootstrap" in Agenda View 1</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci_agenda1.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci agenda1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When a <literal>Fibonacci</literal> object with a <literal>sequence</literal> of <literal>1</literal> is asserted, the <literal>"Bootstrap"</literal> rule is matched again, causing two activations for this rule. The <literal>"Recurse"</literal> rule does not match and activate because the <literal>not</literal> conditional element stops the rule matching as soon as a <literal>Fibonacci</literal> object with a <literal>sequence</literal> of <literal>1</literal> exists.</simpara>
<figure>
<title>Rules "Recurse" and "Bootstrap" in Agenda View 2</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci_agenda2.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci agenda2</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>"Bootstrap"</literal> rule sets the objects with a <literal>sequence</literal> of <literal>1</literal> and <literal>2</literal> to a value of <literal>1</literal>. Now that you have two <literal>Fibonacci</literal> objects with values not equal to <literal>-1</literal>, the <literal>"Calculate"</literal> rule is able to match.</simpara>
<simpara>At this point in the example, nearly 50 <literal>Fibonacci</literal> objects exist in the working memory. You need to select a suitable triple to calculate each of their values in turn. If you use three Fibonacci patterns in a rule without field constraints to confine the possible cross products, the result would be 50x49x48 possible combinations, leading to about 125,000 possible rule firings, most of them incorrect.</simpara>
<simpara>The <literal>"Calculate"</literal> rule uses field constraints to evaluate the three Fibonacci patterns in the correct order. This technique is called <emphasis>cross-product matching</emphasis>.</simpara>
<simpara>The first pattern finds any <literal>Fibonacci</literal> object with a value <literal>!= -1</literal> and binds both the pattern and the field. The second <literal>Fibonacci</literal> object does the same thing, but adds an additional field constraint to ensure that its sequence is greater by one than the <literal>Fibonacci</literal> object bound to <literal>f1</literal>. When this rule fires for the first time, you know that only sequences <literal>1</literal> and <literal>2</literal> have values of <literal>1</literal>, and the two constraints ensure that <literal>f1</literal> references sequence <literal>1</literal> and that <literal>f2</literal> references sequence <literal>2</literal>.</simpara>
<simpara>The final pattern finds the <literal>Fibonacci</literal> object with a value equal to <literal>-1</literal> and with a sequence one greater than <literal>f2</literal>.</simpara>
<simpara>At this point in the example, three <literal>Fibonacci</literal> objects are correctly selected from the available cross products, and you can calculate the value for the third <literal>Fibonacci</literal> object that is bound to <literal>f3</literal>.</simpara>
<formalpara>
<title>Rule "Calculate"</title>
<para>
<screen>rule "Calculate"
  when
    // Bind f1 and s1.
    f1 : Fibonacci( s1 : sequence, value != -1 )
    // Bind f2 and v2, refer to bound variable s1.
    f2 : Fibonacci( sequence == (s1 + 1), v2 : value != -1 )
    // Bind f3 and s3, alternative reference of f2.sequence.
    f3 : Fibonacci( s3 : sequence == (f2.sequence + 1 ), value == -1 )
  then
    // Note the various referencing techniques.
    modify ( f3 ) { value = f1.value + v2 };
    System.out.println( s3 + " == " + f3.value );
end</screen>
</para>
</formalpara>
<simpara>The <literal>modify</literal> statement updates the value of the <literal>Fibonacci</literal> object bound to <literal>f3</literal>. This means that you now have another new <literal>Fibonacci</literal> object with a value not equal to <literal>-1</literal>, which allows the <literal>"Calculate"</literal> rule to re-match and calculate the next Fibonacci number.</simpara>
<simpara>The debug view or <emphasis role="strong">Audit View</emphasis> of your IDE shows how the firing of the last <literal>"Bootstrap"</literal> rule modifies the <literal>Fibonacci</literal> object, enabling the <literal>"Calculate"</literal> rule to match, which then modifies another <literal>Fibonacci</literal> object that enables the <literal>"Calculate"</literal> rule to match again. This process continues until the value is set for all <literal>Fibonacci</literal> objects.</simpara>
<figure>
<title>Rules in Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/FibonacciExample/fibonacci4.png" align="center"/>
</imageobject>
<textobject><phrase>fibonacci4</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="decision-examples-pricing-ref_decision-engine">
<title>Pricing example decisions (decision tables)</title>
<simpara>The Pricing example decision set demonstrates how to use a spreadsheet decision table for calculating the retail cost of an insurance policy in tabular format instead of directly in a DRL file.</simpara>
<simpara>The following is an overview of the Pricing example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>decisiontable</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.decisiontable.PricingRuleDTExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.decisiontable.ExamplePolicyPricing.xls</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates use of spreadsheet decision tables to define rules</simpara>
</listitem>
</itemizedlist>
<simpara>Spreadsheet decision tables are XLS or XLSX spreadsheets that contain business rules defined in a tabular format. You can include spreadsheet decision tables with standalone Red Hat Decision Manager projects or upload them to projects in Business Central. Each row in a decision table is a rule, and each column is a condition, an action, or another rule attribute. After you create and upload your decision tables into your Red Hat Decision Manager project, the rules you defined are compiled into Drools Rule Language (DRL) rules as with all other rule assets.</simpara>
<simpara>The purpose of the Pricing example is to provide a set of business rules to calculate the base price and a discount for a car driver applying for a specific type of insurance policy. The driver’s age and history and the policy type all contribute to calculate the basic premium, and additional rules calculate potential discounts for which the driver might be eligible.</simpara>
<simpara>To execute the example, run the <literal>org.drools.examples.decisiontable.PricingRuleDTExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<screen>Cheapest possible
BASE PRICE IS: 120
DISCOUNT IS: 20</screen>
<simpara>The code to execute the example follows the typical execution pattern: the rules are loaded, the facts are inserted, and a stateless KIE session is created. The difference in this example is that the rules are defined in an <literal>ExamplePolicyPricing.xls</literal> file instead of a DRL file or other source. The spreadsheet file is loaded into the decision engine using templates and DRL rules.</simpara>
<bridgehead xml:id="spreadsheet_decision_table_setup_2" renderas="sect3" remap="_spreadsheet_decision_table_setup_2">Spreadsheet decision table setup</bridgehead>
<simpara>The <literal>ExamplePolicyPricing.xls</literal> spreadsheet contains two decision tables in the first tab:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Base pricing rules</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Promotional discount rules</literal></simpara>
</listitem>
</itemizedlist>
<simpara>As the example spreadsheet demonstrates, you can use only the first tab of a spreadsheet to create decision tables, but multiple tables can be within a single tab. Decision tables do not necessarily follow top-down logic, but are more of a means to capture data resulting in rules. The evaluation of the rules is not necessarily in the given order, because all of the normal mechanics of the decision engine still apply. This is why you can have multiple decision tables in the same tab of a spreadsheet.</simpara>
<simpara>The decision tables are executed through the corresponding rule template files <literal>BasePricing.drt</literal> and <literal>PromotionalPricing.drt</literal>. These template files reference the decision tables through their template parameter and directly reference the various headers for the conditions and actions in the decision tables.</simpara>
<formalpara>
<title>BasePricing.drt rule template file</title>
<para>
<screen>template header
age[]
profile
priorClaims
policyType
base
reason

package org.drools.examples.decisiontable;

template "Pricing bracket"
age
policyType
base

rule "Pricing bracket_@{row.rowNumber}"
  when
    Driver(age &gt;= @{age0}, age &lt;= @{age1}
        , priorClaims == "@{priorClaims}"
        , locationRiskProfile == "@{profile}"
    )
    policy: Policy(type == "@{policyType}")
  then
    policy.setBasePrice(@{base});
    System.out.println("@{reason}");
end
end template</screen>
</para>
</formalpara>
<formalpara>
<title>PromotionalPricing.drt rule template file</title>
<para>
<screen>template header
age[]
priorClaims
policyType
discount

package org.drools.examples.decisiontable;

template "discounts"
age
priorClaims
policyType
discount

rule "Discounts_@{row.rowNumber}"
  when
    Driver(age &gt;= @{age0}, age &lt;= @{age1}, priorClaims == "@{priorClaims}")
    policy: Policy(type == "@{policyType}")
  then
    policy.applyDiscount(@{discount});
end
end template</screen>
</para>
</formalpara>
<simpara>The rules are executed through the <literal>kmodule.xml</literal> reference of the KIE Session <literal>DTableWithTemplateKB</literal>, which specifically mentions the <literal>ExamplePolicyPricing.xls</literal> spreadsheet and is required for successful execution of the rules. This execution method enables you to execute the rules as a standalone unit (as in this example) or to include the rules in a packaged knowledge JAR (KJAR) file, so that the spreadsheet is packaged along with the rules for execution.</simpara>
<simpara>The following section of the <literal>kmodule.xml</literal> file is required for the execution of the rules and spreadsheet to work successfully:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;kbase name="DecisionTableKB" packages="org.drools.examples.decisiontable"&gt;
        &lt;ksession name="DecisionTableKS" type="stateless"/&gt;
    &lt;/kbase&gt;

    &lt;kbase name="DTableWithTemplateKB" packages="org.drools.examples.decisiontable-template"&gt;
        &lt;ruleTemplate dtable="org/drools/examples/decisiontable-template/ExamplePolicyPricingTemplateData.xls"
                      template="org/drools/examples/decisiontable-template/BasePricing.drt"
                      row="3" col="3"/&gt;
        &lt;ruleTemplate dtable="org/drools/examples/decisiontable-template/ExamplePolicyPricingTemplateData.xls"
                      template="org/drools/examples/decisiontable-template/PromotionalPricing.drt"
                      row="18" col="3"/&gt;
        &lt;ksession name="DTableWithTemplateKS"/&gt;
    &lt;/kbase&gt;</programlisting>
<simpara>As an alternative to executing the decision tables using rule template files, you can use the <literal>DecisionTableConfiguration</literal> object and specify an input spreadsheet as the input type, such as <literal>DecisionTableInputType.xls</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">DecisionTableConfiguration dtableconfiguration =
    KnowledgeBuilderFactory.newDecisionTableConfiguration();
        dtableconfiguration.setInputType( DecisionTableInputType.XLS );

        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();

        Resource xlsRes = ResourceFactory.newClassPathResource( "ExamplePolicyPricing.xls",
                                                                getClass() );
        kbuilder.add( xlsRes,
                      ResourceType.DTABLE,
                      dtableconfiguration );</programlisting>
<simpara>The Pricing example uses two fact types:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Driver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Policy</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The example sets the default values for both facts in their respective Java classes <literal>Driver.java</literal> and <literal>Policy.java</literal>. The <literal>Driver</literal> is 30 years old, has had no prior claims, and currently has a risk profile of <literal>LOW</literal>. The <literal>Policy</literal> that the driver is applying for is <literal>COMPREHENSIVE</literal>.</simpara>
<simpara>In any decision table, each row is considered a different rule and each column is a condition or an action. Each row is evaluated in a decision table unless the agenda is cleared upon execution.</simpara>
<simpara>Decision table spreadsheets (XLS or XLSX) require two key areas that define rule data:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>RuleSet</literal> area</simpara>
</listitem>
<listitem>
<simpara>A <literal>RuleTable</literal> area</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>RuleSet</literal> area of the spreadsheet defines elements that you want to apply globally to all rules in the same package (not only the spreadsheet), such as a rule set name or universal rule attributes. The <literal>RuleTable</literal> area defines the actual rules (rows) and the conditions, actions, and other rule attributes (columns) that constitute that rule table within the specified rule set. A decision table spreadsheet can contain multiple <literal>RuleTable</literal> areas, but only one <literal>RuleSet</literal> area.</simpara>
<figure>
<title>Decision table configuration</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Config.png" align="center"/>
</imageobject>
<textobject><phrase>DT Config</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>RuleTable</literal> area also defines the objects to which the rule attributes apply, in this case <literal>Driver</literal> and <literal>Policy</literal>, followed by constraints on the objects. For example, the <literal>Driver</literal> object constraint that defines the <literal>Age Bracket</literal> column is <literal>age &gt;= $1, age &lt;= $2</literal>, where the comma-separated range is defined in the table column values, such as <literal>18,24</literal>.</simpara>
<bridgehead xml:id="base_pricing_rules_2" renderas="sect3" remap="_base_pricing_rules_2">Base pricing rules</bridgehead>
<simpara>The <literal>Base pricing rules</literal> decision table in the Pricing example evaluates the age, risk profile, number of claims, and policy type of the driver and produces the base price of the policy based on these conditions.</simpara>
<figure>
<title>Base price calculation</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Table1.png" align="center"/>
</imageobject>
<textobject><phrase>DT Table1</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>Driver</literal> attributes are defined in the following table columns:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Age Bracket</literal>: The age bracket has a definition for the condition <literal>age &gt;=$1, age &lt;=$2</literal>, which defines the condition boundaries for the driver’s age. This condition column highlights the use of <literal>$1 and $2</literal>, which is comma delimited in the spreadsheet. You can write these values as <literal>18,24</literal> or <literal>18, 24</literal> and both formats work in the execution of the business rules.</simpara>
</listitem>
<listitem>
<simpara><literal>Location risk profile</literal>: The risk profile is a string that the example program passes always as <literal>LOW</literal> but can be changed to reflect <literal>MED</literal> or <literal>HIGH</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Number of prior claims</literal>: The number of claims is defined as an integer that the condition column must exactly equal to trigger the action. The value is not a range, only exact matches.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>Policy</literal> of the decision table is used in both the conditions and the actions of the rule and has attributes defined in the following table columns:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Policy type applying for</literal>: The policy type is a condition that is passed as a string that defines the type of coverage: <literal>COMPREHENSIVE</literal>, <literal>FIRE_THEFT</literal>, or <literal>THIRD_PARTY</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Base $ AUD</literal>: The <literal>basePrice</literal> is defined as an <literal>ACTION</literal> that sets the price through the constraint <literal>policy.setBasePrice($param);</literal> based on the spreadsheet cells corresponding to this value. When you execute the corresponding DRL rule for this decision table, the <literal>then</literal> portion of the rule executes this action statement on the true conditions matching the facts and sets the base price to the corresponding value.</simpara>
</listitem>
<listitem>
<simpara><literal>Record Reason</literal>: When the rule successfully executes, this action generates an output message to the <literal>System.out</literal> console reflecting which rule fired. This is later captured in the application and printed.</simpara>
</listitem>
</itemizedlist>
<simpara>The example also uses the first column on the left to categorize rules. This column is for annotation only and has no affect on rule execution.</simpara>
<bridgehead xml:id="promotional_discount_rules_2" renderas="sect3" remap="_promotional_discount_rules_2">Promotional discount rules</bridgehead>
<simpara>The <literal>Promotional discount rules</literal> decision table in the Pricing example evaluates the age, number of prior claims, and policy type of the driver to generate a potential discount on the price of the insurance policy.</simpara>
<figure>
<title>Discount calculation</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PricingExample/DT_Table2.png" align="center"/>
</imageobject>
<textobject><phrase>DT Table2</phrase></textobject>
</mediaobject>
</figure>
<simpara>This decision table contains the conditions for the discount for which the driver might be eligible. Similar to the base price calculation, this table evaluates the <literal>Age</literal>, <literal>Number of prior claims</literal> of the driver, and the <literal>Policy type applying for</literal> to determine a <literal>Discount %</literal> rate to be applied. For example, if the driver is 30 years old, has no prior claims, and is applying for a <literal>COMPREHENSIVE</literal> policy, the driver is given a discount of <literal>20</literal> percent.</simpara>
</section>
<section xml:id="decision-examples-petstore-ref_decision-engine">
<title>Pet Store example decisions (agenda groups, global variables, callbacks, and GUI integration)</title>
<simpara>The Pet Store example decision set demonstrates how to use agenda groups and global variables in rules and how to integrate Red Hat Decision Manager rules with a graphical user interface (GUI), in this case a Swing-based desktop application. The example also demonstrates how to use callbacks to interact with a running decision engine to update the GUI based on changes in the working memory at run time.</simpara>
<simpara>The following is an overview of the Pet Store example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>petstore</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.petstore.PetStoreExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.petstore.PetStore.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates rule agenda groups, global variables, callbacks, and GUI integration</simpara>
</listitem>
</itemizedlist>
<simpara>In the Pet Store example, the sample <literal>PetStoreExample.java</literal> class defines the following principal classes (in addition to several classes to handle Swing events):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Petstore</literal> contains the <literal>main()</literal> method.</simpara>
</listitem>
<listitem>
<simpara><literal>PetStoreUI</literal> is responsible for creating and displaying the Swing-based GUI. This class contains several smaller classes, mainly for responding to various GUI events, such as user mouse clicks.</simpara>
</listitem>
<listitem>
<simpara><literal>TableModel</literal> holds the table data. This class is essentially a JavaBean that extends the Swing class <literal>AbstractTableModel</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>CheckoutCallback</literal> enables the GUI to interact with the rules.</simpara>
</listitem>
<listitem>
<simpara><literal>Ordershow</literal> keeps the items that you want to buy.</simpara>
</listitem>
<listitem>
<simpara><literal>Purchase</literal> stores details of the order and the products that you are buying.</simpara>
</listitem>
<listitem>
<simpara><literal>Product</literal> is a JavaBean containing details of the product available for purchase and its price.</simpara>
</listitem>
</itemizedlist>
<simpara>Much of the Java code in this example is either plain JavaBean or Swing based. For more information about Swing components, see the Java tutorial on <link xlink:href="https://docs.oracle.com/javase/tutorial/uiswing/">Creating a GUI with JFC/Swing</link>.</simpara>
<bridgehead xml:id="rule_execution_behavior_in_the_pet_store_example_2" renderas="sect3" remap="_rule_execution_behavior_in_the_pet_store_example_2">Rule execution behavior in the Pet Store example</bridgehead>
<simpara>Unlike other example decision sets where the facts are asserted and fired immediately, the Pet Store example does not execute the rules until more facts are gathered based on user interaction. The example executes rules through a <literal>PetStoreUI</literal> object, created by a constructor, that accepts the <literal>Vector</literal> object <literal>stock</literal> for collecting the products. The example then uses an instance of the <literal>CheckoutCallback</literal> class containing the rule base that was previously loaded.</simpara>
<formalpara>
<title>Pet Store KIE container and fact execution setup</title>
<para>
<programlisting language="java" linenumbering="unnumbered">// KieServices is the factory for all KIE services.
KieServices ks = KieServices.Factory.get();

// Create a KIE container on the class path.
KieContainer kc = ks.getKieClasspathContainer();

// Create the stock.
Vector&lt;Product&gt; stock = new Vector&lt;Product&gt;();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the working memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kc ) );
ui.createAndShowGUI();</programlisting>
</para>
</formalpara>
<simpara>The Java code that fires the rules is in the <literal>CheckoutCallBack.checkout()</literal> method. This method is triggered when the user clicks <emphasis role="strong">Checkout</emphasis> in the UI.</simpara>
<formalpara>
<title>Rule execution from CheckoutCallBack.checkout()</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public String checkout(JFrame frame, List&lt;Product&gt; items) {
    Order order = new Order();

    // Iterate through list and add to cart.
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction.

    // From the KIE container, a KIE session is created based on
    // its definition and configuration in the META-INF/kmodule.xml file.
    KieSession ksession = kcontainer.newKieSession("PetStoreKS");

    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );

    // Execute rules.
    ksession.fireAllRules();

    // Return the state of the cart
    return order.toString();
}</programlisting>
</para>
</formalpara>
<simpara>The example code passes two elements into the <literal>CheckoutCallBack.checkout()</literal> method. One element is the handle for the <literal>JFrame</literal> Swing component surrounding the output text frame, found at the bottom of the GUI. The second element is a list of order items, which comes from the <literal>TableModel</literal> that stores the information from the <literal>Table</literal> area at the upper-right section of the GUI.</simpara>
<simpara>The <literal>for</literal> loop transforms the list of order items coming from the GUI into the <literal>Order</literal> JavaBean, also contained in the file <literal>PetStoreExample.java</literal>.</simpara>
<simpara>In this case, the rule is firing in a stateless KIE session because all of the data is stored in Swing components and is not executed until the user clicks <emphasis role="strong">Checkout</emphasis> in the UI. Each time the user clicks <emphasis role="strong">Checkout</emphasis>, the content of the list is moved from the Swing <literal>TableModel</literal> into the KIE session working memory and is then executed with the <literal>ksession.fireAllRules()</literal> method.</simpara>
<simpara>Within this code, there are nine calls to <literal>KieSession</literal>. The first of these creates a new <literal>KieSession</literal> from the <literal>KieContainer</literal> (the example passed in this <literal>KieContainer</literal> from the <literal>CheckoutCallBack</literal> class in the <literal>main()</literal> method). The next two calls pass in the two objects that hold the global variables in the rules: the Swing text area and the Swing frame used for writing messages. More inserts put information on products into the <literal>KieSession</literal>, as well as the order list. The final call is the standard <literal>fireAllRules()</literal>.</simpara>
<bridgehead xml:id="pet_store_rule_file_imports_global_variables_and_java_functions_2" renderas="sect3" remap="_pet_store_rule_file_imports_global_variables_and_java_functions_2">Pet Store rule file imports, global variables, and Java functions</bridgehead>
<simpara>The <literal>PetStore.drl</literal> file contains the standard package and import statements to make various Java classes available to the rules. The rule file also includes <emphasis>global variables</emphasis> to be used within the rules, defined as  <literal>frame</literal> and <literal>textArea</literal>. The global variables hold references to the Swing components <literal>JFrame</literal> and <literal>JTextArea</literal> components that were previously passed on by the Java code that called the <literal>setGlobal()</literal> method. Unlike standard variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the KIE session. This means the contents of these global variables are available for evaluation on all subsequent rules.</simpara>
<formalpara>
<title>PetStore.drl package, imports, and global variables</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.drools.examples;

import org.kie.api.runtime.KieRuntime;
import org.drools.examples.petstore.PetStoreExample.Order;
import org.drools.examples.petstore.PetStoreExample.Purchase;
import org.drools.examples.petstore.PetStoreExample.Product;
import java.util.ArrayList;
import javax.swing.JOptionPane;

import javax.swing.JFrame;

global JFrame frame
global javax.swing.JTextArea textArea</programlisting>
</para>
</formalpara>
<simpara>The <literal>PetStore.drl</literal> file also contains two functions that the rules in the file use:</simpara>
<formalpara>
<title>PetStore.drl Java functions</title>
<para>
<programlisting language="java" linenumbering="unnumbered">function void doCheckout(JFrame frame, KieRuntime krt) {
        Object[] options = {"Yes",
                            "No"};

        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to checkout?",
                                             "",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       if (n == 0) {
            krt.getAgenda().getAgendaGroup( "checkout" ).setFocus();
       }
}

function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) {
        Object[] options = {"Yes",
                            "No"};

        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to buy a tank for your " + total + " fish?",
                                             "Purchase Suggestion",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                           + total + " fish? - " );

       if (n == 0) {
             Purchase purchase = new Purchase( order, fishTank );
             krt.insert( purchase );
             order.addItem( purchase );
             System.out.println( "Yes" );
       } else {
            System.out.println( "No" );
       }
       return true;
}</programlisting>
</para>
</formalpara>
<simpara>The two functions perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>doCheckout()</literal> displays a dialog that asks the user if she or he wants to check out. If the user does, the focus is set to the <literal>checkout</literal> agenda group, enabling rules in that group to (potentially) fire.</simpara>
</listitem>
<listitem>
<simpara><literal>requireTank()</literal> displays a dialog that asks the user if she or he wants to buy a fish tank. If the user does, a new fish tank <literal>Product</literal> is added to the order list in the working memory.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For this example, all rules and functions are within the same rule file for efficiency. In a production environment, you typically separate the rules and functions in different files or build a static Java method and import the files using the import function, such as <literal>import function my.package.name.hello</literal>.</simpara>
</note>
<bridgehead xml:id="pet_store_rules_with_agenda_groups_2" renderas="sect3" remap="_pet_store_rules_with_agenda_groups_2">Pet Store rules with agenda groups</bridgehead>
<simpara>Most of the rules in the Pet Store example use agenda groups to control rule execution. Agenda groups allow you to partition the decision engine agenda to provide more execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>Initially, a working memory has its focus on the agenda group <literal>MAIN</literal>. Rules in an agenda group only fire when the group receives the focus. You can set the focus either by using the method <literal>setFocus()</literal> or the rule attribute <literal>auto-focus</literal>. The <literal>auto-focus</literal> attribute enables the rule to be given a focus automatically for its agenda group when the rule is matched and activated.</simpara>
<simpara>The Pet Store example uses the following agenda groups for rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"init"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"evaluate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"show items"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"checkout"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>For example, the sample rule <literal>"Explode Cart"</literal> uses the <literal>"init"</literal> agenda group to ensure that it has the option to fire and insert shopping cart items into the KIE session working memory:</simpara>
<formalpara>
<title>Rule "Explode Cart"</title>
<para>
<screen>// Insert each item in the shopping cart into the working memory.
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
  when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
  then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end</screen>
</para>
</formalpara>
<simpara>This rule matches against all orders that do not yet have their <literal>grossTotal</literal> calculated. The execution loops for each purchase item in that order.</simpara>
<simpara>The rule uses the following features related to its agenda group:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>agenda-group "init"</literal> defines the name of the agenda group. In this case, only one rule is in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the <literal>auto-focus</literal> attribute for its chance to fire.</simpara>
</listitem>
<listitem>
<simpara><literal>auto-focus true</literal> ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when <literal>fireAllRules()</literal> is called from the Java code.</simpara>
</listitem>
<listitem>
<simpara><literal>kcontext…​.setFocus()</literal> sets the focus to the <literal>"show items"</literal> and <literal>"evaluate"</literal> agenda groups, enabling their rules to fire. In practice, you loop through all items in the order, insert them into memory, and then fire the other rules after each insertion.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>"show items"</literal> agenda group contains only one rule, <literal>"Show Items"</literal>. For each purchase in the order currently in the KIE session working memory, the rule logs details to the text area at the bottom of the GUI, based on the <literal>textArea</literal> variable defined in the rule file.</simpara>
<formalpara>
<title>Rule "Show Items"</title>
<para>
<screen>rule "Show Items"
    agenda-group "show items"
  when
    $order : Order()
    $p : Purchase( order == $order )
  then
   textArea.append( $p.product + "\n");
end</screen>
</para>
</formalpara>
<simpara>The <literal>"evaluate"</literal> agenda group also gains focus from the <literal>"Explode Cart"</literal> rule. This agenda group contains two rules, <literal>"Free Fish Food Sample"</literal> and <literal>"Suggest Tank"</literal>, which are executed in that order.</simpara>
<formalpara>
<title>Rule "Free Fish Food Sample"</title>
<para>
<screen>// Free fish food sample when users buy a goldfish if they did not already buy
// fish food and do not already have a fish food sample.
rule "Free Fish Food Sample"
    agenda-group "evaluate" <co xml:id="CO15-1"/>
  when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO15-2"/>
    not ( $p : Product( name == "Fish Food Sample") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO15-3"/>
    exists ( $p : Product( name == "Gold Fish") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO15-4"/>
    $fishFoodSample : Product( name == "Fish Food Sample" );
  then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase );
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"Free Fish Food Sample"</literal> fires only if all of the following conditions are true:</simpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>The agenda group <literal>"evaluate"</literal> is being evaluated in the rules execution.</para>
</callout>
<callout arearefs="CO15-2">
<para>User does not already have fish food.</para>
</callout>
<callout arearefs="CO15-3">
<para>User does not already have a free fish food sample.</para>
</callout>
<callout arearefs="CO15-4">
<para>User has a goldfish in the order.</para>
</callout>
</calloutlist>
<simpara>If the order facts meet all of these requirements, then a new product is created (Fish Food Sample) and is added to the order in working memory.</simpara>
<formalpara>
<title>Rule "Suggest Tank"</title>
<para>
<screen>// Suggest a fish tank if users buy more than five goldfish and
// do not already have a tank.
rule "Suggest Tank"
    agenda-group "evaluate"
  when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;&amp; Purchase( product == $p ) ) <co xml:id="CO16-1"/>
    ArrayList( $total : size &gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) ) <co xml:id="CO16-2"/>
    $fishTank : Product( name == "Fish Tank" )
  then
    requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total);
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"Suggest Tank"</literal> fires only if the following conditions are true:</simpara>
<calloutlist>
<callout arearefs="CO16-1">
<para>User does not have a fish tank in the order.</para>
</callout>
<callout arearefs="CO16-2">
<para>User has more than five fish in the order.</para>
</callout>
</calloutlist>
<simpara>When the rule fires, it calls the <literal>requireTank()</literal> function defined in the rule file. This function displays a dialog that asks the user if she or he wants to buy a fish tank. If the user does, a new fish tank <literal>Product</literal> is added to the order list in the working memory. When the rule calls the <literal>requireTank()</literal> function, the rule passes the <literal>frame</literal> global variable so that the function has a handle for the Swing GUI.</simpara>
<simpara>The <literal>"do checkout"</literal> rule in the Pet Store example has no agenda group and no <literal>when</literal> conditions, so the rule is always executed and considered part of the default <literal>MAIN</literal> agenda group.</simpara>
<formalpara>
<title>Rule "do checkout"</title>
<para>
<screen>rule "do checkout"
  when
  then
    doCheckout(frame, kcontext.getKieRuntime());
end</screen>
</para>
</formalpara>
<simpara>When the rule fires, it calls the <literal>doCheckout()</literal> function defined in the rule file. This function displays a dialog that asks the user if she or he wants to check out. If the user does, the focus is set to the <literal>checkout</literal> agenda group, enabling rules in that group to (potentially) fire. When the rule calls the <literal>doCheckout()</literal> function, the rule passes the <literal>frame</literal> global variable so that the function has a handle for the Swing GUI.</simpara>
<note>
<simpara>This example also demonstrates a troubleshooting technique if results are not executing as you expect: You can remove the conditions from the <literal>when</literal> statement of a rule and test the action in the <literal>then</literal> statement to verify that the action is performed correctly.</simpara>
</note>
<simpara>The <literal>"checkout"</literal> agenda group contains three rules for processing the order checkout and applying any discounts: <literal>"Gross Total"</literal>, <literal>"Apply 5% Discount"</literal>, and <literal>"Apply 10% Discount"</literal>.</simpara>
<formalpara>
<title>Rules "Gross Total", "Apply 5% Discount", and "Apply 10% Discount"</title>
<para>
<screen>rule "Gross Total"
    agenda-group "checkout"
  when
    $order : Order( grossTotal == -1)
    Number( total : doubleValue ) from accumulate( Purchase( $price : product.price ),
                                                              sum( $price ) )
  then
    modify( $order ) { grossTotal = total }
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
  when
    $order : Order( grossTotal &gt;= 10 &amp;&amp; &lt; 20 )
  then
    $order.discountedTotal = $order.grossTotal * 0.95;
    textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end

rule "Apply 10% Discount"
    agenda-group "checkout"
  when
    $order : Order( grossTotal &gt;= 20 )
  then
    $order.discountedTotal = $order.grossTotal * 0.90;
    textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end</screen>
</para>
</formalpara>
<simpara>If the user has not already calculated the gross total, the <literal>Gross Total</literal> accumulates the product prices into a total, puts this total into the KIE session, and displays it through the Swing <literal>JTextArea</literal> using the <literal>textArea</literal> global variable.</simpara>
<simpara>If the gross total is between <literal>10</literal> and <literal>20</literal> (currency units), the <literal>"Apply 5% Discount"</literal> rule calculates the discounted total, adds it to the KIE session, and displays it in the text area.</simpara>
<simpara>If the gross total is not less than <literal>20</literal>, the <literal>"Apply 10% Discount"</literal> rule calculates the discounted total, adds it to the KIE session, and displays it in the text area.</simpara>
<bridgehead xml:id="pet_store_example_execution_2" renderas="sect3" remap="_pet_store_example_execution_2">Pet Store example execution</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Pet Store example by running the <literal>org.drools.examples.petstore.PetStoreExample</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Pet Store example, the <literal>Pet Store Demo</literal> GUI window appears. This window displays a list of available products (upper left), an empty list of selected products (upper right), <emphasis role="strong">Checkout</emphasis> and <emphasis role="strong">Reset</emphasis> buttons (middle), and an empty system messages area (bottom).</simpara>
<figure>
<title>Pet Store example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/1-PetStore-Start-Screen.png" align="center"/>
</imageobject>
<textobject><phrase>1 PetStore Start Screen</phrase></textobject>
</mediaobject>
</figure>
<simpara>The following events occurred in this example to establish this execution behavior:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>main()</literal> method has run and loaded the rule base but has not yet fired the rules. So far, this is the only code in connection with rules that has been run.</simpara>
</listitem>
<listitem>
<simpara>A new <literal>PetStoreUI</literal> object has been created and given a handle for the rule base, for later use.</simpara>
</listitem>
<listitem>
<simpara>Various Swing components have performed their functions, and the initial UI screen is displayed and waits for user input.</simpara>
</listitem>
</orderedlist>
<simpara>You can click various products from the list to explore the UI setup:</simpara>
<figure>
<title>Explore the Pet Store example GUI</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/2-stock-added-to-order-list.png" align="center"/>
</imageobject>
<textobject><phrase>2 stock added to order list</phrase></textobject>
</mediaobject>
</figure>
<simpara>No rules code has been fired yet. The UI uses Swing code to detect user mouse clicks and add selected products to the <literal>TableModel</literal> object for display in the upper-right corner of the UI. This example illustrates the Model-View-Controller design pattern.</simpara>
<simpara>When you click <emphasis role="strong">Checkout</emphasis>, the rules are then fired in the following way:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Method <literal>CheckOutCallBack.checkout()</literal> is called (eventually) by the Swing class waiting for a user to click <emphasis role="strong">Checkout</emphasis>. This inserts the data from the <literal>TableModel</literal> object (upper-right corner of the UI) into the KIE session working memory. The method then fires the rules.</simpara>
</listitem>
<listitem>
<simpara>The <literal>"Explode Cart"</literal> rule is the first to fire, with the <literal>auto-focus</literal> attribute set to <literal>true</literal>. The rule loops through all of the products in the cart, ensures that the products are in the working memory, and then gives the <literal>"show Items"</literal> and <literal>"evaluate"</literal> agenda groups the option to fire. The rules in these groups add the contents of the cart to the text area (bottom of the UI), evaluate if you are eligible for free fish food, and determine whether to ask if you want to buy a fish tank.</simpara>
<figure>
<title>Fish tank qualification</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/3-purchase-suggestion.png" align="center"/>
</imageobject>
<textobject><phrase>3 purchase suggestion</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>The <literal>"do checkout"</literal> rule is the next to fire because no other agenda group currently has focus and because it is part of the default <literal>MAIN</literal> agenda group. This rule always calls the <literal>doCheckout()</literal> function, which asks you if you want to check out.</simpara>
</listitem>
<listitem>
<simpara>The <literal>doCheckout()</literal> function sets the focus to the <literal>"checkout"</literal> agenda group, giving the rules in that group the option to fire.</simpara>
</listitem>
<listitem>
<simpara>The rules in the <literal>"checkout"</literal> agenda group display the contents of the cart and apply the appropriate discount.</simpara>
</listitem>
<listitem>
<simpara>Swing then waits for user input to either select more products (and cause the rules to fire again) or to close the UI.</simpara>
<figure>
<title>Pet Store example GUI after all rules have fired</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/PetStoreExample/4-Petstore-final-screen.png" align="center"/>
</imageobject>
<textobject><phrase>4 Petstore final screen</phrase></textobject>
</mediaobject>
</figure>
</listitem>
</orderedlist>
<simpara>You can add more <literal>System.out</literal> calls to demonstrate this flow of events in your IDE console:</simpara>
<formalpara>
<title>System.out output in the IDE console</title>
<para>
<screen>Adding free Fish Food Sample to cart
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes</screen>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-politician-ref_decision-engine">
<title>Honest Politician example decisions (truth maintenance and salience)</title>
<simpara>The Honest Politician example decision set demonstrates the concept of truth maintenance with logical insertions and the use of salience in rules.</simpara>
<simpara>The following is an overview of the Honest Politician example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>honestpolitician</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.honestpolitician.HonestPoliticianExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.honestpolitician.HonestPolitician.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates the concept of truth maintenance based on the logical insertion of facts and the use of salience in rules</simpara>
</listitem>
</itemizedlist>
<simpara>The basic premise of the Honest Politician example is that an object can only exist while a statement is true. A rule consequence can logically insert an object with the <literal>insertLogical()</literal> method. This means the object remains in the KIE session working memory as long as the rule that logically inserted it remains true. When the rule is no longer true, the object is automatically retracted.</simpara>
<simpara>In this example, rule execution causes a group of politicians to change from being honest to being dishonest as a result of a corrupt corporation. As each politician is evaluated, they start out with their honesty attribute being set to <literal>true</literal>, but a rule fires that makes the politicians no longer honest. As they switch their state from being honest to dishonest, they are then removed from the working memory. The rule salience notifies the decision engine how to prioritize any rules that have a salience defined for them, otherwise utilizing the default salience value of <literal>0</literal>. Rules with a higher salience value are given higher priority when ordered in the activation queue.</simpara>
<bridgehead xml:id="politician_and_hope_classes_2" renderas="sect3" remap="_politician_and_hope_classes_2">Politician and Hope classes</bridgehead>
<simpara>The sample class <literal>Politician</literal> in the example is configured for an honest politician. The <literal>Politician</literal> class is made up of a String item <literal>name</literal> and a Boolean item <literal>honest</literal>:</simpara>
<formalpara>
<title>Politician class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Politician {
    private String name;
    private boolean honest;
    ...
}</programlisting>
</para>
</formalpara>
<simpara>The <literal>Hope</literal> class determines if a <literal>Hope</literal> object exists. This class has no meaningful members, but is present in the working memory as long as society has hope.</simpara>
<formalpara>
<title>Hope class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public class Hope {

    public Hope() {

    }
  }</programlisting>
</para>
</formalpara>
<bridgehead xml:id="rule_definitions_for_politician_honesty_2" renderas="sect3" remap="_rule_definitions_for_politician_honesty_2">Rule definitions for politician honesty</bridgehead>
<simpara>In the Honest Politician example, when at least one honest politician exists in the working memory, the <literal>"We have an honest Politician"</literal> rule logically inserts a new <literal>Hope</literal> object. As soon as all politicians become dishonest, the <literal>Hope</literal> object is automatically retracted. This rule has a <literal>salience</literal> attribute with a value of <literal>10</literal> to ensure that it fires before any other rule, because at that stage the <literal>"Hope is Dead"</literal> rule is true.</simpara>
<formalpara>
<title>Rule "We have an honest politician"</title>
<para>
<screen>rule "We have an honest Politician"
    salience 10
  when
    exists( Politician( honest == true ) )
  then
    insertLogical( new Hope() );
end</screen>
</para>
</formalpara>
<simpara>As soon as a <literal>Hope</literal> object exists, the <literal>"Hope Lives"</literal> rule matches and fires. This rule also has a <literal>salience</literal> value of <literal>10</literal> so that it takes priority over the <literal>"Corrupt the Honest"</literal> rule.</simpara>
<formalpara>
<title>Rule "Hope Lives"</title>
<para>
<screen>rule "Hope Lives"
    salience 10
  when
    exists( Hope() )
  then
    System.out.println("Hurrah!!! Democracy Lives");
end</screen>
</para>
</formalpara>
<simpara>Initially, four honest politicians exist so this rule has four activations, all in conflict. Each rule fires in turn, corrupting each politician so that they are no longer honest. When all four politicians have been corrupted, no politicians have the property <literal>honest == true</literal>. The rule <literal>"We have an honest Politician"</literal> is no longer true and the object it logically inserted (due to the last execution of <literal>new Hope()</literal>) is automatically retracted.</simpara>
<formalpara>
<title>Rule "Corrupt the Honest"</title>
<para>
<screen>rule "Corrupt the Honest"
  when
    politician : Politician( honest == true )
    exists( Hope() )
  then
    System.out.println( "I'm an evil corporation and I have corrupted " + politician.getName() );
    modify ( politician ) { honest = false };
end</screen>
</para>
</formalpara>
<simpara>With the <literal>Hope</literal> object automatically retracted through the truth maintenance system, the conditional element <literal>not</literal> applied to <literal>Hope</literal> is no longer true so that the <literal>"Hope is Dead"</literal> rule matches and fires.</simpara>
<formalpara>
<title>Rule "Hope is Dead"</title>
<para>
<screen>rule "Hope is Dead"
  when
    not( Hope() )
  then
    System.out.println( "We are all Doomed!!! Democracy is Dead" );
end</screen>
</para>
</formalpara>
<bridgehead xml:id="example_execution_and_audit_trail_2" renderas="sect3" remap="_example_execution_and_audit_trail_2">Example execution and audit trail</bridgehead>
<simpara>In the <literal>HonestPoliticianExample.java</literal> class, the four politicians with the honest state set to <literal>true</literal> are inserted for evaluation against the defined business rules:</simpara>
<formalpara>
<title>HonestPoliticianExample.java class execution</title>
<para>
<programlisting language="java" linenumbering="unnumbered">public static void execute( KieContainer kc ) {
        KieSession ksession = kc.newKieSession("HonestPoliticianKS");

        final Politician p1 = new Politician( "President of Umpa Lumpa", true );
        final Politician p2 = new Politician( "Prime Minster of Cheeseland", true );
        final Politician p3 = new Politician( "Tsar of Pringapopaloo", true );
        final Politician p4 = new Politician( "Omnipotence Om", true );

        ksession.insert( p1 );
        ksession.insert( p2 );
        ksession.insert( p3 );
        ksession.insert( p4 );

        ksession.fireAllRules();

        ksession.dispose();
    }</programlisting>
</para>
</formalpara>
<simpara>To execute the example, run the <literal>org.drools.examples.honestpolitician.HonestPoliticianExample</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Execution output in the IDE console</title>
<para>
<screen>Hurrah!!! Democracy Lives
I'm an evil corporation and I have corrupted President of Umpa Lumpa
I'm an evil corporation and I have corrupted Prime Minster of Cheeseland
I'm an evil corporation and I have corrupted Tsar of Pringapopaloo
I'm an evil corporation and I have corrupted Omnipotence Om
We are all Doomed!!! Democracy is Dead</screen>
</para>
</formalpara>
<simpara>The output shows that, while there is at least one honest politician, democracy lives. However, as each politician is corrupted by some corporation, all politicians become dishonest, and democracy is dead.</simpara>
<simpara>To better understand the execution flow of this example, you can modify the <literal>HonestPoliticianExample.java</literal> class to include a <literal>DebugRuleRuntimeEventListener</literal> listener and an audit logger to view execution details:</simpara>
<formalpara>
<title>HonestPoliticianExample.java class with an audit logger</title>
<para>
<programlisting language="java" linenumbering="unnumbered">package org.drools.examples.honestpolitician;

import org.kie.api.KieServices;
import org.kie.api.event.rule.DebugAgendaEventListener; <co xml:id="CO17-1"/>
import org.kie.api.event.rule.DebugRuleRuntimeEventListener;
import org.kie.api.runtime.KieContainer;
import org.kie.api.runtime.KieSession;

public class HonestPoliticianExample {

    /**
     * @param args
     */
    public static void main(final String[] args) {
    	KieServices ks = KieServices.Factory.get(); <co xml:id="CO17-2"/>
    	//ks = KieServices.Factory.get();
        KieContainer kc = KieServices.Factory.get().getKieClasspathContainer();
        System.out.println(kc.verify().getMessages().toString());
        //execute( kc );
        execute( ks, kc); <co xml:id="CO17-3"/>
    }

    public static void execute( KieServices ks, KieContainer kc ) { <co xml:id="CO17-4"/>
        KieSession ksession = kc.newKieSession("HonestPoliticianKS");

        final Politician p1 = new Politician( "President of Umpa Lumpa", true );
        final Politician p2 = new Politician( "Prime Minster of Cheeseland", true );
        final Politician p3 = new Politician( "Tsar of Pringapopaloo", true );
        final Politician p4 = new Politician( "Omnipotence Om", true );

        ksession.insert( p1 );
        ksession.insert( p2 );
        ksession.insert( p3 );
        ksession.insert( p4 );

        // The application can also setup listeners <co xml:id="CO17-5"/>
        ksession.addEventListener( new DebugAgendaEventListener() );
        ksession.addEventListener( new DebugRuleRuntimeEventListener() );

        // Set up a file-based audit logger.
        ks.getLoggers().newFileLogger( ksession, "./target/honestpolitician" ); <co xml:id="CO17-6"/>

        ksession.fireAllRules();

        ksession.dispose();
    }

}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>Adds to your imports the packages that handle the <literal>DebugAgendaEventListener</literal> and <literal>DebugRuleRuntimeEventListener</literal></para>
</callout>
<callout arearefs="CO17-2">
<para>Creates a <literal>KieServices Factory</literal> and a <literal>ks</literal> element to produce the logs because this audit log is not available at the <literal>KieContainer</literal> level</para>
</callout>
<callout arearefs="CO17-3">
<para>Modifies the <literal>execute</literal> method to use both <literal>KieServices</literal> and <literal>KieContainer</literal></para>
</callout>
<callout arearefs="CO17-4">
<para>Modifies the <literal>execute</literal> method to pass in <literal>KieServices</literal> in addition to the <literal>KieContainer</literal></para>
</callout>
<callout arearefs="CO17-5">
<para>Creates the listeners</para>
</callout>
<callout arearefs="CO17-6">
<para>Builds the log that can be passed into the debug view or <emphasis role="strong">Audit View</emphasis> or your IDE after executing of the rules</para>
</callout>
</calloutlist>
<simpara>When you run the Honest Politician with this modified logging capability, you can load the audit log file from <literal>target/honestpolitician.log</literal> into your IDE debug view or <emphasis role="strong">Audit View</emphasis>, if available (for example, in <emphasis role="strong">Window</emphasis> → <emphasis role="strong">Show View</emphasis> in some IDEs).</simpara>
<simpara>In this example, the <emphasis role="strong">Audit View</emphasis> shows the flow of executions, insertions, and retractions as defined in the example classes and rules:</simpara>
<figure>
<title>Honest Politician example Audit View</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/HonestPoliticianExample/honest_politician_audit.png" align="center"/>
</imageobject>
<textobject><phrase>honest politician audit</phrase></textobject>
</mediaobject>
</figure>
<simpara>When the first politician is inserted, two activations occur. The rule <literal>"We have an honest Politician"</literal> is activated only one time for the first inserted politician because it uses an <literal>exists</literal> conditional element, which matches when at least one politician is inserted. The rule <literal>"Hope is Dead"</literal> is also activated at this stage because the <literal>Hope</literal> object is not yet inserted. The rule <literal>"We have an honest Politician"</literal> fires first because it has a higher <literal>salience</literal> value than the rule <literal>"Hope is Dead"</literal>, and inserts the <literal>Hope</literal> object (highlighted in green). The insertion of the <literal>Hope</literal> object activates the rule <literal>"Hope Lives"</literal> and deactivates the rule <literal>"Hope is Dead"</literal>. The insertion also activates the rule <literal>"Corrupt the Honest"</literal> for each inserted honest politician. The rule <literal>"Hope Lives"</literal> is executed and prints <literal>"Hurrah!!! Democracy Lives"</literal>.</simpara>
<simpara>Next, for each politician, the rule <literal>"Corrupt the Honest"</literal> fires, printing <literal>"I’m an evil corporation and I have corrupted X"</literal>, where <literal>X</literal> is the name of the politician, and modifies the politician honesty value to <literal>false</literal>. When the last honest politician is corrupted, <literal>Hope</literal> is automatically retracted by the truth maintenance system (highlighted in blue). The green highlighted area shows the origin of the currently selected blue highlighted area. After the <literal>Hope</literal> fact is retracted, the rule <literal>"Hope is dead"</literal> fires, printing <literal>"We are all Doomed!!! Democracy is Dead"</literal>.</simpara>
</section>
<section xml:id="decision-examples-sudoku-ref_decision-engine">
<title>Sudoku example decisions (complex pattern matching, callbacks, and GUI integration)</title>
<simpara>The Sudoku example decision set, based on the popular number puzzle Sudoku, demonstrates how to use rules in Red Hat Decision Manager to find a solution in a large potential solution space based on various constraints. This example also shows how to integrate Red Hat Decision Manager rules into a graphical user interface (GUI), in this case a Swing-based desktop application, and how to use callbacks to interact with a running decision engine to update the GUI based on changes in the working memory at run time.</simpara>
<simpara>The following is an overview of the Sudoku example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>sudoku</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.sudoku.SudokuExample</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.sudoku.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates complex pattern matching, problem solving, callbacks, and GUI integration</simpara>
</listitem>
</itemizedlist>
<simpara>Sudoku is a logic-based number placement puzzle. The objective is to fill a 9x9 grid so that each column, each row, and each of the nine 3x3 zones contains the digits from 1 to 9 only one time. The puzzle setter provides a partially completed grid and the puzzle solver’s task is to complete the grid with these constraints.</simpara>
<simpara>The general strategy to solve the problem is to ensure that when you insert a new number, it must be unique in its particular 3x3 zone, row, and column. This Sudoku example decision set uses Red Hat Decision Manager rules to solve Sudoku puzzles from a range of difficulty levels, and to attempt to resolve flawed puzzles that contain invalid entries.</simpara>
<bridgehead xml:id="sudoku_example_execution_and_interaction_2" renderas="sect3" remap="_sudoku_example_execution_and_interaction_2">Sudoku example execution and interaction</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Sudoku example by running the <literal>org.drools.examples.sudoku.SudokuExample</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Sudoku example, the <literal>Drools Sudoku Example</literal> GUI window appears. This window contains an empty grid, but the program comes with various grids stored internally that you can load and solve.</simpara>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Samples</emphasis> → <emphasis role="strong">Simple</emphasis> to load one of the examples. Notice that all buttons are disabled until a grid is loaded.</simpara>
<figure>
<title>Sudoku example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku1.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku1</phrase></textobject>
</mediaobject>
</figure>
<simpara>When you load the <emphasis role="strong">Simple</emphasis> example, the grid is filled according to the puzzle’s initial state.</simpara>
<figure>
<title>Sudoku example GUI after loading Simple sample</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku2.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku2</phrase></textobject>
</mediaobject>
</figure>
<simpara>Choose from the following options:</simpara>
<itemizedlist>
<listitem>
<simpara>Click <emphasis role="strong">Solve</emphasis> to fire the rules defined in the Sudoku example that fill out the remaining values and that make the buttons inactive again.</simpara>
<figure>
<title>Simple sample solved</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku3.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku3</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Step</emphasis> to see the next digit found by the rule set. The console window in your IDE displays detailed information about the rules that are executing to solve the step.</simpara>
<formalpara>
<title>Step execution output in the IDE console</title>
<para>
<screen>single 8 at [0,1]
column elimination due to [1,2]: remove 9 from [4,2]
hidden single 9 at [1,2]
row elimination due to [2,8]: remove 7 from [2,4]
remove 6 from [3,8] due to naked pair at [3,2] and [3,7]
hidden pair in row at [4,6] and [4,4]</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Dump</emphasis> to see the state of the grid, with cells showing either the established value or the remaining possibilities.</simpara>
<formalpara>
<title>Dump execution output in the IDE console</title>
<para>
<screen>        Col: 0     Col: 1     Col: 2     Col: 3     Col: 4     Col: 5     Col: 6     Col: 7     Col: 8
Row 0:  123456789  --- 5 ---  --- 6 ---  --- 8 ---  123456789  --- 1 ---  --- 9 ---  --- 4 ---  123456789
Row 1:  --- 9 ---  123456789  123456789  --- 6 ---  123456789  --- 5 ---  123456789  123456789  --- 3 ---
Row 2:  --- 7 ---  123456789  123456789  --- 4 ---  --- 9 ---  --- 3 ---  123456789  123456789  --- 8 ---
Row 3:  --- 8 ---  --- 9 ---  --- 7 ---  123456789  --- 4 ---  123456789  --- 6 ---  --- 3 ---  --- 5 ---
Row 4:  123456789  123456789  --- 3 ---  --- 9 ---  123456789  --- 6 ---  --- 8 ---  123456789  123456789
Row 5:  --- 4 ---  --- 6 ---  --- 5 ---  123456789  --- 8 ---  123456789  --- 2 ---  --- 9 ---  --- 1 ---
Row 6:  --- 5 ---  123456789  123456789  --- 2 ---  --- 6 ---  --- 9 ---  123456789  123456789  --- 7 ---
Row 7:  --- 6 ---  123456789  123456789  --- 5 ---  123456789  --- 4 ---  123456789  123456789  --- 9 ---
Row 8:  123456789  --- 4 ---  --- 9 ---  --- 7 ---  123456789  --- 8 ---  --- 3 ---  --- 5 ---  123456789</screen>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>The Sudoku example includes a deliberately broken sample file that the rules defined in the example can resolve.</simpara>
<simpara>Click <emphasis role="strong">File</emphasis> → <emphasis role="strong">Samples</emphasis> → <emphasis role="strong">!DELIBERATELY BROKEN!</emphasis> to load the broken sample. The grid starts with some issues, for example, the value <literal>5</literal> appears two times in the first row, which is not allowed.</simpara>
<figure>
<title>Broken Sudoku example initial state</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku4.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku4</phrase></textobject>
</mediaobject>
</figure>
<simpara>Click <emphasis role="strong">Solve</emphasis> to apply the solving rules to this invalid grid. The associated solving rules in the Sudoku example detect the issues in the sample and attempts to solve the puzzle as far as possible. This process does not complete and leaves some cells empty.</simpara>
<simpara>The solving rule activity is displayed in the IDE console window:</simpara>
<formalpara>
<title>Detected issues in the broken sample</title>
<para>
<screen>cell [0,8]: 5 has a duplicate in row 0
cell [0,0]: 5 has a duplicate in row 0
cell [6,0]: 8 has a duplicate in col 0
cell [4,0]: 8 has a duplicate in col 0
Validation complete.</screen>
</para>
</formalpara>
<figure>
<title>Broken sample solution attempt</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/SudokuExample/sudoku5.png" align="center"/>
</imageobject>
<textobject><phrase>sudoku5</phrase></textobject>
</mediaobject>
</figure>
<simpara>The sample Sudoku files labeled <emphasis role="strong">Hard</emphasis> are more complex and the solving rules might not be able to solve them. The unsuccessful solution attempt is displayed in the IDE console window:</simpara>
<formalpara>
<title>Hard sample unresolved</title>
<para>
<screen>Validation complete.
...
Sorry - can't solve this grid.</screen>
</para>
</formalpara>
<simpara>The rules that work to solve the broken sample implement standard solving techniques based on the sets of values that are still candidates for a cell. For example, if a set contains a single value, then this is the value for the cell. For a single occurrence of a value in one of the groups of nine cells, the rules insert a fact of type <literal>Setting</literal> with the solution value for some specific cell. This fact causes the elimination of this value from all other cells in any of the groups the cell belongs to and the value is retracted.</simpara>
<simpara>Other rules in the example reduce the permissible values for some cells. The rules <literal>"naked pair"</literal>, <literal>"hidden pair in row"</literal>, <literal>"hidden pair in column"</literal>, and <literal>"hidden pair in square"</literal> eliminate possibilities but do not establish solutions. The rules <literal>"X-wings in rows"</literal>, "`X-wings in columns"`, <literal>"intersection removal row"</literal>, and <literal>"intersection removal column"</literal> perform more sophisticated eliminations.</simpara>
<bridgehead xml:id="sudoku_example_classes_2" renderas="sect3" remap="_sudoku_example_classes_2">Sudoku example classes</bridgehead>
<simpara>The package <literal>org.drools.examples.sudoku.swing</literal> contains the following core set of classes that implement a framework for Sudoku puzzles:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>SudokuGridModel</literal> class defines an interface that is implemented to store a Sudoku puzzle as a 9x9 grid of <literal>Cell</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridView</literal> class is a Swing component that can visualize any implementation of the <literal>SudokuGridModel</literal> class.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridEvent</literal> and <literal>SudokuGridListener</literal> classes communicate state changes between the model and the view. Events are fired when a cell value is resolved or changed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>SudokuGridSamples</literal> class provides partially filled Sudoku puzzles for demonstration purposes.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This package does not have any dependencies on Red Hat Decision Manager libraries.</simpara>
</note>
<simpara>The package <literal>org.drools.examples.sudoku</literal> contains the following core set of classes that implement the elementary <literal>Cell</literal> object and its various aggregations:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>CellFile</literal> class, with subtypes <literal>CellRow</literal>, <literal>CellCol</literal>, and <literal>CellSqr</literal>, all of which are subtypes of the <literal>CellGroup</literal> class.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Cell</literal> and <literal>CellGroup</literal> subclasses of <literal>SetOfNine</literal>, which provides a property <literal>free</literal> with the type <literal>Set&lt;Integer&gt;</literal>. For a <literal>Cell</literal> class, the set represents the individual candidate set. For a <literal>CellGroup</literal> class, the set is the union of all candidate sets of its cells (the set of digits that still need to be allocated).</simpara>
<simpara>In the Sudoku example are 81 <literal>Cell</literal> and 27 <literal>CellGroup</literal> objects and a linkage provided by the <literal>Cell</literal> properties <literal>cellRow</literal>, <literal>cellCol</literal>, and <literal>cellSqr</literal>, and by the <literal>CellGroup</literal> property <literal>cells</literal> (a list of <literal>Cell</literal> objects). With these components, you can write rules that detect the specific situations that permit the allocation of a value to a cell or the elimination of a value from some candidate set.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Setting</literal> class is used to trigger the operations that accompany the allocation of a value. The presence of a <literal>Setting</literal> fact is used in all rules that detect a new situation in order to avoid reactions to inconsistent intermediary states.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Stepping</literal> class is used in a low priority rule to execute an emergency halt when a <literal>"Step"</literal> does not terminate regularly. This behavior indicates that the program cannot solve the puzzle.</simpara>
</listitem>
<listitem>
<simpara>The main class <literal>org.drools.examples.sudoku.SudokuExample</literal> implements a Java application combining all of these components.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="sudoku_validation_rules_validate_drl_2" renderas="sect3" remap="_sudoku_validation_rules_validate_drl_2">Sudoku validation rules (validate.drl)</bridgehead>
<simpara>The <literal>validate.drl</literal> file in the Sudoku example contains validation rules that detect duplicate numbers in cell groups. They are combined in a <literal>"validate"</literal> agenda group that enables the rules to be explicitly activated after a user loads the puzzle.</simpara>
<simpara>The <literal>when</literal> conditions of the three rules <literal>"duplicate in cell …​"</literal> all function in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>The first condition in the rule locates a cell with an allocated value.</simpara>
</listitem>
<listitem>
<simpara>The second condition in the rule pulls in any of the three cell groups to which the cell belongs.</simpara>
</listitem>
<listitem>
<simpara>The final condition finds a cell (other than the first one) with the same value as the first cell and in the same row, column, or square, depending on the rule.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Rules "duplicate in cell …​"</title>
<para>
<screen>rule "duplicate in cell row"
  when
    $c: Cell( $v: value != null )
    $cr: CellRow( cells contains $c )
    exists Cell( this != $c, value == $v, cellRow == $cr )
  then
    System.out.println( "cell " + $c.toString() + " has a duplicate in row " + $cr.getNumber() );
end

rule "duplicate in cell col"
  when
    $c: Cell( $v: value != null )
    $cc: CellCol( cells contains $c )
    exists Cell( this != $c, value == $v, cellCol == $cc )
  then
    System.out.println( "cell " + $c.toString() + " has a duplicate in col " + $cc.getNumber() );
end

rule "duplicate in cell sqr"
  when
    $c: Cell( $v: value != null )
    $cs: CellSqr( cells contains $c )
    exists Cell( this != $c, value == $v, cellSqr == $cs )
  then
    System.out.println( "cell " + $c.toString() + " has duplicate in its square of nine." );
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"terminate group"</literal> is the last to fire. This rule prints a message and stops the sequence.</simpara>
<formalpara>
<title>Rule "terminate group"</title>
<para>
<screen>rule "terminate group"
    salience -100
  when
  then
    System.out.println( "Validation complete." );
    drools.halt();
end</screen>
</para>
</formalpara>
<bridgehead xml:id="sudoku_solving_rules_sudoku_drl_2" renderas="sect3" remap="_sudoku_solving_rules_sudoku_drl_2">Sudoku solving rules (sudoku.drl)</bridgehead>
<simpara>The <literal>sudoku.drl</literal> file in the Sudoku example contains three types of rules: one group handles the allocation of a number to a cell, another group detects feasible allocations, and the third group eliminates values from candidate sets.</simpara>
<simpara>The rules  <literal>"set a value"</literal>, <literal>"eliminate a value from Cell"</literal>, and <literal>"retract setting"</literal> depend on the presence of a <literal>Setting</literal> object. The first rule handles the assignment to the cell and the operations for removing the value from the <literal>free</literal> sets of the three groups of the cell. This group also reduces a counter that, when zero, returns control to the Java application that has called <literal>fireUntilHalt()</literal>.</simpara>
<simpara>The purpose of the rule <literal>"eliminate a value from Cell"</literal> is to reduce the candidate lists of all cells that are related to the newly assigned cell. Finally, when all eliminations have been made, the rule <literal>"retract setting"</literal> retracts the triggering <literal>Setting</literal> fact.</simpara>
<formalpara>
<title>Rules "set a value", "eliminate a value from a Cell", and "retract setting"</title>
<para>
<screen>// A Setting object is inserted to define the value of a Cell.
// Rule for updating the cell and all cell groups that contain it
rule "set a value"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // A matching Cell, with no value set
    $c: Cell( rowNo == $rn, colNo == $cn, value == null,
              $cr: cellRow, $cc: cellCol, $cs: cellSqr )

    // Count down
    $ctr: Counter( $count: count )
  then
    // Modify the Cell by setting its value.
    modify( $c ){ setValue( $v ) }
    // System.out.println( "set cell " + $c.toString() );
    modify( $cr ){ blockValue( $v ) }
    modify( $cc ){ blockValue( $v ) }
    modify( $cs ){ blockValue( $v ) }
    modify( $ctr ){ setCount( $count - 1 ) }
end

// Rule for removing a value from all cells that are siblings
// in one of the three cell groups
rule "eliminate a value from Cell"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // The matching Cell, with the value already set
    Cell( rowNo == $rn, colNo == $cn, value == $v, $exCells: exCells )

    // For all Cells that are associated with the updated cell
    $c: Cell( free contains $v ) from $exCells
  then
    // System.out.println( "clear " + $v + " from cell " + $c.posAsString()  );
    // Modify a related Cell by blocking the assigned value.
    modify( $c ){ blockValue( $v ) }
end

// Rule for eliminating the Setting fact
rule "retract setting"
  when
    // A Setting with row and column number, and a value
    $s: Setting( $rn: rowNo, $cn: colNo, $v: value )

    // The matching Cell, with the value already set
    $c: Cell( rowNo == $rn, colNo == $cn, value == $v )

    // This is the negation of the last pattern in the previous rule.
    // Now the Setting fact can be safely retracted.
    not( $x: Cell( free contains $v )
         and
         Cell( this == $c, exCells contains $x ) )
  then
    // System.out.println( "done setting cell " + $c.toString() );
    // Discard the Setter fact.
    delete( $s );
    // Sudoku.sudoku.consistencyCheck();
end</screen>
</para>
</formalpara>
<simpara>Two solving rules detect a situation where an allocation of a number to a cell is possible. The rule <literal>"single"</literal> fires for a <literal>Cell</literal> with a candidate set containing a single number. The rule <literal>"hidden single"</literal> fires when no cell exists with a single candidate, but when a cell exists containing a candidate, this candidate is absent from all other cells in one of the three groups to which the cell belongs. Both rules create and insert a <literal>Setting</literal> fact.</simpara>
<formalpara>
<title>Rules "single" and "hidden single"</title>
<para>
<screen>// Detect a set of candidate values with cardinality 1 for some Cell.
// This is the value to be set.
rule "single"
  when
    // Currently no setting underway
    not Setting()

    // One element in the "free" set
    $c: Cell( $rn: rowNo, $cn: colNo, freeCount == 1 )
  then
    Integer i = $c.getFreeValue();
    if (explain) System.out.println( "single " + i + " at " + $c.posAsString() );
    // Insert another Setter fact.
    insert( new Setting( $rn, $cn, i ) );
end

// Detect a set of candidate values with a value that is the only one
// in one of its groups. This is the value to be set.
rule "hidden single"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // Some integer
    $i: Integer()

    // The "free" set contains this number
    $c: Cell( $rn: rowNo, $cn: colNo, freeCount &gt; 1, free contains $i )

    // A cell group contains this cell $c.
    $cg: CellGroup( cells contains $c )
    // No other cell from that group contains $i.
    not ( Cell( this != $c, free contains $i ) from $cg.getCells() )
  then
    if (explain) System.out.println( "hidden single " + $i + " at " + $c.posAsString() );
    // Insert another Setter fact.
    insert( new Setting( $rn, $cn, $i ) );
end</screen>
</para>
</formalpara>
<simpara>Rules from the largest group, either individually or in groups of two or three, implement various solving techniques used for solving Sudoku puzzles manually.</simpara>
<simpara>The rule <literal>"naked pair"</literal> detects identical candidate sets of size <literal>2</literal> in two cells of a group. These two values may be removed from all other candidate sets of that group.</simpara>
<formalpara>
<title>Rule "naked pair"</title>
<para>
<screen>// A "naked pair" is two cells in some cell group with their sets of
// permissible values being equal with cardinality 2. These two values
// can be removed from all other candidate lists in the group.
rule "naked pair"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // One cell with two candidates
    $c1: Cell( freeCount == 2, $f1: free, $r1: cellRow, $rn1: rowNo, $cn1: colNo, $b1: cellSqr )

    // The containing cell group
    $cg: CellGroup( freeCount &gt; 2, cells contains $c1 )

    // Another cell with two candidates, not the one we already have
    $c2: Cell( this != $c1, free == $f1 /*** , rowNo &gt;= $rn1, colNo &gt;= $cn1 ***/ ) from $cg.cells

    // Get one of the "naked pair".
    Integer( $v: intValue ) from $c1.getFree()

    // Get some other cell with a candidate equal to one from the pair.
    $c3: Cell( this != $c1 &amp;&amp; != $c2, freeCount &gt; 1, free contains $v ) from $cg.cells
  then
    if (explain) System.out.println( "remove " + $v + " from " + $c3.posAsString() + " due to naked pair at " + $c1.posAsString() + " and " + $c2.posAsString() );
    // Remove the value.
    modify( $c3 ){ blockValue( $v ) }
end</screen>
</para>
</formalpara>
<simpara>The three rules <literal>"hidden pair in …​"</literal> functions similarly to the rule <literal>"naked pair"</literal>. These rules detect a subset of two numbers in exactly two cells of a group, with neither value occurring in any of the other cells of the group. This means that all other candidates can be eliminated from the two cells harboring the hidden pair.</simpara>
<formalpara>
<title>Rules "hidden pair in …​"</title>
<para>
<screen>// If two cells within the same cell group contain candidate sets with more than
// two values, with two values being in both of them but in none of the other
// cells, then we have a "hidden pair". We can remove all other candidates from
// these two cells.
rule "hidden pair in row"
  when
    // Currently no setting underway
    not Setting()
    not Cell( freeCount == 1 )

    // Establish a pair of Integer facts.
    $i1: Integer()
    $i2: Integer( this &gt; $i1 )

    // Look for a Cell with these two among its candidates. (The upper bound on
    // the number of candidates avoids a lot of useless work during startup.)
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2, $cellRow: cellRow )

    // Get another one from the same row, with the same pair among its candidates.
    $c2: Cell( this != $c1, cellRow == $cellRow, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )

    // Ascertain that no other cell in the group has one of these two values.
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellRow.getCells() )
  then
    if( explain) System.out.println( "hidden pair in row at " + $c1.posAsString() + " and " + $c2.posAsString() );
    // Set the candidate lists of these two Cells to the "hidden pair".
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end

rule "hidden pair in column"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i1: Integer()
    $i2: Integer( this &gt; $i1 )
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2, $cellCol: cellCol )
    $c2: Cell( this != $c1, cellCol == $cellCol, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellCol.getCells() )
  then
    if (explain) System.out.println( "hidden pair in column at " + $c1.posAsString() + " and " + $c2.posAsString() );
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end

rule "hidden pair in square"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i1: Integer()
    $i2: Integer( this &gt; $i1 )
    $c1: Cell( $rn1: rowNo, $cn1: colNo, freeCount &gt; 2 &amp;&amp; &lt; 9, free contains $i1 &amp;&amp; contains $i2,
               $cellSqr: cellSqr )
    $c2: Cell( this != $c1, cellSqr == $cellSqr, freeCount &gt; 2, free contains $i1 &amp;&amp; contains $i2 )
    not( Cell( this != $c1 &amp;&amp; != $c2, free contains $i1 || contains $i2 ) from $cellSqr.getCells() )
  then
    if (explain) System.out.println( "hidden pair in square " + $c1.posAsString() + " and " + $c2.posAsString() );
    modify( $c1 ){ blockExcept( $i1, $i2 ) }
    modify( $c2 ){ blockExcept( $i1, $i2 ) }
end</screen>
</para>
</formalpara>
<simpara>Two rules deal with <literal>"X-wings"</literal> in rows and columns. When only two possible cells for a value exist in each of two different rows (or columns) and these candidates lie also in the same columns (or rows), then all other candidates for this value in the columns (or rows) can be eliminated. When you follow the pattern sequence in one of these rules, notice how the conditions that are conveniently expressed by words such as <literal>same</literal> or <literal>only</literal> result in patterns with suitable constraints or that are prefixed with <literal>not</literal>.</simpara>
<formalpara>
<title>Rules "X-wings in …​"</title>
<para>
<screen>rule "X-wings in rows"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    $ca1: Cell( freeCount &gt; 1, free contains $i,
                $ra: cellRow, $rano: rowNo,         $c1: cellCol,        $c1no: colNo )
    $cb1: Cell( freeCount &gt; 1, free contains $i,
                $rb: cellRow, $rbno: rowNo &gt; $rano,      cellCol == $c1 )
    not( Cell( this != $ca1 &amp;&amp; != $cb1, free contains $i ) from $c1.getCells() )

    $ca2: Cell( freeCount &gt; 1, free contains $i,
                cellRow == $ra, $c2: cellCol,       $c2no: colNo &gt; $c1no )
    $cb2: Cell( freeCount &gt; 1, free contains $i,
                cellRow == $rb,      cellCol == $c2 )
    not( Cell( this != $ca2 &amp;&amp; != $cb2, free contains $i ) from $c2.getCells() )

    $cx: Cell( rowNo == $rano || == $rbno, colNo != $c1no &amp;&amp; != $c2no,
               freeCount &gt; 1, free contains $i )
  then
    if (explain) {
        System.out.println( "X-wing with " + $i + " in rows " +
            $ca1.posAsString() + " - " + $cb1.posAsString() +
            $ca2.posAsString() + " - " + $cb2.posAsString() + ", remove from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end

rule "X-wings in columns"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    $ca1: Cell( freeCount &gt; 1, free contains $i,
                $c1: cellCol, $c1no: colNo,         $ra: cellRow,        $rano: rowNo )
    $ca2: Cell( freeCount &gt; 1, free contains $i,
                $c2: cellCol, $c2no: colNo &gt; $c1no,      cellRow == $ra )
    not( Cell( this != $ca1 &amp;&amp; != $ca2, free contains $i ) from $ra.getCells() )

    $cb1: Cell( freeCount &gt; 1, free contains $i,
                cellCol == $c1, $rb: cellRow,  $rbno: rowNo &gt; $rano )
    $cb2: Cell( freeCount &gt; 1, free contains $i,
                cellCol == $c2,      cellRow == $rb )
    not( Cell( this != $cb1 &amp;&amp; != $cb2, free contains $i ) from $rb.getCells() )

    $cx: Cell( colNo == $c1no || == $c2no, rowNo != $rano &amp;&amp; != $rbno,
               freeCount &gt; 1, free contains $i )
  then
    if (explain) {
        System.out.println( "X-wing with " + $i + " in columns " +
            $ca1.posAsString() + " - " + $ca2.posAsString() +
            $cb1.posAsString() + " - " + $cb2.posAsString() + ", remove from " + $cx.posAsString()  );
    }
    modify( $cx ){ blockValue( $i ) }
end</screen>
</para>
</formalpara>
<simpara>The two rules <literal>"intersection removal …​"</literal> are based on the restricted occurrence of some number within one square, either in a single row or in a single column. This means that this number must be in one of those two or three cells of the row or column and can be removed from the candidate sets of all other cells of the group. The pattern establishes the restricted occurrence and then fires for each cell outside of the square and within the same cell file.</simpara>
<formalpara>
<title>Rules "intersection removal …​"</title>
<para>
<screen>rule "intersection removal column"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    // Occurs in a Cell
    $c: Cell( free contains $i, $cs: cellSqr, $cc: cellCol )
    // Does not occur in another cell of the same square and a different column
    not Cell( this != $c, free contains $i, cellSqr == $cs, cellCol != $cc )

    // A cell exists in the same column and another square containing this value.
    $cx: Cell( freeCount &gt; 1, free contains $i, cellCol == $cc, cellSqr != $cs )
  then
    // Remove the value from that other cell.
    if (explain) {
        System.out.println( "column elimination due to " + $c.posAsString() +
                            ": remove " + $i + " from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end

rule "intersection removal row"
  when
    not Setting()
    not Cell( freeCount == 1 )

    $i: Integer()
    // Occurs in a Cell
    $c: Cell( free contains $i, $cs: cellSqr, $cr: cellRow )
    // Does not occur in another cell of the same square and a different row.
    not Cell( this != $c, free contains $i, cellSqr == $cs, cellRow != $cr )

    // A cell exists in the same row and another square containing this value.
    $cx: Cell( freeCount &gt; 1, free contains $i, cellRow == $cr, cellSqr != $cs )
  then
    // Remove the value from that other cell.
    if (explain) {
        System.out.println( "row elimination due to " + $c.posAsString() +
                            ": remove " + $i + " from " + $cx.posAsString() );
    }
    modify( $cx ){ blockValue( $i ) }
end</screen>
</para>
</formalpara>
<simpara>These rules are sufficient for many but not all Sudoku puzzles. To solve very difficult grids, the rule set requires more complex rules. (Ultimately, some puzzles can be solved only by trial and error.)</simpara>
</section>
<section xml:id="decision-examples-conway-ref_decision-engine">
<title>Conway’s Game of Life example decisions (ruleflow groups and GUI integration)</title>
<simpara>The Conway’s Game of Life example decision set, based on the famous cellular automaton by John Conway, demonstrates how to use ruleflow groups in rules to control rule execution. The example also demonstrates how to integrate Red Hat Decision Manager rules with a graphical user interface (GUI), in this case a Swing-based implementation of Conway’s Game of Life.</simpara>
<simpara>The following is an overview of the Conway’s Game of Life (Conway) example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>conway</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main classes</emphasis>: <literal>org.drools.examples.conway.ConwayRuleFlowGroupRun</literal>, <literal>org.drools.examples.conway.ConwayAgendaGroupRun</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>droolsjbpm-integration-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule files</emphasis>: <literal>org.drools.examples.conway.*.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates ruleflow groups and GUI integration</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Conway’s Game of Life example is separate from most of the other example decision sets in Red Hat Decision Manager and is located in
<literal>~/rhdm-7.10.0-sources/src/droolsjbpm-integration-$VERSION/droolsjbpm-integration-examples</literal> of the <emphasis role="strong">Red Hat Decision Manager 7.10.0 Source Distribution</emphasis> from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Red Hat Customer Portal</link>.</simpara>
</note>
<simpara>In Conway’s Game of Life, a user interacts with the game by creating an initial configuration or an advanced pattern with defined properties and then observing how the initial state evolves. The objective of the game is to show the development of a population, generation by generation. Each generation results from the preceding one, based on the simultaneous evaluation of all cells.</simpara>
<simpara>The following basic rules govern what the next generation looks like:</simpara>
<itemizedlist>
<listitem>
<simpara>If a live cell has fewer than two live neighbors, it dies of loneliness.</simpara>
</listitem>
<listitem>
<simpara>If a live cell has more than three live neighbors, it dies from overcrowding.</simpara>
</listitem>
<listitem>
<simpara>If a dead cell has exactly three live neighbors, it comes to life.</simpara>
</listitem>
</itemizedlist>
<simpara>Any cell that does not meet any of those criteria is left as is for the next generation.</simpara>
<simpara>The Conway’s Game of Life example uses Red Hat Decision Manager rules with <literal>ruleflow-group</literal> attributes to define the pattern implemented in the game. The example also contains a version of the decision set that achieves the same behavior using agenda groups. Agenda groups enable you to partition the decision engine agenda to provide execution control over groups of rules. By default, all rules are in the agenda group <literal>MAIN</literal>. You can use the <literal>agenda-group</literal> attribute to specify a different agenda group for the rule.</simpara>
<simpara>This overview does not explore the version of the Conway example using agenda groups. For more information about agenda groups, see the Red Hat Decision Manager example decision sets that specifically address agenda groups.</simpara>
<bridgehead xml:id="conway_example_execution_and_interaction_2" renderas="sect3" remap="_conway_example_execution_and_interaction_2">Conway example execution and interaction</bridgehead>
<simpara>Similar to other Red Hat Decision Manager decision examples, you execute the Conway ruleflow example by running the <literal>org.drools.examples.conway.ConwayRuleFlowGroupRun</literal> class as a Java application in your IDE.</simpara>
<simpara>When you execute the Conway example, the <literal>Conway’s Game of Life</literal> GUI window appears. This window contains an empty grid, or "arena" where the life simulation takes place. Initially the grid is empty because no live cells are in the system yet.</simpara>
<figure>
<title>Conway example GUI after launch</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway1.png" align="center"/>
</imageobject>
<textobject><phrase>conway1</phrase></textobject>
</mediaobject>
</figure>
<simpara>Select a predefined pattern from the <emphasis role="strong">Pattern</emphasis> drop-down menu and click <emphasis role="strong">Next Generation</emphasis> to click through each population generation. Each cell is either alive or dead, where live cells contain a green ball. As the population evolves from the initial pattern, cells live or die relative to neighboring cells, according to the rules of the game.</simpara>
<figure>
<title>Generation evolution in Conway example</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway2.png" align="center"/>
</imageobject>
<textobject><phrase>conway2</phrase></textobject>
</mediaobject>
</figure>
<simpara>Neighbors include not only cells to the left, right, top, and bottom but also cells that are connected diagonally, so that each cell has a total of eight neighbors. Exceptions are the corner cells, which have only three neighbors, and the cells along the four borders, with five neighbors each.</simpara>
<simpara>You can manually intervene to create or kill cells by clicking the cell.</simpara>
<simpara>To run through an evolution automatically from the initial pattern, click <emphasis role="strong">Start</emphasis>.</simpara>
<bridgehead xml:id="conway_example_rules_with_ruleflow_groups_2" renderas="sect3" remap="_conway_example_rules_with_ruleflow_groups_2">Conway example rules with ruleflow groups</bridgehead>
<simpara>The rules in the <literal>ConwayRuleFlowGroupRun</literal> example use ruleflow groups to control rule execution. A ruleflow group is a group of rules associated by the <literal>ruleflow-group</literal> rule attribute. These rules can only fire when the group is activated. The group itself can only become active when the elaboration of the ruleflow diagram reaches the node representing the group.</simpara>
<simpara>The Conway example uses the following ruleflow groups for rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>"register neighbor"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"evaluate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"calculate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"reset calculate"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"birth"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"kill"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"kill all"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>All of the <literal>Cell</literal> objects are inserted into the KIE session and the <literal>"register …​"</literal> rules in the ruleflow group <literal>"register neighbor"</literal> are allowed to execute by the ruleflow process. This group of four rules creates <literal>Neighbor</literal> relations between some cell and its northeastern, northern, northwestern, and western neighbors.</simpara>
<simpara>This relation is bidirectional and handles the other four directions. Border cells do not require any special treatment. These cells are not paired with neighboring cells where there is not any.</simpara>
<simpara>By the time all activations have fired for these rules, all cells are related to all their neighboring cells.</simpara>
<formalpara>
<title>Rules "register …​"</title>
<para>
<screen>rule "register north east"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $northEast : Cell( row  == ($row - 1), col == ( $col + 1 ) )
  then
    insert( new Neighbor( $cell, $northEast ) );
    insert( new Neighbor( $northEast, $cell ) );
end

rule "register north"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $north : Cell( row  == ($row - 1), col == $col )
  then
    insert( new Neighbor( $cell, $north ) );
    insert( new Neighbor( $north, $cell ) );
end

rule "register north west"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $northWest : Cell( row  == ($row - 1), col == ( $col - 1 ) )
  then
    insert( new Neighbor( $cell, $northWest ) );
    insert( new Neighbor( $northWest, $cell ) );
end

rule "register west"
    ruleflow-group "register neighbor"
  when
    $cell: Cell( $row : row, $col : col )
    $west : Cell( row  == $row, col == ( $col - 1 ) )
  then
    insert( new Neighbor( $cell, $west ) );
    insert( new Neighbor( $west, $cell ) );
end</screen>
</para>
</formalpara>
<simpara>After all the cells are inserted, some Java code applies the pattern to the grid, setting certain cells to <literal>Live</literal>. Then, when the user clicks <emphasis role="strong">Start</emphasis> or <emphasis role="strong">Next Generation</emphasis>, the example executes the <literal>Generation</literal> ruleflow. This ruleflow manages all changes of cells in each generation cycle.</simpara>
<figure>
<title>Generation ruleflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/ConwaysGameOfLifeExample/conway_ruleflow_generation.png" align="center"/>
</imageobject>
<textobject><phrase>conway ruleflow generation</phrase></textobject>
</mediaobject>
</figure>
<simpara>The ruleflow process enters the <literal>"evaluate"</literal> ruleflow group and any active rules in the group can fire. The rules <literal>"Kill the …​"</literal> and <literal>"Give Birth"</literal> in this group apply the game rules to birth or kill cells. The example uses the <literal>phase</literal> attribute to drive the reasoning of the <literal>Cell</literal> object by specific groups of rules. Typically, the phase is tied to a ruleflow group in the ruleflow process definition.</simpara>
<simpara>Notice that the example does not change the state of any <literal>Cell</literal> objects at this point because it must complete the full evaluation before those changes can be applied. The example sets the cell to a <literal>phase</literal> that is either <literal>Phase.KILL</literal> or <literal>Phase.BIRTH</literal>, which is used later to control actions applied to the <literal>Cell</literal> object.</simpara>
<formalpara>
<title>Rules "Kill the …​" and "Give Birth"</title>
<para>
<screen>rule "Kill The Lonely"
    ruleflow-group "evaluate"
    no-loop
  when
    // A live cell has fewer than 2 live neighbors.
    theCell: Cell( liveNeighbors &lt; 2, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Kill The Overcrowded"
    ruleflow-group "evaluate"
    no-loop
  when
    // A live cell has more than 3 live neighbors.
    theCell: Cell( liveNeighbors &gt; 3, cellState == CellState.LIVE,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        setPhase( Phase.KILL );
    }
end

rule "Give Birth"
    ruleflow-group "evaluate"
    no-loop
  when
    // A dead cell has 3 live neighbors.
    theCell: Cell( liveNeighbors == 3, cellState == CellState.DEAD,
                   phase == Phase.EVALUATE )
  then
    modify( theCell ){
        theCell.setPhase( Phase.BIRTH );
    }
end</screen>
</para>
</formalpara>
<simpara>After all <literal>Cell</literal> objects in the grid have been evaluated, the example uses the <literal>"reset calculate"</literal> rule to clear any activations in the <literal>"calculate"</literal> ruleflow group. The example then enters a split in the ruleflow that enables the rules <literal>"kill"</literal> and <literal>"birth"</literal> to fire, if the ruleflow group is activated. These rules apply the state change.</simpara>
<formalpara>
<title>Rules "reset calculate", "kill", and "birth"</title>
<para>
<screen>rule "reset calculate"
    ruleflow-group "reset calculate"
  when
  then
    WorkingMemory wm = drools.getWorkingMemory();
    wm.clearRuleFlowGroup( "calculate" );
end

rule "kill"
    ruleflow-group "kill"
    no-loop
  when
    theCell: Cell( phase == Phase.KILL )
  then
    modify( theCell ){
        setCellState( CellState.DEAD ),
        setPhase( Phase.DONE );
    }
end

rule "birth"
    ruleflow-group "birth"
    no-loop
  when
    theCell: Cell( phase == Phase.BIRTH )
  then
    modify( theCell ){
        setCellState( CellState.LIVE ),
        setPhase( Phase.DONE );
    }
end</screen>
</para>
</formalpara>
<simpara>At this stage, several <literal>Cell</literal> objects have been modified with the state changed to either <literal>LIVE</literal> or <literal>DEAD</literal>. When a cell becomes live or dead, the example uses the <literal>Neighbor</literal> relation in the rules <literal>"Calculate …​"</literal> to iterate over all surrounding cells, increasing or decreasing the <literal>liveNeighbor</literal> count. Any cell that has its count changed is also set to the <literal>EVALUATE</literal> phase to make sure it is included in the reasoning during the evaluation stage of the ruleflow process.</simpara>
<simpara>After the live count has been determined and set for all cells, the ruleflow process ends. If the user initially clicked <emphasis role="strong">Start</emphasis>, the decision engine restarts the ruleflow at that point. If the user initially clicked <emphasis role="strong">Next Generation</emphasis>, the user can request another generation.</simpara>
<formalpara>
<title>Rules "Calculate …​"</title>
<para>
<screen>rule "Calculate Live"
    ruleflow-group "calculate"
    lock-on-active
  when
    theCell: Cell( cellState == CellState.LIVE )
    Neighbor( cell == theCell, $neighbor : neighbor )
  then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() + 1 ),
        setPhase( Phase.EVALUATE );
    }
end

rule "Calculate Dead"
    ruleflow-group "calculate"
    lock-on-active
  when
    theCell: Cell( cellState == CellState.DEAD )
    Neighbor( cell == theCell, $neighbor : neighbor )
  then
    modify( $neighbor ){
        setLiveNeighbors( $neighbor.getLiveNeighbors() - 1 ),
        setPhase( Phase.EVALUATE );
    }
end</screen>
</para>
</formalpara>
</section>
<section xml:id="decision-examples-doom-ref_decision-engine">
<title>House of Doom example decisions (backward chaining and recursion)</title>
<simpara>The House of Doom example decision set demonstrates how the decision engine uses backward chaining and recursion to reach defined goals or subgoals in a hierarchical system.</simpara>
<simpara>The following is an overview of the House of Doom example:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Name</emphasis>: <literal>backwardchaining</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Main class</emphasis>: <literal>org.drools.examples.backwardchaining.HouseOfDoomMain</literal> (in <literal>src/main/java</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Module</emphasis>: <literal>drools-examples</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: Java application</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rule file</emphasis>: <literal>org.drools.examples.backwardchaining.BC-Example.drl</literal> (in <literal>src/main/resources</literal>)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Objective</emphasis>: Demonstrates backward chaining and recursion</simpara>
</listitem>
</itemizedlist>
<simpara>A backward-chaining rule system is a goal-driven system that starts with a conclusion that the decision engine attempts to satisfy, often using recursion. If the system cannot reach the conclusion or goal, it searches for subgoals, which are conclusions that complete part of the current goal. The system continues this process until either the initial conclusion is satisfied or all subgoals are satisfied.</simpara>
<simpara>In contrast, a forward-chaining rule system is a data-driven system that starts with a fact in the working memory of the decision engine and reacts to changes to that fact. When objects are inserted into working memory, any rule conditions that become true as a result of the change are scheduled for execution by the agenda.</simpara>
<simpara>The decision engine in Red Hat Decision Manager uses both forward and backward chaining to evaluate rules.</simpara>
<simpara>The following diagram illustrates how the decision engine evaluates rules using forward chaining overall with a backward-chaining segment in the logic flow:</simpara>
<figure>
<title>Rule evaluation logic using forward and backward chaining</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/RuleEvaluation_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>RuleEvaluation Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>The House of Doom example uses rules with various types of queries to find the location of rooms and items within the house. The sample class <literal>Location.java</literal> contains the <literal>item</literal> and <literal>location</literal> elements used in the example. The sample class <literal>HouseOfDoomMain.java</literal> inserts the items or rooms in their respective locations in the house and executes the rules.</simpara>
<formalpara>
<title>Items and locations in HouseOfDoomMain.java class</title>
<para>
<programlisting language="java" linenumbering="unnumbered">ksession.insert( new Location("Office", "House") );
ksession.insert( new Location("Kitchen", "House") );
ksession.insert( new Location("Knife", "Kitchen") );
ksession.insert( new Location("Cheese", "Kitchen") );
ksession.insert( new Location("Desk", "Office") );
ksession.insert( new Location("Chair", "Office") );
ksession.insert( new Location("Computer", "Desk") );
ksession.insert( new Location("Drawer", "Desk") );</programlisting>
</para>
</formalpara>
<simpara>The example rules rely on backward chaining and recursion to determine the location of all items and rooms in the house structure.</simpara>
<simpara>The following diagram illustrates the structure of the House of Doom and the items and rooms within it:</simpara>
<figure>
<title>House of Doom structure</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/_images/Examples/BackwardChaining/TransitiveReasoning_Enterprise.png" align="center"/>
</imageobject>
<textobject><phrase>TransitiveReasoning Enterprise</phrase></textobject>
</mediaobject>
</figure>
<simpara>To execute the example, run the <literal>org.drools.examples.backwardchaining.HouseOfDoomMain</literal> class as a Java application in your IDE.</simpara>
<simpara>After the execution, the following output appears in the IDE console window:</simpara>
<formalpara>
<title>Execution output in the IDE console</title>
<para>
<screen>go1
Office is in the House
---
go2
Drawer is in the House
---
go3
---
Key is in the Office
---
go4
Chair is in the Office
Desk is in the Office
Key is in the Office
Computer is in the Office
Drawer is in the Office
---
go5
Chair is in Office
Desk is in Office
Drawer is in Desk
Key is in Drawer
Kitchen is in House
Cheese is in Kitchen
Knife is in Kitchen
Computer is in Desk
Office is in House
Key is in Office
Drawer is in House
Computer is in House
Key is in House
Desk is in House
Chair is in House
Knife is in House
Cheese is in House
Computer is in Office
Drawer is in Office
Key is in Desk</screen>
</para>
</formalpara>
<simpara>All rules in the example have fired to detect the location of all items in the house and to print the location of each in the output.</simpara>
<bridgehead xml:id="recursive_query_and_related_rules_2" renderas="sect3" remap="_recursive_query_and_related_rules_2">Recursive query and related rules</bridgehead>
<simpara>A recursive query repeatedly searches through the hierarchy of a data structure for relationships between elements.</simpara>
<simpara>In the House of Doom example, the <literal>BC-Example.drl</literal> file contains an <literal>isContainedIn</literal> query that most of the rules in the example use to recursively evaluate the house data structure for data inserted into the decision engine:</simpara>
<formalpara>
<title>Recursive query in BC-Example.drl</title>
<para>
<screen>query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end</screen>
</para>
</formalpara>
<simpara>The rule <literal>"go"</literal> prints every string inserted into the system to determine how items are implemented, and the rule <literal>"go1"</literal> calls the query <literal>isContainedIn</literal>:</simpara>
<formalpara>
<title>Rules "go" and "go1"</title>
<para>
<screen>rule "go" salience 10
  when
    $s : String()
  then
    System.out.println( $s );
end

rule "go1"
  when
    String( this == "go1" )
    isContainedIn("Office", "House"; )
  then
    System.out.println( "Office is in the House" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go1"</literal> string into the decision engine and activates the <literal>"go1"</literal> rule to detect that item <literal>Office</literal> is in the location <literal>House</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go1" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go1" output in the IDE console</title>
<para>
<screen>go1
Office is in the House</screen>
</para>
</formalpara>
<bridgehead xml:id="transitive_closure_rule_2" renderas="sect3" remap="_transitive_closure_rule_2">Transitive closure rule</bridgehead>
<simpara>Transitive closure is a relationship between an element contained in a parent element that is multiple levels higher in a hierarchical structure.</simpara>
<simpara>The rule <literal>"go2"</literal> identifies the transitive closure relationship of the <literal>Drawer</literal> and the <literal>House</literal>: The <literal>Drawer</literal> is in the <literal>Desk</literal> in the <literal>Office</literal> in the <literal>House</literal>.</simpara>
<screen>rule "go2"
  when
    String( this == "go2" )
    isContainedIn("Drawer", "House"; )
  then
    System.out.println( "Drawer is in the House" );
end</screen>
<simpara>The example inserts the <literal>"go2"</literal> string into the decision engine and activates the <literal>"go2"</literal> rule to detect that item <literal>Drawer</literal> is ultimately within the location <literal>House</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go2" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go2" output in the IDE console</title>
<para>
<screen>go2
Drawer is in the House</screen>
</para>
</formalpara>
<simpara>The decision engine determines this outcome based on the following logic:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The query recursively searches through several levels in the house to detect the transitive closure between <literal>Drawer</literal> and <literal>House</literal>.</simpara>
</listitem>
<listitem>
<simpara>Instead of using <literal>Location( x, y; )</literal>, the query uses the value of <literal>(z, y; )</literal> because <literal>Drawer</literal> is not directly in <literal>House</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>z</literal> argument is currently unbound, which means it has no value and returns everything that is in the argument.</simpara>
</listitem>
<listitem>
<simpara>The <literal>y</literal> argument is currently bound to <literal>House</literal>, so <literal>z</literal> returns <literal>Office</literal> and <literal>Kitchen</literal>.</simpara>
</listitem>
<listitem>
<simpara>The query gathers information from the <literal>Office</literal> and checks recursively if the <literal>Drawer</literal> is in the <literal>Office</literal>. The query line <literal>isContainedIn( x, z; )</literal> is called for these parameters.</simpara>
</listitem>
<listitem>
<simpara>No instance of <literal>Drawer</literal> exists directly in <literal>Office</literal>, so no match is found.</simpara>
</listitem>
<listitem>
<simpara>With <literal>z</literal> unbound, the query returns data within the <literal>Office</literal> and determines that <emphasis role="strong">z == Desk</emphasis>.</simpara>
<screen>isContainedIn(x==drawer, z==desk)</screen>
</listitem>
<listitem>
<simpara>The <literal>isContainedIn</literal> query recursively searches three times, and on the third time, the query detects an instance of <literal>Drawer</literal> in <literal>Desk</literal>.</simpara>
<screen>Location(x==drawer, y==desk)</screen>
</listitem>
<listitem>
<simpara>After this match on the first location, the query recursively searches back up the structure to determine that the <literal>Drawer</literal> is in the <literal>Desk</literal>, the <literal>Desk</literal> is in the <literal>Office</literal>, and the <literal>Office</literal> is in the <literal>House</literal>. Therefore, the <literal>Drawer</literal> is in the <literal>House</literal> and the rule is satisfied.</simpara>
</listitem>
</orderedlist>
<bridgehead xml:id="reactive_query_rule_2" renderas="sect3" remap="_reactive_query_rule_2">Reactive query rule</bridgehead>
<simpara>A reactive query searches through the hierarchy of a data structure for relationships between elements and is dynamically updated when elements in the structure are modified.</simpara>
<simpara>The rule <literal>"go3"</literal> functions as a reactive query that detects if a new item <literal>Key</literal> ever becomes present in the <literal>Office</literal> by transitive closure: A <literal>Key</literal> in the <literal>Drawer</literal> in the <literal>Office</literal>.</simpara>
<formalpara>
<title>Rule "go3"</title>
<para>
<screen>rule "go3"
  when
    String( this == "go3" )
    isContainedIn("Key", "Office"; )
  then
    System.out.println( "Key is in the Office" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go3"</literal> string into the decision engine and activates the <literal>"go3"</literal> rule. Initially, this rule is not satisfied because no item <literal>Key</literal> exists in the house structure, so the rule produces no output.</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go3" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go3" output in the IDE console (unsatisfied)</title>
<para>
<screen>go3</screen>
</para>
</formalpara>
<simpara>The example then inserts a new item <literal>Key</literal> in the location <literal>Drawer</literal>, which is in <literal>Office</literal>. This change satisfies the transitive closure in the <literal>"go3"</literal> rule and the output is populated accordingly.</simpara>
<formalpara>
<title>Insert new item location and fire rules</title>
<para>
<screen>ksession.insert( new Location("Key", "Drawer") );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go3" output in the IDE console (satisfied)</title>
<para>
<screen>Key is in the Office</screen>
</para>
</formalpara>
<simpara>This change also adds another level in the structure that the query includes in subsequent recursive searches.</simpara>
<bridgehead xml:id="queries_with_unbound_arguments_in_rules_2" renderas="sect3" remap="_queries_with_unbound_arguments_in_rules_2">Queries with unbound arguments in rules</bridgehead>
<simpara>A query with one or more unbound arguments returns all undefined (unbound) items within a defined (bound) argument of the query. If all arguments in a query are unbound, then the query returns all items within the scope of the query.</simpara>
<simpara>The rule <literal>"go4"</literal> uses an unbound argument <literal>thing</literal> to search for all items within the bound argument <literal>Office</literal>, instead of using a bound argument to search for a specific item in the <literal>Office</literal>:</simpara>
<formalpara>
<title>Rule "go4"</title>
<para>
<screen>rule "go4"
  when
    String( this == "go4" )
    isContainedIn(thing, "Office"; )
  then
    System.out.println( thing + "is in the Office" );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go4"</literal> string into the decision engine and activates the <literal>"go4"</literal> rule to return all items in the <literal>Office</literal>:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go4" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go4" output in the IDE console</title>
<para>
<screen>go4
Chair is in the Office
Desk is in the Office
Key is in the Office
Computer is in the Office
Drawer is in the Office</screen>
</para>
</formalpara>
<simpara>The rule <literal>"go5"</literal> uses both unbound arguments <literal>thing</literal> and <literal>location</literal> to search for all items and their locations in the entire <literal>House</literal> data structure:</simpara>
<formalpara>
<title>Rule "go5"</title>
<para>
<screen>rule "go5"
  when
    String( this == "go5" )
    isContainedIn(thing, location; )
  then
    System.out.println(thing + " is in " + location );
end</screen>
</para>
</formalpara>
<simpara>The example inserts the <literal>"go5"</literal> string into the decision engine and activates the <literal>"go5"</literal> rule to return all items and their locations in the <literal>House</literal> data structure:</simpara>
<formalpara>
<title>Insert string and fire rules</title>
<para>
<screen>ksession.insert( "go5" );
ksession.fireAllRules();</screen>
</para>
</formalpara>
<formalpara>
<title>Rule "go5" output in the IDE console</title>
<para>
<screen>go5
Chair is in Office
Desk is in Office
Drawer is in Desk
Key is in Drawer
Kitchen is in House
Cheese is in Kitchen
Knife is in Kitchen
Computer is in Desk
Office is in House
Key is in Office
Drawer is in House
Computer is in House
Key is in House
Desk is in House
Chair is in House
Knife is in House
Cheese is in House
Computer is in Office
Drawer is in Office
Key is in Desk</screen>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="performance-tuning-decision-engine-ref_decision-engine">
<title>Performance tuning considerations with the decision engine</title>
<simpara>The following key concepts or suggested practices can help you optimize decision engine performance. These concepts are summarized in this section as a convenience and are explained in more detail in the cross-referenced documentation, where applicable. This section will expand or change as needed with new releases of Red Hat Decision Manager.</simpara>
<variablelist>
<varlistentry>
<term>Use sequential mode for stateless KIE sessions that do not require important decision engine updates</term>
<listitem>
<simpara>Sequential mode is an advanced rule base configuration in the decision engine that enables the decision engine to evaluate rules one time in the order that they are listed in the decision engine agenda without regard to changes in the working memory. As a result, rule execution may be faster in sequential mode, but important updates may not be applied to your rules. Sequential mode applies to stateless KIE sessions only.</simpara>
<simpara>To enable sequential mode, set the system property <literal>drools.sequential</literal> to <literal>true</literal>.</simpara>
<simpara>For more information about sequential mode or other options for enabling it, see <xref linkend="phreak-sequential-mode-con_decision-engine"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Use simple operations with event listeners</term>
<listitem>
<simpara>Limit the number of event listeners and the type of operations they perform. Use event listeners for simple operations, such as debug logging and setting properties. Complicated operations, such as network calls, in listeners can impede rule execution. After you finish working with a KIE session, remove the attached event listeners so that the session can be cleaned, as shown in the following example:</simpara>
<formalpara>
<title>Example event listener removed after use</title>
<para>
<programlisting language="java" linenumbering="unnumbered">Listener listener = ...;
StatelessKnowledgeSession ksession = createSession();
try {
    ksession.insert(fact);
    ksession.fireAllRules();
    ...
} finally {
    if (session != null) {
        ksession.detachListener(listener);
        ksession.dispose();
    }
}</programlisting>
</para>
</formalpara>
<simpara>For information about built-in event listeners and debug logging in the decision engine, see <xref linkend="engine-event-listeners-con_decision-engine"/>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Configure <literal>LambdaIntrospector</literal> cache size for an executable model build</term>
<listitem>
<simpara>You can configure the size of <literal>LambdaIntrospector.methodFingerprintsMap</literal> cache, which is used in an executable model build. The default size of the cache is <literal>32</literal>. When you configure smaller value for the cache size, it reduces memory usage. For example, you can configure system property <literal>drools.lambda.introspector.cache.size</literal> to <literal>0</literal> for minimum memory usage. Note that smaller cache size also slows down the build performance.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Use lambda externalization for executable model</term>
<listitem>
<simpara>Enable lambda externalization to optimize the memory consumption during runtime. It rewrites lambdas that are generated and used in the executable model. This enables you to reuse the same lambda multiple times with all the patterns and the same constraint. When the rete or phreak is instantiated, the executable model becomes garbage collectible.</simpara>
<simpara>To enable lambda externalization for the executable model, include the following property:</simpara>
<screen>-Ddrools.externaliseCanonicalModelLambda=true</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>Configure alpha node range index threshold</term>
<listitem>
<simpara>Alpha node range index is used to evaluate the rule constraint. You can configure the threshold of the alpha node range index using the <literal>drools.alphaNodeRangeIndexThreshold</literal> system property. The default value of the threshold is <literal>9</literal>, indicating that the alpha node range index is enabled when a precedent node contains more than nine alpha nodes with inequality constraints. For example, when you have nine rules similar to <literal>Person(age &gt; 10)</literal>, <literal>Person(age &gt; 20)</literal>, …​, <literal>Person(age &gt; 90)</literal>, then you can have similar nine alpha nodes.</simpara>
<simpara>The default value of the threshold is based on the related advantages and overhead. However, if you configure a smaller value for the threshold, then the performance can be improved depending on your rules. For example, you can configure the <literal>drools.alphaNodeRangeIndexThreshold</literal> value to <literal>6</literal>, enabling the alpha node range index when you have more than six alpha nodes for a precedent node. You can set a suitable value for the threshold based on the performance test results of your rules.</simpara>
</listitem>
</varlistentry>
</variablelist>
</chapter>
<chapter xml:id="additional_resources_3" remap="_additional_resources_3">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/designing_your_decision_management_architecture_for_red_hat_decision_manager"><emphasis>Designing your decision management architecture for Red Hat Decision Manager</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-drl-rules"><emphasis>Designing a decision service using DRL rules</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/deploying_and_managing_red_hat_decision_manager_services#assembly-packaging-deploying"><emphasis>Packaging and deploying a Red Hat Decision Manager project</emphasis></link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<part xml:id="assembly-ba-artificial-intelligence">
<title>Integrating machine learning with Red Hat Decision Manager</title>
<partintro>
<simpara>As a business analyst or business rules developer, you can integrate machine learning with Red Hat Decision Manager by using PMML files with Decision Model and Notation (DMN) models.</simpara>
</partintro>
<chapter xml:id="ai-con_artificial-intelligence">
<title>Pragmatic AI</title>
<simpara>When you think about artificial intelligence (AI), machine learning and big data might come to mind. But machine learning is only part of the picture. Artificial intelligence includes the following technologies:</simpara>
<itemizedlist>
<listitem>
<simpara>Robotics: The integration of technology, science, and engineering that produces machines that can perform physical tasks that are performed by humans</simpara>
</listitem>
<listitem>
<simpara>Machine learning: The ability of a collection of algorithms to learn or improve when exposed to data without being explicitly programmed to do so</simpara>
</listitem>
<listitem>
<simpara>Natural language processing: A subset of machine learning that processes human speech</simpara>
</listitem>
<listitem>
<simpara>Mathematical optimization: The use of conditions and constraints to find the optimal solution to a problem</simpara>
</listitem>
<listitem>
<simpara>Digital decisioning: The use of defined criteria, conditions, and a series of machine and human tasks to make decisions</simpara>
</listitem>
</itemizedlist>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/123_RHPAM_Integrating_AI_1020_building-blocks.svg"/>
</imageobject>
<textobject><phrase>123 RHPAM Integrating AI 1020 building blocks</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>While science fiction is filled with what is referred to as artificial general intelligence (AGI), machines that perform better than people and cannot be distinguished from them and learn and evolve without human intervention or control, AGI is decades away. Meanwhile, we have pragmatic AI which is much less frightening and much more useful to us today. Pragmatic AI is a collection of AI technologies that, when combined, provide solutions to problems such as predicting customer behavior, providing automated customer service, and helping customers make purchasing decisions.</simpara>
<simpara>Leading industry analysts report that previously organizations have struggled with AI technologies because they invested in the potential of AI rather than the reality of what AI can deliver today. AI projects were not productive and as a result investment in AI slowed and budgets for AI projects were reduced. This disillusionment with AI is often referred to as an AI winter. AI has experienced several cycles of AI winters followed by AI springs and we are now decidedly in an AI spring. Organizations are seeing the practical reality of what AI can deliver. Being pragmatic means being practical and realistic.  A pragmatic approach to AI considers AI technologies that are available today, combines them where useful, and adds human intervention when needed to create solutions to real-world problems.</simpara>
<formalpara>
<title>Pragmatic AI solution example</title>
<para>One application of pragmatic AI is in customer support. A customer files a support ticket that reports a problem, for example, a login error. A machine learning algorithm is applied to the ticket to match the ticket content with existing solutions, based on keywords or natural language processing (NLP). The keywords might appear in many solutions, some relevant and some not as relevant. You can use digital decisioning to determine which solutions to present to the customer. However, sometimes none of the solutions proposed by the algorithm are appropriate to propose to the customer. This can be because all solutions have a low confidence score or multiple solutions have a high confidence score. In cases where an appropriate solution cannot be found, the digital decisioning can involve the human support team. To find the best support person based on availability and expertise, mathematical optimization selects the best assignee for the support ticket by considering employee rostering constraints.</para>
</formalpara>
<simpara>As this example shows, you can combine machine learning to extract information from data analysis and digital decisioning to model the human knowledge and experience. You can then apply mathematical optimization to schedule human assistance. This is a pattern that you can apply to other situations, for example, a credit card dispute and credit card fraud detection.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/123_RHPAM_Integrating_AI_1020_equation.svg"/>
</imageobject>
<textobject><phrase>123 RHPAM Integrating AI 1020 equation</phrase></textobject>
</inlinemediaobject>
These technologies use four industry standards:</simpara>
<itemizedlist>
<listitem>
<simpara>Case Management Model and Notation (CMMN)</simpara>
<simpara>CMMN is used to model work methods that include various activities that might be performed in an unpredictable order depending on circumstances. CMMN models are event centered. CMMN overcomes limitations of what can be modeled with BPMN2 by supporting less structured work tasks and tasks driven by humans. By combining BPMN and CMMN you can create much more powerful models.</simpara>
</listitem>
<listitem>
<simpara>Business Process Model and Notation (BPMN2)</simpara>
<simpara>The BPMN2 specification is an Object Management Group (OMG) specification that defines standards for graphically representing a business process, defines execution semantics for the elements, and provides process definitions in XML format. BPMN2 can model computer and human tasks.</simpara>
</listitem>
<listitem>
<simpara>Decision Model and Notation (DMN)</simpara>
<simpara>Decision Model and Notation (DMN) is a standard established by the OMG for describing and modeling operational decisions. DMN defines an XML schema that enables DMN models to be shared between DMN-compliant platforms and across organizations so that business analysts and business rules developers can collaborate in designing and implementing DMN decision services. The DMN standard is similar to and can be used together with the Business Process Model and Notation (BPMN) standard for designing and modeling business processes.</simpara>
</listitem>
<listitem>
<simpara>Predictive Model Markup Language (PMML)</simpara>
<simpara>PMML is the language used to represent predictive models, mathematical models that use statistical techniques to uncover, or learn, patterns in large volumes of data. Predictive models use the patterns that they learn to predict the existence of patterns in new data. With PMML, you can share predictive models between applications. This data is exported as a PMML file that can be consumed by a DMN model. As a machine learning framework continues to train the model, the updated data can be saved to the existing PMML file. This means that you can use predictive models created by any application that can save the model as a PMML file. Therefore, DMN and PMML integrate well.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Putting it all together</title>
<para><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/123_RHPAM_Integrating_AI_1020_overview.svg"/>
</imageobject>
<textobject><phrase>123 RHPAM Integrating AI 1020 overview</phrase></textobject>
</inlinemediaobject></para>
</formalpara>
<simpara>This illustration shows how predictive decision automation works.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Business data enters the system, for example, data from a loan application.</simpara>
</listitem>
<listitem>
<simpara>A decision model that is integrated with a predictive model decides whether or not to approve the loan or whether additional tasks are required.</simpara>
</listitem>
<listitem>
<simpara>A business action results, for example, a rejection letter or loan offer is sent to the customer.</simpara>
</listitem>
</orderedlist>
<simpara>The next section demonstrates how predictive decision automation works with Red Hat Decision Manager.</simpara>
</chapter>
<chapter xml:id="ai-credit-card-con_artificial-intelligence">
<title>Credit card fraud dispute use case</title>
<simpara>The financial industry uses pragmatic AI for decisioning in several areas. One area is credit card charge disputes. When a customer identifies an incorrect or unrecognized charge on a credit card bill, the customer can dispute the charge.  Human intervention in credit card fraud detection is required in some cases but the majority of reported credit card fraud can be completely or partially resolved with pragmatic AI.</simpara>
<simpara>Machine learning models such as Tensorflow™ and R™ produce predictive models. You can save these predictive models in an open standard such as PMML so that you can use the model with Red Hat Decision Manager or other products that support the PMML standard.</simpara>
<section xml:id="ai-gsg_artificial-intelligence">
<title>Using a PMML model with a DMN model to resolve credit card transaction disputes</title>
<simpara>This example shows you how to use Red Hat Decision Manager to create a DMN model that uses a PMML model to resolve credit card transaction disputes. When a customer disputes a credit card transaction, the system decides whether or not to process the transaction automatically.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat Decision Manager is available and the following JAR file has been added to the <literal>~/kie-server.war/WEB-INF/lib</literal> and <literal>~/business-central.war/WEB-INF/lib</literal> directories in your Red Hat Decision Manager installation:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kie-dmn-jpmml-7.48.0.Final-redhat-00002.jar</literal></simpara>
<simpara>This file is available in the Red Hat Decision Manager 7.10 Maven Repository distribution available from the <link xlink:href="https://access.redhat.com/jbossnetwork/restricted/listSoftware.html">Software Downloads</link> page in the Red Hat Customer Portal (login required). The group ID, artifact ID, and version (GAV) identifier of this file is <literal>org.kie:kie-dmn-jpmml:7.48.0.Final-redhat-00002</literal>. For more information, see the "Including PMML models within a DMN file in Business Central" section of <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://mvnrepository.com/artifact/org.jpmml/pmml-evaluator/1.5.1">JPMML Evaluator 1.5.1 JAR file</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://mvnrepository.com/artifact/org.jpmml/pmml-evaluator-extension/1.5.1">JPMML Evaluator Extensions 1.5.1 JAR file</link></simpara>
<simpara>These files are required to enable JPMML evaluation in KIE Server and Business Central.</simpara>
<important>
<simpara>Red Hat supports integration with the Java Evaluator API for PMML (JPMML) for PMML execution in Red Hat Decision Manager. However, Red Hat does not support the JPMML libraries directly. If you include JPMML libraries in your Red Hat Decision Manager distribution, see the <link xlink:href="https://openscoring.io/">Openscoring.io</link> licensing terms for JPMML.</simpara>
</important>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>dtree_risk_predictor.pmml</literal> file with the contents of the XML example in <xref linkend="ai-pmml-ref_artificial-intelligence"/>.</simpara>
</listitem>
<listitem>
<simpara>In Business Central, create the <emphasis role="strong">Credit Card Dispute</emphasis> project:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Menu → Design → Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> box, enter <literal>Credit Card Dispute</literal> and click <emphasis role="strong">Add</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Assets</emphasis> window of the <emphasis role="strong">Credit Card Dispute</emphasis> project, import the <literal>dtree_risk_predictor.pmml</literal> file into the <literal>com</literal> package:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/import-pmml.png"/>
</imageobject>
<textobject><phrase>import pmml</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Import Asset</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Create new Import Asset</emphasis> dialog, enter <literal>dtree_risk_predictor</literal> in the <emphasis role="strong">Name</emphasis> box, select <emphasis role="strong">com</emphasis> from the <emphasis role="strong">Package</emphasis> menu, select the <literal>dtree_risk_predictor.pmml</literal> file, and click <emphasis role="strong">OK</emphasis>.</simpara>
<simpara>The content of the <literal>dtree_risk_predictor.pmml</literal> file appears in the <emphasis role="strong">Overview</emphasis> window.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Dispute Transaction Check</emphasis> DMN model in <emphasis role="strong">com</emphasis> package:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/dmn-asset.png"/>
</imageobject>
<textobject><phrase>dmn asset</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To return to the project window, click <emphasis role="strong">Credit Card Dispute</emphasis> in the breadcrumb trail.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">DMN</emphasis> in the asset library.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Create new DMN</emphasis> dialog, enter enter <literal>Dispute Transaction Check</literal> in the <emphasis role="strong">Name</emphasis> box, select <emphasis role="strong">com</emphasis> from the <emphasis role="strong">Package</emphasis> menu, and click <emphasis role="strong">OK</emphasis>.</simpara>
<simpara>The DMN editor opens with the <emphasis role="strong">Dispute Transaction Check</emphasis> DMN model.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">tTransaction</emphasis> custom data type:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/ttransactions.png"/>
</imageobject>
<textobject><phrase>ttransactions</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Data Types</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add a custom Data Type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> box, enter <literal>tTransaction</literal>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Structure</emphasis> from the <emphasis role="strong">Type</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>To create the data type, click the check mark.</simpara>
<simpara>The <emphasis role="strong">tTransaction</emphasis> custom data type appears with one variable row.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> field of the variable row, enter <literal>transaction_amount</literal>, select <emphasis role="strong">Number</emphasis> from the <emphasis role="strong">Type</emphasis> menu, and then click the check mark.</simpara>
</listitem>
<listitem>
<simpara>To add a new variable row, click the plus symbol on the <literal>transaction_amount</literal> row. A new row appears.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> field, enter <literal>cardholder_identifier</literal>, select <emphasis role="strong">Number</emphasis> from the <emphasis role="strong">Type</emphasis> menu, and then click the check mark.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add the <emphasis role="strong">Risk Predictor</emphasis> <literal>dtree_risk_predictor.pmml</literal> model:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/include-model.png"/>
</imageobject>
<textobject><phrase>include model</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Included Models</emphasis> window of the DMN editor, click <emphasis role="strong">Include Model</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Include Model</emphasis> dialog, select <literal>dtree_risk_predictor.pmml</literal> from the <emphasis role="strong">Models</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>Risk Predictor</literal> in the <emphasis role="strong">Provide a unique name</emphasis> box and click <emphasis role="strong">OK</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Risk Predictor</emphasis> Business Knowledge Model (BKM) node with the <emphasis role="strong">Risk Predictor</emphasis> and <emphasis role="strong">DecisionTreeClassifier</emphasis> model:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/risk-predictor-function.png"/>
</imageobject>
<textobject><phrase>risk predictor function</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> window of the DMN editor, drag a BKM node to the DMN editor palette.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/bkm.png"/>
</imageobject>
<textobject><phrase>bkm</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>Rename the node <emphasis role="strong">Risk Predictor</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the edit icon located below the trash can icon on the left side of the node.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/risk-predictor-node.png"/>
</imageobject>
<textobject><phrase>risk predictor node</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">F</emphasis> in the <emphasis role="strong">Risk Predictor</emphasis> box and select <emphasis role="strong">PMML</emphasis> from the <emphasis role="strong">Select Function Kind</emphasis> menu. The <emphasis role="strong">F</emphasis> changes to <emphasis role="strong">P</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Double-click the <emphasis role="strong">First select PMML document</emphasis> box and select <emphasis role="strong">Risk Predictor</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Double-click the <emphasis role="strong">Second select PMML model</emphasis> box and select <emphasis role="strong">DecisionTreeClassifier</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To return to the DMN editor palette,  click <emphasis role="strong">Back to Dispute Transaction Check</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Transaction</emphasis> input data node with the data type <emphasis role="strong">tTransaction</emphasis>:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/risk-transaction.png"/>
</imageobject>
<textobject><phrase>risk transaction</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> window of the DMN editor, drag an input data node to the DMN editor palette.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/input-node.png"/>
</imageobject>
<textobject><phrase>input node</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>Rename the node <emphasis role="strong">Transaction</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the node then click the properties pencil icon in the upper-right corner of the window.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Properties</emphasis> panel, select <emphasis role="strong">Information Item → Data type → tTransaction</emphasis> then close the panel.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Transaction Dispute Risk</emphasis> decision node and add the <emphasis role="strong">Transaction</emphasis> node for data input and the <emphasis role="strong">Risk Predictor</emphasis> node for the function:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/model3.png"/>
</imageobject>
<textobject><phrase>model3</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> window of the DMN editor, drag a decision data node to the DMN editor palette.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/decision-node.png"/>
</imageobject>
<textobject><phrase>decision node</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>Rename the node <emphasis role="strong">Transaction Dispute Risk</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Risk Predictor</emphasis> node and drag the arrow from the top right of the node to the <emphasis role="strong">Transaction Dispute Risk</emphasis> node.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Transaction</emphasis> node and drag the arrow from the bottom right of the node to the <emphasis role="strong">Transaction Dispute Risk</emphasis> node.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Transaction Dispute Risk</emphasis> node, create the <emphasis role="strong">Risk predictor</emphasis> invocation function:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/transaction-dispute-risk.png"/>
</imageobject>
<textobject><phrase>transaction dispute risk</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the <emphasis role="strong">Transaction Dispute Risk</emphasis> node and click the edit icon on the left side of the node.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Select expression</emphasis> and select <emphasis role="strong">Invocation</emphasis> from the menu.</simpara>
</listitem>
<listitem>
<simpara>Enter <emphasis role="strong">Risk Predictor</emphasis> in the <emphasis role="strong">Enter function</emphasis> box.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">P1</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Edit Parameter</emphasis> dialog, enter <literal>amount</literal> in the <emphasis role="strong">Name</emphasis> box, select <emphasis role="strong">number</emphasis> from the <emphasis role="strong">Data Type</emphasis> menu, and press the Enter key.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Select expression</emphasis> and select <emphasis role="strong">Literal expression</emphasis> from the menu.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>Transaction.transaction_amount</literal> in the box next to <emphasis role="strong">amount</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Right-click on <emphasis role="strong">1</emphasis> and select <emphasis role="strong">Insert below</emphasis>. The <emphasis role="strong">Edit Parameter</emphasis> dialog opens.</simpara>
</listitem>
<listitem>
<simpara>Enter <emphasis role="strong">holder_index</emphasis> in the <emphasis role="strong">Name</emphasis> box, select <emphasis role="strong">number</emphasis> from the <emphasis role="strong">Data Type</emphasis> menu, and press the Enter key.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Select expression</emphasis> on row <emphasis role="strong">2</emphasis> and select <emphasis role="strong">Literal expression</emphasis> from the menu.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>Transaction.cardholder_identifier</literal> in the box next to <emphasis role="strong">amount</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Risk Threshold</emphasis> input data node with the data type <emphasis role="strong">number</emphasis>:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/model4.png"/>
</imageobject>
<textobject><phrase>model4</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Model</emphasis> window of the DMN editor, drag an input data node to the DMN editor palette.</simpara>
</listitem>
<listitem>
<simpara>Rename the node <emphasis role="strong">Risk Threshold</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the node then click the properties pencil icon in the upper-right corner of the window.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Properties</emphasis> panel, select <emphasis role="strong">Information Item → Data type → number</emphasis> then close the panel.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <emphasis role="strong">Can be automatically processed?</emphasis> decision node that takes as inputs the <emphasis role="strong">Transaction Dispute Risk</emphasis> and the <emphasis role="strong">Risk threshold</emphasis> nodes:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/model5.png"/>
</imageobject>
<textobject><phrase>model5</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Drag a decision node to the DMN editor palette and rename it <emphasis role="strong">Can be automatically processed?</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the node, then click the edit icon on the upper-left side of the node.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Select expression</emphasis> and then select <emphasis role="strong">Literal expression</emphasis> from the menu.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>Transaction Dispute Risk.predicted_dispute_risk &lt; Risk Threshold</literal> in the box.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Transaction Dispute Risk</emphasis> node and drag the arrow in the top left of the node to the <emphasis role="strong">Can be automatically processed?</emphasis> node.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Risk Threshold</emphasis> node and drag the arrow from the bottom left of the node to the <emphasis role="strong">Can be automatically processed?</emphasis> node.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Save the model and build the project:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the DMN editor, click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If necessary, correct any errors that appear.</simpara>
</listitem>
<listitem>
<simpara>To return to the project window, click <emphasis role="strong">Credit Card Dispute</emphasis> in the breadcrumb trail.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Build</emphasis>. The project should successfully build.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add and run a test scenario:
<inlinemediaobject>
<imageobject>
<imagedata fileref="images/_images/ai/AIScenarioSimulations.png"/>
</imageobject>
<textobject><phrase>AIScenarioSimulations</phrase></textobject>
</inlinemediaobject></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Add Asset</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Test Scenario</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Create new Test Scenario</emphasis> dialog, enter the name <literal>Test Dispute Transaction Check</literal>, select <emphasis role="strong">com</emphasis> from the <emphasis role="strong">Package</emphasis> menu, and select <emphasis role="strong">DMN</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Dispute Transaction Check.dmn</emphasis> from the <emphasis role="strong">Choose a DMN asset</emphasis> menu and click <emphasis role="strong">OK</emphasis>. The test template builds.</simpara>
</listitem>
<listitem>
<simpara>Enter the following values and click <emphasis role="strong">Save</emphasis>:</simpara>
<note>
<simpara>Do not add a value to the <emphasis role="strong">Transaction Dispute Risk</emphasis> column. This value is determined by the test scenario.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Test scenario parameters</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="13*"/>
<colspec colname="col_3" colwidth="24*"/>
<colspec colname="col_4" colwidth="24*"/>
<colspec colname="col_5" colwidth="19*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Risk Threshold</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">cardholder_identifier</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">transaction_amount</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Can be automatically processed?</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Risk threshold 5, automatically processed</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>1234</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Risk threshold 4, amount = 1000, not processed</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>1234</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Risk threshold 4, amount = 180, automatically processed</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>1234</simpara></entry>
<entry align="left" valign="top"><simpara>180</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Risk threshold 1, amount = 1, not processed</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1234</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</listitem>
<listitem>
<simpara>To run the test, click the <emphasis role="strong">Play</emphasis> button, to the right of <emphasis role="strong">Validate</emphasis>. The results appear in the <emphasis role="strong">Test Report</emphasis> panel on the right of the screen.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ai-pmml-ref_artificial-intelligence">
<title>Credit card transaction dispute exercise PMML file</title>
<simpara>Use the following XML content to create the <literal>dtree_risk_predictor.pmml</literal> file in the <xref linkend="ai-gsg_artificial-intelligence"/> exercise.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;PMML xmlns="http://www.dmg.org/PMML-4_2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="4.2" xsi:schemaLocation="http://www.dmg.org/PMML-4_2 http://www.dmg.org/v4-2-1/pmml-4-2.xsd"&gt;
  &lt;Header copyright="Copyright (c) 2018 Software AG" description="Default Description"&gt;
    &lt;Application name="Nyoka" version="4.3.0" /&gt;
    &lt;Timestamp&gt;2020-10-09 14:27:26.622723&lt;/Timestamp&gt;
  &lt;/Header&gt;
  &lt;DataDictionary numberOfFields="3"&gt;
    &lt;DataField name="amount" optype="continuous" dataType="double" /&gt;
    &lt;DataField name="holder_index" optype="continuous" dataType="double" /&gt;
    &lt;DataField name="dispute_risk" optype="categorical" dataType="integer"&gt;
      &lt;Value value="1" /&gt;
      &lt;Value value="2" /&gt;
      &lt;Value value="3" /&gt;
      &lt;Value value="4" /&gt;
      &lt;Value value="5" /&gt;
    &lt;/DataField&gt;
  &lt;/DataDictionary&gt;
  &lt;TreeModel modelName="DecisionTreeClassifier" functionName="classification" missingValuePenalty="1.0"&gt;
    &lt;MiningSchema&gt;
      &lt;MiningField name="amount" usageType="active" optype="continuous" /&gt;
      &lt;MiningField name="holder_index" usageType="active" optype="continuous" /&gt;
      &lt;MiningField name="dispute_risk" usageType="target" optype="categorical" /&gt;
    &lt;/MiningSchema&gt;
    &lt;Output&gt;
      &lt;OutputField name="probability_1" optype="continuous" dataType="double" feature="probability" value="1" /&gt;
      &lt;OutputField name="probability_2" optype="continuous" dataType="double" feature="probability" value="2" /&gt;
      &lt;OutputField name="probability_3" optype="continuous" dataType="double" feature="probability" value="3" /&gt;
      &lt;OutputField name="probability_4" optype="continuous" dataType="double" feature="probability" value="4" /&gt;
      &lt;OutputField name="probability_5" optype="continuous" dataType="double" feature="probability" value="5" /&gt;
      &lt;OutputField name="predicted_dispute_risk" optype="categorical" dataType="integer" feature="predictedValue" /&gt;
    &lt;/Output&gt;
    &lt;Node id="0" recordCount="600.0"&gt;
      &lt;True /&gt;
      &lt;Node id="1" recordCount="200.0"&gt;
        &lt;SimplePredicate field="amount" operator="lessOrEqual" value="99.94000244140625" /&gt;
        &lt;Node id="2" score="2" recordCount="55.0"&gt;
          &lt;SimplePredicate field="holder_index" operator="lessOrEqual" value="0.5" /&gt;
          &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="2" recordCount="55.0" confidence="1.0" /&gt;
          &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
        &lt;/Node&gt;
        &lt;Node id="3" score="1" recordCount="145.0"&gt;
          &lt;SimplePredicate field="holder_index" operator="greaterThan" value="0.5" /&gt;
          &lt;ScoreDistribution value="1" recordCount="145.0" confidence="1.0" /&gt;
          &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
        &lt;/Node&gt;
      &lt;/Node&gt;
      &lt;Node id="4" recordCount="400.0"&gt;
        &lt;SimplePredicate field="amount" operator="greaterThan" value="99.94000244140625" /&gt;
        &lt;Node id="5" recordCount="105.0"&gt;
          &lt;SimplePredicate field="holder_index" operator="lessOrEqual" value="0.5" /&gt;
          &lt;Node id="6" score="3" recordCount="54.0"&gt;
            &lt;SimplePredicate field="amount" operator="lessOrEqual" value="150.4550018310547" /&gt;
            &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="3" recordCount="54.0" confidence="1.0" /&gt;
            &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
          &lt;/Node&gt;
          &lt;Node id="7" recordCount="51.0"&gt;
            &lt;SimplePredicate field="amount" operator="greaterThan" value="150.4550018310547" /&gt;
            &lt;Node id="8" recordCount="40.0"&gt;
              &lt;SimplePredicate field="amount" operator="lessOrEqual" value="200.00499725341797" /&gt;
              &lt;Node id="9" recordCount="36.0"&gt;
                &lt;SimplePredicate field="amount" operator="lessOrEqual" value="195.4949951171875" /&gt;
                &lt;Node id="10" recordCount="2.0"&gt;
                  &lt;SimplePredicate field="amount" operator="lessOrEqual" value="152.2050018310547" /&gt;
                  &lt;Node id="11" score="4" recordCount="1.0"&gt;
                    &lt;SimplePredicate field="amount" operator="lessOrEqual" value="151.31500244140625" /&gt;
                    &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="4" recordCount="1.0" confidence="1.0" /&gt;
                    &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;/Node&gt;
                  &lt;Node id="12" score="3" recordCount="1.0"&gt;
                    &lt;SimplePredicate field="amount" operator="greaterThan" value="151.31500244140625" /&gt;
                    &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="3" recordCount="1.0" confidence="1.0" /&gt;
                    &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;/Node&gt;
                &lt;/Node&gt;
                &lt;Node id="13" recordCount="34.0"&gt;
                  &lt;SimplePredicate field="amount" operator="greaterThan" value="152.2050018310547" /&gt;
                  &lt;Node id="14" recordCount="20.0"&gt;
                    &lt;SimplePredicate field="amount" operator="lessOrEqual" value="176.5050048828125" /&gt;
                    &lt;Node id="15" recordCount="19.0"&gt;
                      &lt;SimplePredicate field="amount" operator="lessOrEqual" value="176.06500244140625" /&gt;
                      &lt;Node id="16" score="4" recordCount="9.0"&gt;
                        &lt;SimplePredicate field="amount" operator="lessOrEqual" value="166.6449966430664" /&gt;
                        &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="4" recordCount="9.0" confidence="1.0" /&gt;
                        &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;/Node&gt;
                      &lt;Node id="17" recordCount="10.0"&gt;
                        &lt;SimplePredicate field="amount" operator="greaterThan" value="166.6449966430664" /&gt;
                        &lt;Node id="18" score="3" recordCount="1.0"&gt;
                          &lt;SimplePredicate field="amount" operator="lessOrEqual" value="167.97999572753906" /&gt;
                          &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="3" recordCount="1.0" confidence="1.0" /&gt;
                          &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;/Node&gt;
                        &lt;Node id="19" score="4" recordCount="9.0"&gt;
                          &lt;SimplePredicate field="amount" operator="greaterThan" value="167.97999572753906" /&gt;
                          &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="4" recordCount="9.0" confidence="1.0" /&gt;
                          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;/Node&gt;
                      &lt;/Node&gt;
                    &lt;/Node&gt;
                    &lt;Node id="20" score="3" recordCount="1.0"&gt;
                      &lt;SimplePredicate field="amount" operator="greaterThan" value="176.06500244140625" /&gt;
                      &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="3" recordCount="1.0" confidence="1.0" /&gt;
                      &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;/Node&gt;
                  &lt;/Node&gt;
                  &lt;Node id="21" score="4" recordCount="14.0"&gt;
                    &lt;SimplePredicate field="amount" operator="greaterThan" value="176.5050048828125" /&gt;
                    &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="4" recordCount="14.0" confidence="1.0" /&gt;
                    &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;/Node&gt;
                &lt;/Node&gt;
              &lt;/Node&gt;
              &lt;Node id="22" recordCount="4.0"&gt;
                &lt;SimplePredicate field="amount" operator="greaterThan" value="195.4949951171875" /&gt;
                &lt;Node id="23" score="3" recordCount="1.0"&gt;
                  &lt;SimplePredicate field="amount" operator="lessOrEqual" value="195.76499938964844" /&gt;
                  &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="3" recordCount="1.0" confidence="1.0" /&gt;
                  &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                &lt;/Node&gt;
                &lt;Node id="24" recordCount="3.0"&gt;
                  &lt;SimplePredicate field="amount" operator="greaterThan" value="195.76499938964844" /&gt;
                  &lt;Node id="25" score="4" recordCount="1.0"&gt;
                    &lt;SimplePredicate field="amount" operator="lessOrEqual" value="196.74500274658203" /&gt;
                    &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="4" recordCount="1.0" confidence="1.0" /&gt;
                    &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;/Node&gt;
                  &lt;Node id="26" recordCount="2.0"&gt;
                    &lt;SimplePredicate field="amount" operator="greaterThan" value="196.74500274658203" /&gt;
                    &lt;Node id="27" score="3" recordCount="1.0"&gt;
                      &lt;SimplePredicate field="amount" operator="lessOrEqual" value="197.5800018310547" /&gt;
                      &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="3" recordCount="1.0" confidence="1.0" /&gt;
                      &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;/Node&gt;
                    &lt;Node id="28" score="4" recordCount="1.0"&gt;
                      &lt;SimplePredicate field="amount" operator="greaterThan" value="197.5800018310547" /&gt;
                      &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;ScoreDistribution value="4" recordCount="1.0" confidence="1.0" /&gt;
                      &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;/Node&gt;
                  &lt;/Node&gt;
                &lt;/Node&gt;
              &lt;/Node&gt;
            &lt;/Node&gt;
            &lt;Node id="29" score="5" recordCount="11.0"&gt;
              &lt;SimplePredicate field="amount" operator="greaterThan" value="200.00499725341797" /&gt;
              &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
              &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
              &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
              &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
              &lt;ScoreDistribution value="5" recordCount="11.0" confidence="1.0" /&gt;
            &lt;/Node&gt;
          &lt;/Node&gt;
        &lt;/Node&gt;
        &lt;Node id="30" recordCount="295.0"&gt;
          &lt;SimplePredicate field="holder_index" operator="greaterThan" value="0.5" /&gt;
          &lt;Node id="31" score="2" recordCount="170.0"&gt;
            &lt;SimplePredicate field="amount" operator="lessOrEqual" value="150.93499755859375" /&gt;
            &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="2" recordCount="170.0" confidence="1.0" /&gt;
            &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
            &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
          &lt;/Node&gt;
          &lt;Node id="32" recordCount="125.0"&gt;
            &lt;SimplePredicate field="amount" operator="greaterThan" value="150.93499755859375" /&gt;
            &lt;Node id="33" recordCount="80.0"&gt;
              &lt;SimplePredicate field="holder_index" operator="lessOrEqual" value="2.5" /&gt;
              &lt;Node id="34" recordCount="66.0"&gt;
                &lt;SimplePredicate field="amount" operator="lessOrEqual" value="199.13500213623047" /&gt;
                &lt;Node id="35" score="3" recordCount="10.0"&gt;
                  &lt;SimplePredicate field="amount" operator="lessOrEqual" value="155.56999969482422" /&gt;
                  &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="3" recordCount="10.0" confidence="1.0" /&gt;
                  &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                &lt;/Node&gt;
                &lt;Node id="36" recordCount="56.0"&gt;
                  &lt;SimplePredicate field="amount" operator="greaterThan" value="155.56999969482422" /&gt;
                  &lt;Node id="37" score="2" recordCount="1.0"&gt;
                    &lt;SimplePredicate field="amount" operator="lessOrEqual" value="155.9000015258789" /&gt;
                    &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                    &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                    &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;/Node&gt;
                  &lt;Node id="38" recordCount="55.0"&gt;
                    &lt;SimplePredicate field="amount" operator="greaterThan" value="155.9000015258789" /&gt;
                    &lt;Node id="39" recordCount="31.0"&gt;
                      &lt;SimplePredicate field="amount" operator="lessOrEqual" value="176.3699951171875" /&gt;
                      &lt;Node id="40" recordCount="30.0"&gt;
                        &lt;SimplePredicate field="amount" operator="lessOrEqual" value="175.72000122070312" /&gt;
                        &lt;Node id="41" recordCount="19.0"&gt;
                          &lt;SimplePredicate field="amount" operator="lessOrEqual" value="168.06999969482422" /&gt;
                          &lt;Node id="42" recordCount="6.0"&gt;
                            &lt;SimplePredicate field="amount" operator="lessOrEqual" value="158.125" /&gt;
                            &lt;Node id="43" score="3" recordCount="5.0"&gt;
                              &lt;SimplePredicate field="amount" operator="lessOrEqual" value="157.85499572753906" /&gt;
                              &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="3" recordCount="5.0" confidence="1.0" /&gt;
                              &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;/Node&gt;
                            &lt;Node id="44" score="2" recordCount="1.0"&gt;
                              &lt;SimplePredicate field="amount" operator="greaterThan" value="157.85499572753906" /&gt;
                              &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                              &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;/Node&gt;
                          &lt;/Node&gt;
                          &lt;Node id="45" score="3" recordCount="13.0"&gt;
                            &lt;SimplePredicate field="amount" operator="greaterThan" value="158.125" /&gt;
                            &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="3" recordCount="13.0" confidence="1.0" /&gt;
                            &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;/Node&gt;
                        &lt;/Node&gt;
                        &lt;Node id="46" recordCount="11.0"&gt;
                          &lt;SimplePredicate field="amount" operator="greaterThan" value="168.06999969482422" /&gt;
                          &lt;Node id="47" score="2" recordCount="1.0"&gt;
                            &lt;SimplePredicate field="amount" operator="lessOrEqual" value="168.69499969482422" /&gt;
                            &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                            &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;/Node&gt;
                          &lt;Node id="48" recordCount="10.0"&gt;
                            &lt;SimplePredicate field="amount" operator="greaterThan" value="168.69499969482422" /&gt;
                            &lt;Node id="49" recordCount="4.0"&gt;
                              &lt;SimplePredicate field="holder_index" operator="lessOrEqual" value="1.5" /&gt;
                              &lt;Node id="50" score="2" recordCount="1.0"&gt;
                                &lt;SimplePredicate field="amount" operator="lessOrEqual" value="172.0250015258789" /&gt;
                                &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                                &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;/Node&gt;
                              &lt;Node id="51" score="3" recordCount="3.0"&gt;
                                &lt;SimplePredicate field="amount" operator="greaterThan" value="172.0250015258789" /&gt;
                                &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="3" recordCount="3.0" confidence="1.0" /&gt;
                                &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                                &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;/Node&gt;
                            &lt;/Node&gt;
                            &lt;Node id="52" score="3" recordCount="6.0"&gt;
                              &lt;SimplePredicate field="holder_index" operator="greaterThan" value="1.5" /&gt;
                              &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="3" recordCount="6.0" confidence="1.0" /&gt;
                              &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                              &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                            &lt;/Node&gt;
                          &lt;/Node&gt;
                        &lt;/Node&gt;
                      &lt;/Node&gt;
                      &lt;Node id="53" score="2" recordCount="1.0"&gt;
                        &lt;SimplePredicate field="amount" operator="greaterThan" value="175.72000122070312" /&gt;
                        &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                        &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;/Node&gt;
                    &lt;/Node&gt;
                    &lt;Node id="54" recordCount="24.0"&gt;
                      &lt;SimplePredicate field="amount" operator="greaterThan" value="176.3699951171875" /&gt;
                      &lt;Node id="55" score="3" recordCount="16.0"&gt;
                        &lt;SimplePredicate field="amount" operator="lessOrEqual" value="192.0999984741211" /&gt;
                        &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="3" recordCount="16.0" confidence="1.0" /&gt;
                        &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                      &lt;/Node&gt;
                      &lt;Node id="56" recordCount="8.0"&gt;
                        &lt;SimplePredicate field="amount" operator="greaterThan" value="192.0999984741211" /&gt;
                        &lt;Node id="57" score="2" recordCount="1.0"&gt;
                          &lt;SimplePredicate field="amount" operator="lessOrEqual" value="192.75499725341797" /&gt;
                          &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="2" recordCount="1.0" confidence="1.0" /&gt;
                          &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;/Node&gt;
                        &lt;Node id="58" score="3" recordCount="7.0"&gt;
                          &lt;SimplePredicate field="amount" operator="greaterThan" value="192.75499725341797" /&gt;
                          &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="3" recordCount="7.0" confidence="1.0" /&gt;
                          &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                          &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                        &lt;/Node&gt;
                      &lt;/Node&gt;
                    &lt;/Node&gt;
                  &lt;/Node&gt;
                &lt;/Node&gt;
              &lt;/Node&gt;
              &lt;Node id="59" recordCount="14.0"&gt;
                &lt;SimplePredicate field="amount" operator="greaterThan" value="199.13500213623047" /&gt;
                &lt;Node id="60" score="5" recordCount="10.0"&gt;
                  &lt;SimplePredicate field="holder_index" operator="lessOrEqual" value="1.5" /&gt;
                  &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="5" recordCount="10.0" confidence="1.0" /&gt;
                &lt;/Node&gt;
                &lt;Node id="61" score="4" recordCount="4.0"&gt;
                  &lt;SimplePredicate field="holder_index" operator="greaterThan" value="1.5" /&gt;
                  &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                  &lt;ScoreDistribution value="4" recordCount="4.0" confidence="1.0" /&gt;
                  &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
                &lt;/Node&gt;
              &lt;/Node&gt;
            &lt;/Node&gt;
            &lt;Node id="62" recordCount="45.0"&gt;
              &lt;SimplePredicate field="holder_index" operator="greaterThan" value="2.5" /&gt;
              &lt;Node id="63" score="2" recordCount="37.0"&gt;
                &lt;SimplePredicate field="amount" operator="lessOrEqual" value="199.13999938964844" /&gt;
                &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="2" recordCount="37.0" confidence="1.0" /&gt;
                &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="4" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
              &lt;/Node&gt;
              &lt;Node id="64" score="4" recordCount="8.0"&gt;
                &lt;SimplePredicate field="amount" operator="greaterThan" value="199.13999938964844" /&gt;
                &lt;ScoreDistribution value="1" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="2" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="3" recordCount="0.0" confidence="0.0" /&gt;
                &lt;ScoreDistribution value="4" recordCount="8.0" confidence="1.0" /&gt;
                &lt;ScoreDistribution value="5" recordCount="0.0" confidence="0.0" /&gt;
              &lt;/Node&gt;
            &lt;/Node&gt;
          &lt;/Node&gt;
        &lt;/Node&gt;
      &lt;/Node&gt;
    &lt;/Node&gt;
  &lt;/TreeModel&gt;
&lt;/PMML&gt;</programlisting>
</section>
</chapter>
<chapter xml:id="additional_resources_4" remap="_additional_resources_4">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-case-management"><emphasis>Getting started with case management</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/getting_started_with_red_hat_decision_manager#assembly-getting-started-decision-services"><emphasis>Getting started with decision services</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_decision_services_in_red_hat_decision_manager#assembly-dmn-models"><emphasis>Designing a decision service using DMN models</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_decision_manager/7.10/html-single/developing_solvers_with_red_hat_business_optimizer_in_red_hat_decision_manager#assembly-getting-started-business-optimizer"><emphasis>Getting started with Red Hat Business Optimizer</emphasis></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://go.forrester.com/blogs/predictions-2019-ai-artificial-intelligence/">Predictions 2019: Expect A Pragmatic Vision Of AI</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</part>
<appendix xml:id="versioning-information">
<title>Versioning information</title>
<simpara>Documentation last updated on Monday, January 18, 2021.</simpara>
</appendix>
<appendix xml:id="author-group">
<title>Contact information</title>
<simpara>Red Hat Decision Manager documentation team: <link xlink:href="mailto:brms-docs@redhat.com">brms-docs@redhat.com</link></simpara>
</appendix>
</book>