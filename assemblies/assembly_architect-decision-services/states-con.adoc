[id='states-con']
= Stateless versus stateful sessions

When planning your rule authoring, you must decide between stateless versus stateful sessions.

You define either stateless or stateful in the `ksession` element in the `kmodule.xml` file. By default it is set to stateful.

== Stateless sessions
A stateless session can be called like a function passing it some data and then receiving some results back. Some common use cases for stateless sessions are, but not limited to:

* Validation
** Is this person eligible for a mortgage?
* Calculation
** Compute a mortgage premium.
* Routing and Filtering
** Filter incoming messages, such as emails, into folders.
** Send incoming messages to a destination.

Let's start with a very simple example using a driver license application.

[source,java]
----
public class Applicant {
    private String name;
    private int age;
    private boolean valid;
    // getter and setter methods here
}
----

Now that we have our data model we can write our first rule. We assume that the application uses rules to reject invalid applications.

As this is a simple validation use case we will add a single rule to disqualify any applicant younger than 18.

[source]
----
package com.company.license

rule "Is of valid age"
when
    $a : Applicant( age < 18 )
then
    $a.setValid( false );
end
----

To make the engine aware of data that will be processed against the rules, we have to insert the data, much like with a database. When the Applicant instance is inserted into the engine it is evaluated against the constraints of the rules. In this case only two constraints for one rule.
We use two because the `Applicant` type is the first object type constraint and `age < 18` is the second field constraint. An object type constraint plus its zero or more field constraints is referred to as a pattern. When an inserted instance satisfies both the object type constraint and all the field constraints, it is said to be matched.

The `$a` is a binding variable which enables us to reference the matched object in the consequence. The dollar character `$` is optional, but it helps to differentiate variable names from field names. The process of matching patterns against the inserted data is often referred to as `pattern matching`.

To use this rule you must place it in a Drools file as a plain text file with .drl extension. For this example, we will name this file `licenseApplication.drl` and store it in a Kie project. A Kie project has the structure of a normal Maven project with an additional kmodule.xml file that defines the ``KieBase``s and ``KieSession``s that can be created.
The file must be located in the resources/META-INF folder of the Maven project, while all the other Drools artifacts, such as the `licenseApplication.drl` containing the former rule, must be stored in the resources folder or in any other subfolder.

Since meaningful defaults are provided for all configuration aspects, the simplest `kmodule.xml` file can contain just an empty kmodule tag as shown here:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<kmodule xmlns="http://www.drools.org/xsd/kmodule"/>
----

At this point it is possible to create a `KieContainer` that reads the files to be built from the classpath.

[source,java]
----
KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
----

The above code snippet compiles all the DRL files found on the classpath and adds the result of this compilation, a ``KieModule``, in the ``KieContainer``. If there are no errors, we create our session from the `KieContainer` and execute against some data:

[source,java]
----
StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant("Mr John Smith", 16);
assertTrue(applicant.isValid());
ksession.execute(applicant);
assertFalse(applicant.isValid());
----

The preceding code executes the data against the rules. Since the applicant is under the age of 18, the application is marked as invalid.

So far we've only used a single instance, but what if we want to use more than one, we can execute against any object implementing Iterable interface, such as a collection. We will add another class called `Application`, which has the date of the application, and we will move the `boolean valid` field to the `Application` class.

[source,java]
----
public class Applicant {
    private String name;
    private int age;
    // getter and setter methods here
}

public class Application {
    private Date dateApplied;
    private boolean valid;
    // getter and setter methods here
}
----


Now, we can add another rule to validate that the application was submitted within a certain period of time.

[source]
----
package com.company.license

rule "Is of valid age"
when
    Applicant(age < 18)
    $a : Application()
then
    $a.setValid(false);
end

rule "Application was made this year"
when
    $a : Application(dateApplied > "01-jan-2009")
then
    $a.setValid(false);
end
----

As Java arrays do not implement the `Iterable` interface, we use the `Arrays.asList(...)` JDK converter method .
The code shown below executes against an iterable list, where all collection elements are inserted before any matched rules are fired.

[source,java]
----
StatelessKieSession kSession = kContainer.newStatelessKieSession();
Applicant applicant = new Applicant("Mr John Smith", 16);
Application application = new Application();
assertTrue(application.isValid());
ksession.execute(Arrays.asList(application, applicant));
assertFalse(application.isValid());
----

The `execute(Object object)` and `execute(Iterable objects)` execute methods are convenience methods for the interface ``BatchExecutor``'s method ``execute(Command command)``.

The `KieCommands` commands factory, which is obtainable from the `KieServices` like all other factories of the KIE API, is used to create commands, so that the following is equivalent to ``execute(Iterable it)``:

[source,java]
----
ksession.execute(
    kieServices.getCommands()
                .newInsertElements(Arrays.asList(application, applicant))
  );
----

Batch Executor and Command Factory are useful when working with multiple Commands and with output identifiers for obtaining results.

[source,java]
----
KieCommands kieCommands = kieServices.getCommands();
List<Command> cmds = new ArrayList<Command>();
cmds.add(kieCommands.newInsert(new Person("Mr John Smith"), "mrSmith", true, null));
cmds.add(kieCommands.newInsert(new Person("Mr John Doe"), "mrDoe", true, null));
BatchExecutionResults results = ksession.execute(kieCommands.newBatchExecution(cmds));
assertEquals(new Person("Mr John Smith"), results.getValue("mrSmith"));
----

`CommandFactory` supports many other Commands that can be used in the `BatchExecutor` like ``StartProcess``, ``Query``, and ``SetGlobal``.


== Stateful sessions
Stateful sessions takes the specified data, executes the rules. After the rules fire, you can add more rules and fire it again. Stateful sessions are more difficult to manage and utilize more resources. Stateful sessions are long lived and allow iterative changes over time. Some common use cases for stateful sessions are, but not limited to:

* Monitoring
** Stock market monitoring and analysis for semi-automatic buying
* Diagnostics
** Fault finding, medical diagnostics
* Logistics
** Parcel tracking and delivery provisioning
* Compliance
** Validation of legality for market trades

In contrast to a stateless session, the `dispose()` method must be called afterwards to ensure there are no memory leaks, as the KieBase contains references to stateful knowledge sessions when they are created. Since stateful sessions are the most commonly used session type it, is named `KieSession` in the KIE API. `KieSession` also supports the `BatchExecutor` interface, like ``StatelessKieSession``, the only difference being that the `FireAllRules` command is not automatically called at the end for a stateful session.

The following example illustrates the monitoring use case with an example for raising a fire alarm. Using just four classes, we represent rooms in a house, each of which has one sprinkler. If a fire starts in one room, we represent that with a single `Fire` instance.

[source,java]
----
public class Room {
    private String name;
    // getter and setter methods here
}
public class Sprinkler {
    private Room room;
    private boolean on;
    // getter and setter methods here
}
public class Fire {
    private Room room;
    // getter and setter methods here
}
public class Alarm {
}
----

In the previous section on stateless sessions the concepts of inserting and matching against data were introduced. That example assumed that only a single instance of each object type was inserted and only used literal constraints. However, a house has many rooms, so rules must express relationships between objects, such as a sprinkler being in a certain room. This is best done by using a binding variable as a constraint in a pattern. This "join" process results in cross products, which are covered in the next section.

When a fire occurs, an instance of the `Fire` class is created for that room and inserted into the session. The rule uses a binding on the `room` field of the `Fire` object to constrain matching to the sprinkler for that room, which is currently off.
When this rule fires and the consequence is executed the sprinkler is turned on.

[source]
----
rule "When there is a fire turn on the sprinkler"
when
    Fire($room : room)
    $sprinkler : Sprinkler(room == $room, on == false)
then
    modify($sprinkler) {setOn(true)};
    System.out.println("Turn on the sprinkler for room " + $room.getName());
end
----

Whereas the stateless session uses standard Java syntax to modify a field, in the above rule we use the `modify` statement, which acts as a sort of "with" statement. It may contain a series of comma separated Java expressions. For example, calls to setters of the object selected by the `modify` statement's control expression. This modifies the data, and makes the engine aware of those changes so it can reason over them once more. This process is called inference, and it is essential for the stateful session's functionality.

Stateless sessions typically do not use inference, so the engine does not need to be aware of changes to data. Inference can also be turned off explicitly by using the __sequential mode__.

So far we have rules that tell us when matching data exists, but what about when it does not exist? How do we determine that a fire has been extinguished? For example, there isn't a `Fire` object. Previously, the constraints were sentences according to Propositional Logic, where the engine is constraining against individual instances. Drools also has support for First Order Logic that allows you to look at sets of data. A pattern under the keyword `not` matches when something does not exist.

The following rule turns the sprinkler off as soon as the fire in that room is extinguished.

[source]
----
rule "When the fire is gone turn off the sprinkler"
when
    $room : Room( )
    $sprinkler : Sprinkler(room == $room, on == true)
    not Fire( room == $room )
then
    modify($sprinkler) {setOn(false)};
    System.out.println("Turn off the sprinkler for room " + $room.getName());
end
----

While there is one sprinkler per room, there is just a single alarm for the building. An `Alarm` object is created when a fire occurs, but only one `Alarm` is needed for the entire building, no matter how many fires occur. Previously `not` was introduced to match the absence of a fact; now we use its complement `exists` which matches for one or more instances of some category.

[source]
----
rule "Raise the alarm when we have one or more fires"
when
    exists Fire()
then
    insert(new Alarm());
    System.out.println("Raise the alarm");
end
----

Likewise, when there are no fires we want to remove the alarm, so the `not` keyword can be used again.

[source]
----
rule "Cancel the alarm when all the fires have gone"
when
    not Fire()
    $alarm : Alarm()
then
    delete($alarm);
    System.out.println("Cancel the alarm");
end
----

Finally there is a general health status message that is printed when the application first starts and after the alarm is removed and all sprinklers are turned off.

[source]
----
rule "Status output when things are ok"
when
    not Alarm()
    not Sprinkler(on == true)
then
    System.out.println("Everything is ok");
end
----

As we did in the stateless session example, the above rules should be placed in a single DRL file and saved into the resources folder of your Maven project or one of its subfolders. We can then obtain a `KieSession` from the ``KieContainer``.
The only difference is that this time we create a stateful session, whereas before we created a stateless session.

[source,java]
----
KieServices kieServices = KieServices.Factory.get();
KieContainer kContainer = kieServices.getKieClasspathContainer();
KieSession ksession = kContainer.newKieSession();
----


With the session created you can now iterate your work with it. Four `Room` objects are created and inserted, as well as one `Sprinkler` object for each room. At this point the engine has done all of its matching, but no rules have fired yet.
Calling `ksession.fireAllRules()` allows the matched rules to fire, but without a fire that will just produce the health message.

[source,java]
----
String[] names = new String[] {"kitchen", "bedroom", "office", "livingroom"};
Map<String, Room> name2room = new HashMap<String, Room>();
for (String name: names) {
    Room room = new Room(name);
    name2room.put(name, room);
    ksession.insert(room);
    Sprinkler sprinkler = new Sprinkler(room);
    ksession.insert(sprinkler);
}

ksession.fireAllRules();
----

[source]
----
> Everything is ok
----

Now, we will create two fires and insert them; this time a reference is kept for the returned ``FactHandle``. A fact handle is an internal engine reference to the inserted instance and allows instances to be retracted or modified at a later point in time.
With the fires now in the engine, once `fireAllRules()` is called, the alarm is raised and the respective sprinklers are turned on.

[source,java]
----
Fire kitchenFire = new Fire(name2room.get("kitchen"));
Fire officeFire = new Fire(name2room.get("office"));

FactHandle kitchenFireHandle = ksession.insert(kitchenFire);
FactHandle officeFireHandle = ksession.insert(officeFire);

ksession.fireAllRules();
----

[source]
----
> Raise the alarm
> Turn on the sprinkler for room kitchen
> Turn on the sprinkler for room office
----

After all fires are extinguished the `Fire` instances are retracted. This results in the sprinklers being turned off, the alarm being cancelled, and eventually the health message is printed again.

[source,java]
----
ksession.delete(kitchenFireHandle);
ksession.delete(officeFireHandle);

ksession.fireAllRules();
----

[source]
----
> Cancel the alarm
> Turn off the sprinkler for room office
> Turn off the sprinkler for room kitchen
> Everything is ok
----
